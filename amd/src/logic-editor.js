"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __pow = Math.pow;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a2, b2) => {
    for (var prop in b2 ||= {})
      if (__hasOwnProp.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b2)) {
        if (__propIsEnum.call(b2, prop))
          __defNormalProp(a2, prop, b2[prop]);
      }
    return a2;
  };
  var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
  var __name = (target2, value) => __defProp(target2, "name", { value, configurable: true });
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target2) => (target2 = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target2, "default", { value: mod, enumerable: true }) : target2,
    mod
  ));
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // node_modules/file-saver/dist/FileSaver.min.js
  var require_FileSaver_min = __commonJS({
    "node_modules/file-saver/dist/FileSaver.min.js"(exports, module) {
      (function(a2, b2) {
        if ("function" == typeof define && define.amd)
          define([], b2);
        else if ("undefined" != typeof exports)
          b2();
        else {
          b2(), a2.FileSaver = { exports: {} }.exports;
        }
      })(exports, function() {
        "use strict";
        function b2(a3, b3) {
          return "undefined" == typeof b3 ? b3 = { autoBom: false } : "object" != typeof b3 && (console.warn("Deprecated: Expected third argument to be a object"), b3 = { autoBom: !b3 }), b3.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a3.type) ? new Blob(["\uFEFF", a3], { type: a3.type }) : a3;
        }
        __name(b2, "b");
        function c(a3, b3, c2) {
          var d2 = new XMLHttpRequest();
          d2.open("GET", a3), d2.responseType = "blob", d2.onload = function() {
            g(d2.response, b3, c2);
          }, d2.onerror = function() {
            console.error("could not download file");
          }, d2.send();
        }
        __name(c, "c");
        function d(a3) {
          var b3 = new XMLHttpRequest();
          b3.open("HEAD", a3, false);
          try {
            b3.send();
          } catch (a4) {
          }
          return 200 <= b3.status && 299 >= b3.status;
        }
        __name(d, "d");
        function e(a3) {
          try {
            a3.dispatchEvent(new MouseEvent("click"));
          } catch (c2) {
            var b3 = document.createEvent("MouseEvents");
            b3.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a3.dispatchEvent(b3);
          }
        }
        __name(e, "e");
        var f = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof global && global.global === global ? global : void 0, a2 = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f.saveAs || ("object" != typeof window || window !== f ? function() {
        } : "download" in HTMLAnchorElement.prototype && !a2 ? function(b3, g2, h) {
          var i2 = f.URL || f.webkitURL, j = document.createElement("a");
          g2 = g2 || b3.name || "download", j.download = g2, j.rel = "noopener", "string" == typeof b3 ? (j.href = b3, j.origin === location.origin ? e(j) : d(j.href) ? c(b3, g2, h) : e(j, j.target = "_blank")) : (j.href = i2.createObjectURL(b3), setTimeout(function() {
            i2.revokeObjectURL(j.href);
          }, 4e4), setTimeout(function() {
            e(j);
          }, 0));
        } : "msSaveOrOpenBlob" in navigator ? function(f2, g2, h) {
          if (g2 = g2 || f2.name || "download", "string" != typeof f2)
            navigator.msSaveOrOpenBlob(b2(f2, h), g2);
          else if (d(f2))
            c(f2, g2, h);
          else {
            var i2 = document.createElement("a");
            i2.href = f2, i2.target = "_blank", setTimeout(function() {
              e(i2);
            });
          }
        } : function(b3, d2, e2, g2) {
          if (g2 = g2 || open("", "_blank"), g2 && (g2.document.title = g2.document.body.innerText = "downloading..."), "string" == typeof b3)
            return c(b3, d2, e2);
          var h = "application/octet-stream" === b3.type, i2 = /constructor/i.test(f.HTMLElement) || f.safari, j = /CriOS\/[\d]+/.test(navigator.userAgent);
          if ((j || h && i2 || a2) && "undefined" != typeof FileReader) {
            var k = new FileReader();
            k.onloadend = function() {
              var a3 = k.result;
              a3 = j ? a3 : a3.replace(/^data:[^;]*;/, "data:attachment/file;"), g2 ? g2.location.href = a3 : location = a3, g2 = null;
            }, k.readAsDataURL(b3);
          } else {
            var l = f.URL || f.webkitURL, m = l.createObjectURL(b3);
            g2 ? g2.location = m : location.href = m, g2 = null, setTimeout(function() {
              l.revokeObjectURL(m);
            }, 4e4);
          }
        });
        f.saveAs = g.saveAs = g, "undefined" != typeof module && (module.exports = g);
      });
    }
  });

  // node_modules/json5/dist/index.js
  var require_dist = __commonJS({
    "node_modules/json5/dist/index.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.JSON5 = factory();
      })(exports, function() {
        "use strict";
        function createCommonjsModule(fn2, module2) {
          return module2 = { exports: {} }, fn2(module2, module2.exports), module2.exports;
        }
        __name(createCommonjsModule, "createCommonjsModule");
        var _global = createCommonjsModule(function(module2) {
          var global2 = module2.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
          if (typeof __g == "number") {
            __g = global2;
          }
        });
        var _core = createCommonjsModule(function(module2) {
          var core = module2.exports = { version: "2.6.5" };
          if (typeof __e == "number") {
            __e = core;
          }
        });
        var _core_1 = _core.version;
        var _isObject = /* @__PURE__ */ __name(function(it) {
          return typeof it === "object" ? it !== null : typeof it === "function";
        }, "_isObject");
        var _anObject = /* @__PURE__ */ __name(function(it) {
          if (!_isObject(it)) {
            throw TypeError(it + " is not an object!");
          }
          return it;
        }, "_anObject");
        var _fails = /* @__PURE__ */ __name(function(exec) {
          try {
            return !!exec();
          } catch (e) {
            return true;
          }
        }, "_fails");
        var _descriptors = !_fails(function() {
          return Object.defineProperty({}, "a", { get: function() {
            return 7;
          } }).a != 7;
        });
        var document2 = _global.document;
        var is = _isObject(document2) && _isObject(document2.createElement);
        var _domCreate = /* @__PURE__ */ __name(function(it) {
          return is ? document2.createElement(it) : {};
        }, "_domCreate");
        var _ie8DomDefine = !_descriptors && !_fails(function() {
          return Object.defineProperty(_domCreate("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
        var _toPrimitive = /* @__PURE__ */ __name(function(it, S2) {
          if (!_isObject(it)) {
            return it;
          }
          var fn2, val;
          if (S2 && typeof (fn2 = it.toString) == "function" && !_isObject(val = fn2.call(it))) {
            return val;
          }
          if (typeof (fn2 = it.valueOf) == "function" && !_isObject(val = fn2.call(it))) {
            return val;
          }
          if (!S2 && typeof (fn2 = it.toString) == "function" && !_isObject(val = fn2.call(it))) {
            return val;
          }
          throw TypeError("Can't convert object to primitive value");
        }, "_toPrimitive");
        var dP = Object.defineProperty;
        var f = _descriptors ? Object.defineProperty : /* @__PURE__ */ __name(function defineProperty(O, P, Attributes) {
          _anObject(O);
          P = _toPrimitive(P, true);
          _anObject(Attributes);
          if (_ie8DomDefine) {
            try {
              return dP(O, P, Attributes);
            } catch (e) {
            }
          }
          if ("get" in Attributes || "set" in Attributes) {
            throw TypeError("Accessors not supported!");
          }
          if ("value" in Attributes) {
            O[P] = Attributes.value;
          }
          return O;
        }, "defineProperty");
        var _objectDp = {
          f
        };
        var _propertyDesc = /* @__PURE__ */ __name(function(bitmap, value) {
          return {
            enumerable: !(bitmap & 1),
            configurable: !(bitmap & 2),
            writable: !(bitmap & 4),
            value
          };
        }, "_propertyDesc");
        var _hide = _descriptors ? function(object, key2, value) {
          return _objectDp.f(object, key2, _propertyDesc(1, value));
        } : function(object, key2, value) {
          object[key2] = value;
          return object;
        };
        var hasOwnProperty = {}.hasOwnProperty;
        var _has = /* @__PURE__ */ __name(function(it, key2) {
          return hasOwnProperty.call(it, key2);
        }, "_has");
        var id = 0;
        var px = Math.random();
        var _uid = /* @__PURE__ */ __name(function(key2) {
          return "Symbol(".concat(key2 === void 0 ? "" : key2, ")_", (++id + px).toString(36));
        }, "_uid");
        var _library = false;
        var _shared = createCommonjsModule(function(module2) {
          var SHARED = "__core-js_shared__";
          var store = _global[SHARED] || (_global[SHARED] = {});
          (module2.exports = function(key2, value) {
            return store[key2] || (store[key2] = value !== void 0 ? value : {});
          })("versions", []).push({
            version: _core.version,
            mode: _library ? "pure" : "global",
            copyright: "\xA9 2019 Denis Pushkarev (zloirock.ru)"
          });
        });
        var _functionToString = _shared("native-function-to-string", Function.toString);
        var _redefine = createCommonjsModule(function(module2) {
          var SRC = _uid("src");
          var TO_STRING = "toString";
          var TPL = ("" + _functionToString).split(TO_STRING);
          _core.inspectSource = function(it) {
            return _functionToString.call(it);
          };
          (module2.exports = function(O, key2, val, safe) {
            var isFunction = typeof val == "function";
            if (isFunction) {
              _has(val, "name") || _hide(val, "name", key2);
            }
            if (O[key2] === val) {
              return;
            }
            if (isFunction) {
              _has(val, SRC) || _hide(val, SRC, O[key2] ? "" + O[key2] : TPL.join(String(key2)));
            }
            if (O === _global) {
              O[key2] = val;
            } else if (!safe) {
              delete O[key2];
              _hide(O, key2, val);
            } else if (O[key2]) {
              O[key2] = val;
            } else {
              _hide(O, key2, val);
            }
          })(Function.prototype, TO_STRING, /* @__PURE__ */ __name(function toString() {
            return typeof this == "function" && this[SRC] || _functionToString.call(this);
          }, "toString"));
        });
        var _aFunction = /* @__PURE__ */ __name(function(it) {
          if (typeof it != "function") {
            throw TypeError(it + " is not a function!");
          }
          return it;
        }, "_aFunction");
        var _ctx = /* @__PURE__ */ __name(function(fn2, that, length) {
          _aFunction(fn2);
          if (that === void 0) {
            return fn2;
          }
          switch (length) {
            case 1:
              return function(a2) {
                return fn2.call(that, a2);
              };
            case 2:
              return function(a2, b2) {
                return fn2.call(that, a2, b2);
              };
            case 3:
              return function(a2, b2, c2) {
                return fn2.call(that, a2, b2, c2);
              };
          }
          return function() {
            return fn2.apply(that, arguments);
          };
        }, "_ctx");
        var PROTOTYPE = "prototype";
        var $export = /* @__PURE__ */ __name(function(type7, name2, source2) {
          var IS_FORCED = type7 & $export.F;
          var IS_GLOBAL = type7 & $export.G;
          var IS_STATIC = type7 & $export.S;
          var IS_PROTO = type7 & $export.P;
          var IS_BIND = type7 & $export.B;
          var target2 = IS_GLOBAL ? _global : IS_STATIC ? _global[name2] || (_global[name2] = {}) : (_global[name2] || {})[PROTOTYPE];
          var exports2 = IS_GLOBAL ? _core : _core[name2] || (_core[name2] = {});
          var expProto = exports2[PROTOTYPE] || (exports2[PROTOTYPE] = {});
          var key2, own, out, exp;
          if (IS_GLOBAL) {
            source2 = name2;
          }
          for (key2 in source2) {
            own = !IS_FORCED && target2 && target2[key2] !== void 0;
            out = (own ? target2 : source2)[key2];
            exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == "function" ? _ctx(Function.call, out) : out;
            if (target2) {
              _redefine(target2, key2, out, type7 & $export.U);
            }
            if (exports2[key2] != out) {
              _hide(exports2, key2, exp);
            }
            if (IS_PROTO && expProto[key2] != out) {
              expProto[key2] = out;
            }
          }
        }, "$export");
        _global.core = _core;
        $export.F = 1;
        $export.G = 2;
        $export.S = 4;
        $export.P = 8;
        $export.B = 16;
        $export.W = 32;
        $export.U = 64;
        $export.R = 128;
        var _export = $export;
        var ceil = Math.ceil;
        var floor = Math.floor;
        var _toInteger = /* @__PURE__ */ __name(function(it) {
          return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
        }, "_toInteger");
        var _defined = /* @__PURE__ */ __name(function(it) {
          if (it == void 0) {
            throw TypeError("Can't call method on  " + it);
          }
          return it;
        }, "_defined");
        var _stringAt = /* @__PURE__ */ __name(function(TO_STRING) {
          return function(that, pos2) {
            var s = String(_defined(that));
            var i2 = _toInteger(pos2);
            var l = s.length;
            var a2, b2;
            if (i2 < 0 || i2 >= l) {
              return TO_STRING ? "" : void 0;
            }
            a2 = s.charCodeAt(i2);
            return a2 < 55296 || a2 > 56319 || i2 + 1 === l || (b2 = s.charCodeAt(i2 + 1)) < 56320 || b2 > 57343 ? TO_STRING ? s.charAt(i2) : a2 : TO_STRING ? s.slice(i2, i2 + 2) : (a2 - 55296 << 10) + (b2 - 56320) + 65536;
          };
        }, "_stringAt");
        var $at = _stringAt(false);
        _export(_export.P, "String", {
          // 21.1.3.3 String.prototype.codePointAt(pos)
          codePointAt: /* @__PURE__ */ __name(function codePointAt2(pos2) {
            return $at(this, pos2);
          }, "codePointAt")
        });
        var codePointAt = _core.String.codePointAt;
        var max3 = Math.max;
        var min3 = Math.min;
        var _toAbsoluteIndex = /* @__PURE__ */ __name(function(index, length) {
          index = _toInteger(index);
          return index < 0 ? max3(index + length, 0) : min3(index, length);
        }, "_toAbsoluteIndex");
        var fromCharCode = String.fromCharCode;
        var $fromCodePoint = String.fromCodePoint;
        _export(_export.S + _export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), "String", {
          // 21.1.2.2 String.fromCodePoint(...codePoints)
          fromCodePoint: /* @__PURE__ */ __name(function fromCodePoint2(x) {
            var arguments$1 = arguments;
            var res = [];
            var aLen = arguments.length;
            var i2 = 0;
            var code;
            while (aLen > i2) {
              code = +arguments$1[i2++];
              if (_toAbsoluteIndex(code, 1114111) !== code) {
                throw RangeError(code + " is not a valid code point");
              }
              res.push(
                code < 65536 ? fromCharCode(code) : fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320)
              );
            }
            return res.join("");
          }, "fromCodePoint")
        });
        var fromCodePoint = _core.String.fromCodePoint;
        var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
        var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
        var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
        var unicode = {
          Space_Separator,
          ID_Start,
          ID_Continue
        };
        var util = {
          isSpaceSeparator: /* @__PURE__ */ __name(function isSpaceSeparator(c2) {
            return typeof c2 === "string" && unicode.Space_Separator.test(c2);
          }, "isSpaceSeparator"),
          isIdStartChar: /* @__PURE__ */ __name(function isIdStartChar2(c2) {
            return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 === "$" || c2 === "_" || unicode.ID_Start.test(c2));
          }, "isIdStartChar"),
          isIdContinueChar: /* @__PURE__ */ __name(function isIdContinueChar2(c2) {
            return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 >= "0" && c2 <= "9" || c2 === "$" || c2 === "_" || c2 === "\u200C" || c2 === "\u200D" || unicode.ID_Continue.test(c2));
          }, "isIdContinueChar"),
          isDigit: /* @__PURE__ */ __name(function isDigit2(c2) {
            return typeof c2 === "string" && /[0-9]/.test(c2);
          }, "isDigit"),
          isHexDigit: /* @__PURE__ */ __name(function isHexDigit(c2) {
            return typeof c2 === "string" && /[0-9A-Fa-f]/.test(c2);
          }, "isHexDigit")
        };
        var source;
        var parseState;
        var stack;
        var pos;
        var line;
        var column;
        var token;
        var key;
        var root;
        var parse = /* @__PURE__ */ __name(function parse2(text, reviver) {
          source = String(text);
          parseState = "start";
          stack = [];
          pos = 0;
          line = 1;
          column = 0;
          token = void 0;
          key = void 0;
          root = void 0;
          do {
            token = lex();
            parseStates[parseState]();
          } while (token.type !== "eof");
          if (typeof reviver === "function") {
            return internalize({ "": root }, "", reviver);
          }
          return root;
        }, "parse");
        function internalize(holder, name2, reviver) {
          var value = holder[name2];
          if (value != null && typeof value === "object") {
            if (Array.isArray(value)) {
              for (var i2 = 0; i2 < value.length; i2++) {
                var key2 = String(i2);
                var replacement = internalize(value, key2, reviver);
                if (replacement === void 0) {
                  delete value[key2];
                } else {
                  Object.defineProperty(value, key2, {
                    value: replacement,
                    writable: true,
                    enumerable: true,
                    configurable: true
                  });
                }
              }
            } else {
              for (var key$1 in value) {
                var replacement$1 = internalize(value, key$1, reviver);
                if (replacement$1 === void 0) {
                  delete value[key$1];
                } else {
                  Object.defineProperty(value, key$1, {
                    value: replacement$1,
                    writable: true,
                    enumerable: true,
                    configurable: true
                  });
                }
              }
            }
          }
          return reviver.call(holder, name2, value);
        }
        __name(internalize, "internalize");
        var lexState;
        var buffer;
        var doubleQuote;
        var sign;
        var c;
        function lex() {
          lexState = "default";
          buffer = "";
          doubleQuote = false;
          sign = 1;
          for (; ; ) {
            c = peek();
            var token2 = lexStates[lexState]();
            if (token2) {
              return token2;
            }
          }
        }
        __name(lex, "lex");
        function peek() {
          if (source[pos]) {
            return String.fromCodePoint(source.codePointAt(pos));
          }
        }
        __name(peek, "peek");
        function read2() {
          var c2 = peek();
          if (c2 === "\n") {
            line++;
            column = 0;
          } else if (c2) {
            column += c2.length;
          } else {
            column++;
          }
          if (c2) {
            pos += c2.length;
          }
          return c2;
        }
        __name(read2, "read");
        var lexStates = {
          default: /* @__PURE__ */ __name(function default$1() {
            switch (c) {
              case "	":
              case "\v":
              case "\f":
              case " ":
              case "\xA0":
              case "\uFEFF":
              case "\n":
              case "\r":
              case "\u2028":
              case "\u2029":
                read2();
                return;
              case "/":
                read2();
                lexState = "comment";
                return;
              case void 0:
                read2();
                return newToken("eof");
            }
            if (util.isSpaceSeparator(c)) {
              read2();
              return;
            }
            return lexStates[parseState]();
          }, "default$1"),
          comment: /* @__PURE__ */ __name(function comment() {
            switch (c) {
              case "*":
                read2();
                lexState = "multiLineComment";
                return;
              case "/":
                read2();
                lexState = "singleLineComment";
                return;
            }
            throw invalidChar(read2());
          }, "comment"),
          multiLineComment: /* @__PURE__ */ __name(function multiLineComment() {
            switch (c) {
              case "*":
                read2();
                lexState = "multiLineCommentAsterisk";
                return;
              case void 0:
                throw invalidChar(read2());
            }
            read2();
          }, "multiLineComment"),
          multiLineCommentAsterisk: /* @__PURE__ */ __name(function multiLineCommentAsterisk() {
            switch (c) {
              case "*":
                read2();
                return;
              case "/":
                read2();
                lexState = "default";
                return;
              case void 0:
                throw invalidChar(read2());
            }
            read2();
            lexState = "multiLineComment";
          }, "multiLineCommentAsterisk"),
          singleLineComment: /* @__PURE__ */ __name(function singleLineComment() {
            switch (c) {
              case "\n":
              case "\r":
              case "\u2028":
              case "\u2029":
                read2();
                lexState = "default";
                return;
              case void 0:
                read2();
                return newToken("eof");
            }
            read2();
          }, "singleLineComment"),
          value: /* @__PURE__ */ __name(function value() {
            switch (c) {
              case "{":
              case "[":
                return newToken("punctuator", read2());
              case "n":
                read2();
                literal("ull");
                return newToken("null", null);
              case "t":
                read2();
                literal("rue");
                return newToken("boolean", true);
              case "f":
                read2();
                literal("alse");
                return newToken("boolean", false);
              case "-":
              case "+":
                if (read2() === "-") {
                  sign = -1;
                }
                lexState = "sign";
                return;
              case ".":
                buffer = read2();
                lexState = "decimalPointLeading";
                return;
              case "0":
                buffer = read2();
                lexState = "zero";
                return;
              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7":
              case "8":
              case "9":
                buffer = read2();
                lexState = "decimalInteger";
                return;
              case "I":
                read2();
                literal("nfinity");
                return newToken("numeric", Infinity);
              case "N":
                read2();
                literal("aN");
                return newToken("numeric", NaN);
              case '"':
              case "'":
                doubleQuote = read2() === '"';
                buffer = "";
                lexState = "string";
                return;
            }
            throw invalidChar(read2());
          }, "value"),
          identifierNameStartEscape: /* @__PURE__ */ __name(function identifierNameStartEscape() {
            if (c !== "u") {
              throw invalidChar(read2());
            }
            read2();
            var u = unicodeEscape();
            switch (u) {
              case "$":
              case "_":
                break;
              default:
                if (!util.isIdStartChar(u)) {
                  throw invalidIdentifier();
                }
                break;
            }
            buffer += u;
            lexState = "identifierName";
          }, "identifierNameStartEscape"),
          identifierName: /* @__PURE__ */ __name(function identifierName() {
            switch (c) {
              case "$":
              case "_":
              case "\u200C":
              case "\u200D":
                buffer += read2();
                return;
              case "\\":
                read2();
                lexState = "identifierNameEscape";
                return;
            }
            if (util.isIdContinueChar(c)) {
              buffer += read2();
              return;
            }
            return newToken("identifier", buffer);
          }, "identifierName"),
          identifierNameEscape: /* @__PURE__ */ __name(function identifierNameEscape() {
            if (c !== "u") {
              throw invalidChar(read2());
            }
            read2();
            var u = unicodeEscape();
            switch (u) {
              case "$":
              case "_":
              case "\u200C":
              case "\u200D":
                break;
              default:
                if (!util.isIdContinueChar(u)) {
                  throw invalidIdentifier();
                }
                break;
            }
            buffer += u;
            lexState = "identifierName";
          }, "identifierNameEscape"),
          sign: /* @__PURE__ */ __name(function sign$1() {
            switch (c) {
              case ".":
                buffer = read2();
                lexState = "decimalPointLeading";
                return;
              case "0":
                buffer = read2();
                lexState = "zero";
                return;
              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7":
              case "8":
              case "9":
                buffer = read2();
                lexState = "decimalInteger";
                return;
              case "I":
                read2();
                literal("nfinity");
                return newToken("numeric", sign * Infinity);
              case "N":
                read2();
                literal("aN");
                return newToken("numeric", NaN);
            }
            throw invalidChar(read2());
          }, "sign$1"),
          zero: /* @__PURE__ */ __name(function zero() {
            switch (c) {
              case ".":
                buffer += read2();
                lexState = "decimalPoint";
                return;
              case "e":
              case "E":
                buffer += read2();
                lexState = "decimalExponent";
                return;
              case "x":
              case "X":
                buffer += read2();
                lexState = "hexadecimal";
                return;
            }
            return newToken("numeric", sign * 0);
          }, "zero"),
          decimalInteger: /* @__PURE__ */ __name(function decimalInteger() {
            switch (c) {
              case ".":
                buffer += read2();
                lexState = "decimalPoint";
                return;
              case "e":
              case "E":
                buffer += read2();
                lexState = "decimalExponent";
                return;
            }
            if (util.isDigit(c)) {
              buffer += read2();
              return;
            }
            return newToken("numeric", sign * Number(buffer));
          }, "decimalInteger"),
          decimalPointLeading: /* @__PURE__ */ __name(function decimalPointLeading() {
            if (util.isDigit(c)) {
              buffer += read2();
              lexState = "decimalFraction";
              return;
            }
            throw invalidChar(read2());
          }, "decimalPointLeading"),
          decimalPoint: /* @__PURE__ */ __name(function decimalPoint() {
            switch (c) {
              case "e":
              case "E":
                buffer += read2();
                lexState = "decimalExponent";
                return;
            }
            if (util.isDigit(c)) {
              buffer += read2();
              lexState = "decimalFraction";
              return;
            }
            return newToken("numeric", sign * Number(buffer));
          }, "decimalPoint"),
          decimalFraction: /* @__PURE__ */ __name(function decimalFraction() {
            switch (c) {
              case "e":
              case "E":
                buffer += read2();
                lexState = "decimalExponent";
                return;
            }
            if (util.isDigit(c)) {
              buffer += read2();
              return;
            }
            return newToken("numeric", sign * Number(buffer));
          }, "decimalFraction"),
          decimalExponent: /* @__PURE__ */ __name(function decimalExponent() {
            switch (c) {
              case "+":
              case "-":
                buffer += read2();
                lexState = "decimalExponentSign";
                return;
            }
            if (util.isDigit(c)) {
              buffer += read2();
              lexState = "decimalExponentInteger";
              return;
            }
            throw invalidChar(read2());
          }, "decimalExponent"),
          decimalExponentSign: /* @__PURE__ */ __name(function decimalExponentSign() {
            if (util.isDigit(c)) {
              buffer += read2();
              lexState = "decimalExponentInteger";
              return;
            }
            throw invalidChar(read2());
          }, "decimalExponentSign"),
          decimalExponentInteger: /* @__PURE__ */ __name(function decimalExponentInteger() {
            if (util.isDigit(c)) {
              buffer += read2();
              return;
            }
            return newToken("numeric", sign * Number(buffer));
          }, "decimalExponentInteger"),
          hexadecimal: /* @__PURE__ */ __name(function hexadecimal() {
            if (util.isHexDigit(c)) {
              buffer += read2();
              lexState = "hexadecimalInteger";
              return;
            }
            throw invalidChar(read2());
          }, "hexadecimal"),
          hexadecimalInteger: /* @__PURE__ */ __name(function hexadecimalInteger() {
            if (util.isHexDigit(c)) {
              buffer += read2();
              return;
            }
            return newToken("numeric", sign * Number(buffer));
          }, "hexadecimalInteger"),
          string: /* @__PURE__ */ __name(function string12() {
            switch (c) {
              case "\\":
                read2();
                buffer += escape();
                return;
              case '"':
                if (doubleQuote) {
                  read2();
                  return newToken("string", buffer);
                }
                buffer += read2();
                return;
              case "'":
                if (!doubleQuote) {
                  read2();
                  return newToken("string", buffer);
                }
                buffer += read2();
                return;
              case "\n":
              case "\r":
                throw invalidChar(read2());
              case "\u2028":
              case "\u2029":
                separatorChar(c);
                break;
              case void 0:
                throw invalidChar(read2());
            }
            buffer += read2();
          }, "string"),
          start: /* @__PURE__ */ __name(function start2() {
            switch (c) {
              case "{":
              case "[":
                return newToken("punctuator", read2());
            }
            lexState = "value";
          }, "start"),
          beforePropertyName: /* @__PURE__ */ __name(function beforePropertyName() {
            switch (c) {
              case "$":
              case "_":
                buffer = read2();
                lexState = "identifierName";
                return;
              case "\\":
                read2();
                lexState = "identifierNameStartEscape";
                return;
              case "}":
                return newToken("punctuator", read2());
              case '"':
              case "'":
                doubleQuote = read2() === '"';
                lexState = "string";
                return;
            }
            if (util.isIdStartChar(c)) {
              buffer += read2();
              lexState = "identifierName";
              return;
            }
            throw invalidChar(read2());
          }, "beforePropertyName"),
          afterPropertyName: /* @__PURE__ */ __name(function afterPropertyName() {
            if (c === ":") {
              return newToken("punctuator", read2());
            }
            throw invalidChar(read2());
          }, "afterPropertyName"),
          beforePropertyValue: /* @__PURE__ */ __name(function beforePropertyValue() {
            lexState = "value";
          }, "beforePropertyValue"),
          afterPropertyValue: /* @__PURE__ */ __name(function afterPropertyValue() {
            switch (c) {
              case ",":
              case "}":
                return newToken("punctuator", read2());
            }
            throw invalidChar(read2());
          }, "afterPropertyValue"),
          beforeArrayValue: /* @__PURE__ */ __name(function beforeArrayValue() {
            if (c === "]") {
              return newToken("punctuator", read2());
            }
            lexState = "value";
          }, "beforeArrayValue"),
          afterArrayValue: /* @__PURE__ */ __name(function afterArrayValue() {
            switch (c) {
              case ",":
              case "]":
                return newToken("punctuator", read2());
            }
            throw invalidChar(read2());
          }, "afterArrayValue"),
          end: /* @__PURE__ */ __name(function end2() {
            throw invalidChar(read2());
          }, "end")
        };
        function newToken(type7, value) {
          return {
            type: type7,
            value,
            line,
            column
          };
        }
        __name(newToken, "newToken");
        function literal(s) {
          for (var i2 = 0, list = s; i2 < list.length; i2 += 1) {
            var c2 = list[i2];
            var p = peek();
            if (p !== c2) {
              throw invalidChar(read2());
            }
            read2();
          }
        }
        __name(literal, "literal");
        function escape() {
          var c2 = peek();
          switch (c2) {
            case "b":
              read2();
              return "\b";
            case "f":
              read2();
              return "\f";
            case "n":
              read2();
              return "\n";
            case "r":
              read2();
              return "\r";
            case "t":
              read2();
              return "	";
            case "v":
              read2();
              return "\v";
            case "0":
              read2();
              if (util.isDigit(peek())) {
                throw invalidChar(read2());
              }
              return "\0";
            case "x":
              read2();
              return hexEscape();
            case "u":
              read2();
              return unicodeEscape();
            case "\n":
            case "\u2028":
            case "\u2029":
              read2();
              return "";
            case "\r":
              read2();
              if (peek() === "\n") {
                read2();
              }
              return "";
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              throw invalidChar(read2());
            case void 0:
              throw invalidChar(read2());
          }
          return read2();
        }
        __name(escape, "escape");
        function hexEscape() {
          var buffer2 = "";
          var c2 = peek();
          if (!util.isHexDigit(c2)) {
            throw invalidChar(read2());
          }
          buffer2 += read2();
          c2 = peek();
          if (!util.isHexDigit(c2)) {
            throw invalidChar(read2());
          }
          buffer2 += read2();
          return String.fromCodePoint(parseInt(buffer2, 16));
        }
        __name(hexEscape, "hexEscape");
        function unicodeEscape() {
          var buffer2 = "";
          var count = 4;
          while (count-- > 0) {
            var c2 = peek();
            if (!util.isHexDigit(c2)) {
              throw invalidChar(read2());
            }
            buffer2 += read2();
          }
          return String.fromCodePoint(parseInt(buffer2, 16));
        }
        __name(unicodeEscape, "unicodeEscape");
        var parseStates = {
          start: /* @__PURE__ */ __name(function start2() {
            if (token.type === "eof") {
              throw invalidEOF();
            }
            push();
          }, "start"),
          beforePropertyName: /* @__PURE__ */ __name(function beforePropertyName() {
            switch (token.type) {
              case "identifier":
              case "string":
                key = token.value;
                parseState = "afterPropertyName";
                return;
              case "punctuator":
                pop();
                return;
              case "eof":
                throw invalidEOF();
            }
          }, "beforePropertyName"),
          afterPropertyName: /* @__PURE__ */ __name(function afterPropertyName() {
            if (token.type === "eof") {
              throw invalidEOF();
            }
            parseState = "beforePropertyValue";
          }, "afterPropertyName"),
          beforePropertyValue: /* @__PURE__ */ __name(function beforePropertyValue() {
            if (token.type === "eof") {
              throw invalidEOF();
            }
            push();
          }, "beforePropertyValue"),
          beforeArrayValue: /* @__PURE__ */ __name(function beforeArrayValue() {
            if (token.type === "eof") {
              throw invalidEOF();
            }
            if (token.type === "punctuator" && token.value === "]") {
              pop();
              return;
            }
            push();
          }, "beforeArrayValue"),
          afterPropertyValue: /* @__PURE__ */ __name(function afterPropertyValue() {
            if (token.type === "eof") {
              throw invalidEOF();
            }
            switch (token.value) {
              case ",":
                parseState = "beforePropertyName";
                return;
              case "}":
                pop();
            }
          }, "afterPropertyValue"),
          afterArrayValue: /* @__PURE__ */ __name(function afterArrayValue() {
            if (token.type === "eof") {
              throw invalidEOF();
            }
            switch (token.value) {
              case ",":
                parseState = "beforeArrayValue";
                return;
              case "]":
                pop();
            }
          }, "afterArrayValue"),
          end: /* @__PURE__ */ __name(function end2() {
          }, "end")
        };
        function push() {
          var value;
          switch (token.type) {
            case "punctuator":
              switch (token.value) {
                case "{":
                  value = {};
                  break;
                case "[":
                  value = [];
                  break;
              }
              break;
            case "null":
            case "boolean":
            case "numeric":
            case "string":
              value = token.value;
              break;
          }
          if (root === void 0) {
            root = value;
          } else {
            var parent = stack[stack.length - 1];
            if (Array.isArray(parent)) {
              parent.push(value);
            } else {
              Object.defineProperty(parent, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
              });
            }
          }
          if (value !== null && typeof value === "object") {
            stack.push(value);
            if (Array.isArray(value)) {
              parseState = "beforeArrayValue";
            } else {
              parseState = "beforePropertyName";
            }
          } else {
            var current = stack[stack.length - 1];
            if (current == null) {
              parseState = "end";
            } else if (Array.isArray(current)) {
              parseState = "afterArrayValue";
            } else {
              parseState = "afterPropertyValue";
            }
          }
        }
        __name(push, "push");
        function pop() {
          stack.pop();
          var current = stack[stack.length - 1];
          if (current == null) {
            parseState = "end";
          } else if (Array.isArray(current)) {
            parseState = "afterArrayValue";
          } else {
            parseState = "afterPropertyValue";
          }
        }
        __name(pop, "pop");
        function invalidChar(c2) {
          if (c2 === void 0) {
            return syntaxError("JSON5: invalid end of input at " + line + ":" + column);
          }
          return syntaxError("JSON5: invalid character '" + formatChar(c2) + "' at " + line + ":" + column);
        }
        __name(invalidChar, "invalidChar");
        function invalidEOF() {
          return syntaxError("JSON5: invalid end of input at " + line + ":" + column);
        }
        __name(invalidEOF, "invalidEOF");
        function invalidIdentifier() {
          column -= 5;
          return syntaxError("JSON5: invalid identifier character at " + line + ":" + column);
        }
        __name(invalidIdentifier, "invalidIdentifier");
        function separatorChar(c2) {
          console.warn("JSON5: '" + formatChar(c2) + "' in strings is not valid ECMAScript; consider escaping");
        }
        __name(separatorChar, "separatorChar");
        function formatChar(c2) {
          var replacements2 = {
            "'": "\\'",
            '"': '\\"',
            "\\": "\\\\",
            "\b": "\\b",
            "\f": "\\f",
            "\n": "\\n",
            "\r": "\\r",
            "	": "\\t",
            "\v": "\\v",
            "\0": "\\0",
            "\u2028": "\\u2028",
            "\u2029": "\\u2029"
          };
          if (replacements2[c2]) {
            return replacements2[c2];
          }
          if (c2 < " ") {
            var hexString = c2.charCodeAt(0).toString(16);
            return "\\x" + ("00" + hexString).substring(hexString.length);
          }
          return c2;
        }
        __name(formatChar, "formatChar");
        function syntaxError(message) {
          var err = new SyntaxError(message);
          err.lineNumber = line;
          err.columnNumber = column;
          return err;
        }
        __name(syntaxError, "syntaxError");
        var stringify = /* @__PURE__ */ __name(function stringify2(value, replacer, space) {
          var stack2 = [];
          var indent = "";
          var propertyList;
          var replacerFunc;
          var gap = "";
          var quote;
          if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
            space = replacer.space;
            quote = replacer.quote;
            replacer = replacer.replacer;
          }
          if (typeof replacer === "function") {
            replacerFunc = replacer;
          } else if (Array.isArray(replacer)) {
            propertyList = [];
            for (var i2 = 0, list = replacer; i2 < list.length; i2 += 1) {
              var v = list[i2];
              var item = void 0;
              if (typeof v === "string") {
                item = v;
              } else if (typeof v === "number" || v instanceof String || v instanceof Number) {
                item = String(v);
              }
              if (item !== void 0 && propertyList.indexOf(item) < 0) {
                propertyList.push(item);
              }
            }
          }
          if (space instanceof Number) {
            space = Number(space);
          } else if (space instanceof String) {
            space = String(space);
          }
          if (typeof space === "number") {
            if (space > 0) {
              space = Math.min(10, Math.floor(space));
              gap = "          ".substr(0, space);
            }
          } else if (typeof space === "string") {
            gap = space.substr(0, 10);
          }
          return serializeProperty("", { "": value });
          function serializeProperty(key2, holder) {
            var value2 = holder[key2];
            if (value2 != null) {
              if (typeof value2.toJSON5 === "function") {
                value2 = value2.toJSON5(key2);
              } else if (typeof value2.toJSON === "function") {
                value2 = value2.toJSON(key2);
              }
            }
            if (replacerFunc) {
              value2 = replacerFunc.call(holder, key2, value2);
            }
            if (value2 instanceof Number) {
              value2 = Number(value2);
            } else if (value2 instanceof String) {
              value2 = String(value2);
            } else if (value2 instanceof Boolean) {
              value2 = value2.valueOf();
            }
            switch (value2) {
              case null:
                return "null";
              case true:
                return "true";
              case false:
                return "false";
            }
            if (typeof value2 === "string") {
              return quoteString2(value2, false);
            }
            if (typeof value2 === "number") {
              return String(value2);
            }
            if (typeof value2 === "object") {
              return Array.isArray(value2) ? serializeArray(value2) : serializeObject(value2);
            }
            return void 0;
          }
          __name(serializeProperty, "serializeProperty");
          function quoteString2(value2) {
            var quotes = {
              "'": 0.1,
              '"': 0.2
            };
            var replacements2 = {
              "'": "\\'",
              '"': '\\"',
              "\\": "\\\\",
              "\b": "\\b",
              "\f": "\\f",
              "\n": "\\n",
              "\r": "\\r",
              "	": "\\t",
              "\v": "\\v",
              "\0": "\\0",
              "\u2028": "\\u2028",
              "\u2029": "\\u2029"
            };
            var product = "";
            for (var i3 = 0; i3 < value2.length; i3++) {
              var c2 = value2[i3];
              switch (c2) {
                case "'":
                case '"':
                  quotes[c2]++;
                  product += c2;
                  continue;
                case "\0":
                  if (util.isDigit(value2[i3 + 1])) {
                    product += "\\x00";
                    continue;
                  }
              }
              if (replacements2[c2]) {
                product += replacements2[c2];
                continue;
              }
              if (c2 < " ") {
                var hexString = c2.charCodeAt(0).toString(16);
                product += "\\x" + ("00" + hexString).substring(hexString.length);
                continue;
              }
              product += c2;
            }
            var quoteChar = quote || Object.keys(quotes).reduce(function(a2, b2) {
              return quotes[a2] < quotes[b2] ? a2 : b2;
            });
            product = product.replace(new RegExp(quoteChar, "g"), replacements2[quoteChar]);
            return quoteChar + product + quoteChar;
          }
          __name(quoteString2, "quoteString");
          function serializeObject(value2) {
            if (stack2.indexOf(value2) >= 0) {
              throw TypeError("Converting circular structure to JSON5");
            }
            stack2.push(value2);
            var stepback = indent;
            indent = indent + gap;
            var keys = propertyList || Object.keys(value2);
            var partial4 = [];
            for (var i3 = 0, list2 = keys; i3 < list2.length; i3 += 1) {
              var key2 = list2[i3];
              var propertyString = serializeProperty(key2, value2);
              if (propertyString !== void 0) {
                var member = serializeKey(key2) + ":";
                if (gap !== "") {
                  member += " ";
                }
                member += propertyString;
                partial4.push(member);
              }
            }
            var final;
            if (partial4.length === 0) {
              final = "{}";
            } else {
              var properties;
              if (gap === "") {
                properties = partial4.join(",");
                final = "{" + properties + "}";
              } else {
                var separator = ",\n" + indent;
                properties = partial4.join(separator);
                final = "{\n" + indent + properties + ",\n" + stepback + "}";
              }
            }
            stack2.pop();
            indent = stepback;
            return final;
          }
          __name(serializeObject, "serializeObject");
          function serializeKey(key2) {
            if (key2.length === 0) {
              return quoteString2(key2, true);
            }
            var firstChar = String.fromCodePoint(key2.codePointAt(0));
            if (!util.isIdStartChar(firstChar)) {
              return quoteString2(key2, true);
            }
            for (var i3 = firstChar.length; i3 < key2.length; i3++) {
              if (!util.isIdContinueChar(String.fromCodePoint(key2.codePointAt(i3)))) {
                return quoteString2(key2, true);
              }
            }
            return key2;
          }
          __name(serializeKey, "serializeKey");
          function serializeArray(value2) {
            if (stack2.indexOf(value2) >= 0) {
              throw TypeError("Converting circular structure to JSON5");
            }
            stack2.push(value2);
            var stepback = indent;
            indent = indent + gap;
            var partial4 = [];
            for (var i3 = 0; i3 < value2.length; i3++) {
              var propertyString = serializeProperty(String(i3), value2);
              partial4.push(propertyString !== void 0 ? propertyString : "null");
            }
            var final;
            if (partial4.length === 0) {
              final = "[]";
            } else {
              if (gap === "") {
                var properties = partial4.join(",");
                final = "[" + properties + "]";
              } else {
                var separator = ",\n" + indent;
                var properties$1 = partial4.join(separator);
                final = "[\n" + indent + properties$1 + ",\n" + stepback + "]";
              }
            }
            stack2.pop();
            indent = stepback;
            return final;
          }
          __name(serializeArray, "serializeArray");
        }, "stringify");
        var JSON58 = {
          parse,
          stringify
        };
        var lib = JSON58;
        var es5 = lib;
        return es5;
      });
    }
  });

  // node_modules/lz-string/libs/lz-string.js
  var require_lz_string = __commonJS({
    "node_modules/lz-string/libs/lz-string.js"(exports, module) {
      var LZString2 = function() {
        var f = String.fromCharCode;
        var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
        var baseReverseDic = {};
        function getBaseValue(alphabet, character) {
          if (!baseReverseDic[alphabet]) {
            baseReverseDic[alphabet] = {};
            for (var i2 = 0; i2 < alphabet.length; i2++) {
              baseReverseDic[alphabet][alphabet.charAt(i2)] = i2;
            }
          }
          return baseReverseDic[alphabet][character];
        }
        __name(getBaseValue, "getBaseValue");
        var LZString3 = {
          compressToBase64: function(input2) {
            if (input2 == null)
              return "";
            var res = LZString3._compress(input2, 6, function(a2) {
              return keyStrBase64.charAt(a2);
            });
            switch (res.length % 4) {
              default:
              case 0:
                return res;
              case 1:
                return res + "===";
              case 2:
                return res + "==";
              case 3:
                return res + "=";
            }
          },
          decompressFromBase64: function(input2) {
            if (input2 == null)
              return "";
            if (input2 == "")
              return null;
            return LZString3._decompress(input2.length, 32, function(index) {
              return getBaseValue(keyStrBase64, input2.charAt(index));
            });
          },
          compressToUTF16: function(input2) {
            if (input2 == null)
              return "";
            return LZString3._compress(input2, 15, function(a2) {
              return f(a2 + 32);
            }) + " ";
          },
          decompressFromUTF16: function(compressed) {
            if (compressed == null)
              return "";
            if (compressed == "")
              return null;
            return LZString3._decompress(compressed.length, 16384, function(index) {
              return compressed.charCodeAt(index) - 32;
            });
          },
          //compress into uint8array (UCS-2 big endian format)
          compressToUint8Array: function(uncompressed) {
            var compressed = LZString3.compress(uncompressed);
            var buf = new Uint8Array(compressed.length * 2);
            for (var i2 = 0, TotalLen = compressed.length; i2 < TotalLen; i2++) {
              var current_value = compressed.charCodeAt(i2);
              buf[i2 * 2] = current_value >>> 8;
              buf[i2 * 2 + 1] = current_value % 256;
            }
            return buf;
          },
          //decompress from uint8array (UCS-2 big endian format)
          decompressFromUint8Array: function(compressed) {
            if (compressed === null || compressed === void 0) {
              return LZString3.decompress(compressed);
            } else {
              var buf = new Array(compressed.length / 2);
              for (var i2 = 0, TotalLen = buf.length; i2 < TotalLen; i2++) {
                buf[i2] = compressed[i2 * 2] * 256 + compressed[i2 * 2 + 1];
              }
              var result = [];
              buf.forEach(function(c) {
                result.push(f(c));
              });
              return LZString3.decompress(result.join(""));
            }
          },
          //compress into a string that is already URI encoded
          compressToEncodedURIComponent: function(input2) {
            if (input2 == null)
              return "";
            return LZString3._compress(input2, 6, function(a2) {
              return keyStrUriSafe.charAt(a2);
            });
          },
          //decompress from an output of compressToEncodedURIComponent
          decompressFromEncodedURIComponent: function(input2) {
            if (input2 == null)
              return "";
            if (input2 == "")
              return null;
            input2 = input2.replace(/ /g, "+");
            return LZString3._decompress(input2.length, 32, function(index) {
              return getBaseValue(keyStrUriSafe, input2.charAt(index));
            });
          },
          compress: function(uncompressed) {
            return LZString3._compress(uncompressed, 16, function(a2) {
              return f(a2);
            });
          },
          _compress: function(uncompressed, bitsPerChar, getCharFromInt) {
            if (uncompressed == null)
              return "";
            var i2, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
            for (ii = 0; ii < uncompressed.length; ii += 1) {
              context_c = uncompressed.charAt(ii);
              if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
                context_dictionary[context_c] = context_dictSize++;
                context_dictionaryToCreate[context_c] = true;
              }
              context_wc = context_w + context_c;
              if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
                context_w = context_wc;
              } else {
                if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                  if (context_w.charCodeAt(0) < 256) {
                    for (i2 = 0; i2 < context_numBits; i2++) {
                      context_data_val = context_data_val << 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                    }
                    value = context_w.charCodeAt(0);
                    for (i2 = 0; i2 < 8; i2++) {
                      context_data_val = context_data_val << 1 | value & 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value = value >> 1;
                    }
                  } else {
                    value = 1;
                    for (i2 = 0; i2 < context_numBits; i2++) {
                      context_data_val = context_data_val << 1 | value;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value = 0;
                    }
                    value = context_w.charCodeAt(0);
                    for (i2 = 0; i2 < 16; i2++) {
                      context_data_val = context_data_val << 1 | value & 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value = value >> 1;
                    }
                  }
                  context_enlargeIn--;
                  if (context_enlargeIn == 0) {
                    context_enlargeIn = Math.pow(2, context_numBits);
                    context_numBits++;
                  }
                  delete context_dictionaryToCreate[context_w];
                } else {
                  value = context_dictionary[context_w];
                  for (i2 = 0; i2 < context_numBits; i2++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                }
                context_enlargeIn--;
                if (context_enlargeIn == 0) {
                  context_enlargeIn = Math.pow(2, context_numBits);
                  context_numBits++;
                }
                context_dictionary[context_wc] = context_dictSize++;
                context_w = String(context_c);
              }
            }
            if (context_w !== "") {
              if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                if (context_w.charCodeAt(0) < 256) {
                  for (i2 = 0; i2 < context_numBits; i2++) {
                    context_data_val = context_data_val << 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                  }
                  value = context_w.charCodeAt(0);
                  for (i2 = 0; i2 < 8; i2++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                } else {
                  value = 1;
                  for (i2 = 0; i2 < context_numBits; i2++) {
                    context_data_val = context_data_val << 1 | value;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = 0;
                  }
                  value = context_w.charCodeAt(0);
                  for (i2 = 0; i2 < 16; i2++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                }
                context_enlargeIn--;
                if (context_enlargeIn == 0) {
                  context_enlargeIn = Math.pow(2, context_numBits);
                  context_numBits++;
                }
                delete context_dictionaryToCreate[context_w];
              } else {
                value = context_dictionary[context_w];
                for (i2 = 0; i2 < context_numBits; i2++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
            }
            value = 2;
            for (i2 = 0; i2 < context_numBits; i2++) {
              context_data_val = context_data_val << 1 | value & 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
            while (true) {
              context_data_val = context_data_val << 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data.push(getCharFromInt(context_data_val));
                break;
              } else
                context_data_position++;
            }
            return context_data.join("");
          },
          decompress: function(compressed) {
            if (compressed == null)
              return "";
            if (compressed == "")
              return null;
            return LZString3._decompress(compressed.length, 32768, function(index) {
              return compressed.charCodeAt(index);
            });
          },
          _decompress: function(length, resetValue, getNextValue) {
            var dictionary = [], next, enlargeIn = 4, dictSize = 4, numBits = 3, entry = "", result = [], i2, w, bits, resb, maxpower, power, c, data2 = { val: getNextValue(0), position: resetValue, index: 1 };
            for (i2 = 0; i2 < 3; i2 += 1) {
              dictionary[i2] = i2;
            }
            bits = 0;
            maxpower = Math.pow(2, 2);
            power = 1;
            while (power != maxpower) {
              resb = data2.val & data2.position;
              data2.position >>= 1;
              if (data2.position == 0) {
                data2.position = resetValue;
                data2.val = getNextValue(data2.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            switch (next = bits) {
              case 0:
                bits = 0;
                maxpower = Math.pow(2, 8);
                power = 1;
                while (power != maxpower) {
                  resb = data2.val & data2.position;
                  data2.position >>= 1;
                  if (data2.position == 0) {
                    data2.position = resetValue;
                    data2.val = getNextValue(data2.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                c = f(bits);
                break;
              case 1:
                bits = 0;
                maxpower = Math.pow(2, 16);
                power = 1;
                while (power != maxpower) {
                  resb = data2.val & data2.position;
                  data2.position >>= 1;
                  if (data2.position == 0) {
                    data2.position = resetValue;
                    data2.val = getNextValue(data2.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                c = f(bits);
                break;
              case 2:
                return "";
            }
            dictionary[3] = c;
            w = c;
            result.push(c);
            while (true) {
              if (data2.index > length) {
                return "";
              }
              bits = 0;
              maxpower = Math.pow(2, numBits);
              power = 1;
              while (power != maxpower) {
                resb = data2.val & data2.position;
                data2.position >>= 1;
                if (data2.position == 0) {
                  data2.position = resetValue;
                  data2.val = getNextValue(data2.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              switch (c = bits) {
                case 0:
                  bits = 0;
                  maxpower = Math.pow(2, 8);
                  power = 1;
                  while (power != maxpower) {
                    resb = data2.val & data2.position;
                    data2.position >>= 1;
                    if (data2.position == 0) {
                      data2.position = resetValue;
                      data2.val = getNextValue(data2.index++);
                    }
                    bits |= (resb > 0 ? 1 : 0) * power;
                    power <<= 1;
                  }
                  dictionary[dictSize++] = f(bits);
                  c = dictSize - 1;
                  enlargeIn--;
                  break;
                case 1:
                  bits = 0;
                  maxpower = Math.pow(2, 16);
                  power = 1;
                  while (power != maxpower) {
                    resb = data2.val & data2.position;
                    data2.position >>= 1;
                    if (data2.position == 0) {
                      data2.position = resetValue;
                      data2.val = getNextValue(data2.index++);
                    }
                    bits |= (resb > 0 ? 1 : 0) * power;
                    power <<= 1;
                  }
                  dictionary[dictSize++] = f(bits);
                  c = dictSize - 1;
                  enlargeIn--;
                  break;
                case 2:
                  return result.join("");
              }
              if (enlargeIn == 0) {
                enlargeIn = Math.pow(2, numBits);
                numBits++;
              }
              if (dictionary[c]) {
                entry = dictionary[c];
              } else {
                if (c === dictSize) {
                  entry = w + w.charAt(0);
                } else {
                  return null;
                }
              }
              result.push(entry);
              dictionary[dictSize++] = w + entry.charAt(0);
              enlargeIn--;
              w = entry;
              if (enlargeIn == 0) {
                enlargeIn = Math.pow(2, numBits);
                numBits++;
              }
            }
          }
        };
        return LZString3;
      }();
      if (typeof define === "function" && define.amd) {
        define(function() {
          return LZString2;
        });
      } else if (typeof module !== "undefined" && module != null) {
        module.exports = LZString2;
      } else if (typeof angular !== "undefined" && angular != null) {
        angular.module("LZString", []).factory("LZString", function() {
          return LZString2;
        });
      }
    }
  });

  // node_modules/png-metadata-writer/crc32.js
  var require_crc32 = __commonJS({
    "node_modules/png-metadata-writer/crc32.js"(exports) {
      var Crc32;
      (function(factory) {
        if (typeof DO_NOT_EXPORT_CRC === "undefined") {
          if ("object" === typeof exports) {
            factory(exports);
          } else if ("function" === typeof define && define.amd) {
            define(function() {
              var module2 = {};
              factory(module2);
              return module2;
            });
          } else {
            factory(Crc32 = {});
          }
        } else {
          factory(Crc32 = {});
        }
      })(function(CRC32) {
        CRC32.version = "1.2.0";
        function signed_crc_table() {
          var c = 0, table2 = new Array(256);
          for (var n = 0; n != 256; ++n) {
            c = n;
            c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
            c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
            c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
            c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
            c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
            c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
            c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
            c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
            table2[n] = c;
          }
          return typeof Int32Array !== "undefined" ? new Int32Array(table2) : table2;
        }
        __name(signed_crc_table, "signed_crc_table");
        var T = signed_crc_table();
        function crc32_bstr(bstr, seed) {
          var C = seed ^ -1, L = bstr.length - 1;
          for (var i2 = 0; i2 < L; ) {
            C = C >>> 8 ^ T[(C ^ bstr.charCodeAt(i2++)) & 255];
            C = C >>> 8 ^ T[(C ^ bstr.charCodeAt(i2++)) & 255];
          }
          if (i2 === L)
            C = C >>> 8 ^ T[(C ^ bstr.charCodeAt(i2)) & 255];
          return C ^ -1;
        }
        __name(crc32_bstr, "crc32_bstr");
        function crc32_buf(buf, seed) {
          if (buf.length > 1e4)
            return crc32_buf_8(buf, seed);
          var C = seed ^ -1, L = buf.length - 3;
          for (var i2 = 0; i2 < L; ) {
            C = C >>> 8 ^ T[(C ^ buf[i2++]) & 255];
            C = C >>> 8 ^ T[(C ^ buf[i2++]) & 255];
            C = C >>> 8 ^ T[(C ^ buf[i2++]) & 255];
            C = C >>> 8 ^ T[(C ^ buf[i2++]) & 255];
          }
          while (i2 < L + 3)
            C = C >>> 8 ^ T[(C ^ buf[i2++]) & 255];
          return C ^ -1;
        }
        __name(crc32_buf, "crc32_buf");
        function crc32_buf_8(buf, seed) {
          var C = seed ^ -1, L = buf.length - 7;
          for (var i2 = 0; i2 < L; ) {
            C = C >>> 8 ^ T[(C ^ buf[i2++]) & 255];
            C = C >>> 8 ^ T[(C ^ buf[i2++]) & 255];
            C = C >>> 8 ^ T[(C ^ buf[i2++]) & 255];
            C = C >>> 8 ^ T[(C ^ buf[i2++]) & 255];
            C = C >>> 8 ^ T[(C ^ buf[i2++]) & 255];
            C = C >>> 8 ^ T[(C ^ buf[i2++]) & 255];
            C = C >>> 8 ^ T[(C ^ buf[i2++]) & 255];
            C = C >>> 8 ^ T[(C ^ buf[i2++]) & 255];
          }
          while (i2 < L + 7)
            C = C >>> 8 ^ T[(C ^ buf[i2++]) & 255];
          return C ^ -1;
        }
        __name(crc32_buf_8, "crc32_buf_8");
        function crc32_str(str, seed) {
          var C = seed ^ -1;
          for (var i2 = 0, L = str.length, c, d; i2 < L; ) {
            c = str.charCodeAt(i2++);
            if (c < 128) {
              C = C >>> 8 ^ T[(C ^ c) & 255];
            } else if (c < 2048) {
              C = C >>> 8 ^ T[(C ^ (192 | c >> 6 & 31)) & 255];
              C = C >>> 8 ^ T[(C ^ (128 | c & 63)) & 255];
            } else if (c >= 55296 && c < 57344) {
              c = (c & 1023) + 64;
              d = str.charCodeAt(i2++) & 1023;
              C = C >>> 8 ^ T[(C ^ (240 | c >> 8 & 7)) & 255];
              C = C >>> 8 ^ T[(C ^ (128 | c >> 2 & 63)) & 255];
              C = C >>> 8 ^ T[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
              C = C >>> 8 ^ T[(C ^ (128 | d & 63)) & 255];
            } else {
              C = C >>> 8 ^ T[(C ^ (224 | c >> 12 & 15)) & 255];
              C = C >>> 8 ^ T[(C ^ (128 | c >> 6 & 63)) & 255];
              C = C >>> 8 ^ T[(C ^ (128 | c & 63)) & 255];
            }
          }
          return C ^ -1;
        }
        __name(crc32_str, "crc32_str");
        CRC32.table = T;
        CRC32.bstr = crc32_bstr;
        CRC32.buf = crc32_buf;
        CRC32.str = crc32_str;
      });
    }
  });

  // node_modules/png-metadata-writer/index.js
  var require_png_metadata_writer = __commonJS({
    "node_modules/png-metadata-writer/index.js"(exports, module) {
      var crc32 = require_crc32();
      var uint8 = new Uint8Array(4);
      var int32 = new Int32Array(uint8.buffer);
      var uint32 = new Uint32Array(uint8.buffer);
      var RESOLUTION_UNITS = { UNDEFINED: 0, METERS: 1, INCHES: 2 };
      function sliced(args, slice, sliceEnd) {
        var ret = [];
        var len = args.length;
        if (0 === len)
          return ret;
        var start2 = slice < 0 ? Math.max(0, slice + len) : slice || 0;
        if (sliceEnd !== void 0) {
          len = sliceEnd < 0 ? sliceEnd + len : sliceEnd;
        }
        while (len-- > start2) {
          ret[len - start2] = args[len];
        }
        return ret;
      }
      __name(sliced, "sliced");
      function textEncode(keyword, content, chunkName = "tEXt") {
        keyword = String(keyword);
        content = String(content);
        if (content.length && (!/^[\x00-\xFF]+$/.test(keyword) || !/^[\x00-\xFF]+$/.test(content))) {
          throw new Error(
            "Only Latin-1 characters are permitted in PNG tEXt chunks. You might want to consider base64 encoding and/or zEXt compression"
          );
        }
        if (keyword.length >= 80) {
          throw new Error(
            'Keyword "' + keyword + '" is longer than the 79-character limit imposed by the PNG specification'
          );
        }
        let totalSize = keyword.length + content.length + 1;
        let output = new Uint8Array(totalSize);
        let idx = 0;
        let code;
        for (let i2 = 0; i2 < keyword.length; i2++) {
          if (!(code = keyword.charCodeAt(i2))) {
            throw new Error("0x00 character is not permitted in tEXt keywords");
          }
          output[idx++] = code;
        }
        output[idx++] = 0;
        for (let j = 0; j < content.length; j++) {
          if (!(code = content.charCodeAt(j))) {
            throw new Error("0x00 character is not permitted in tEXt content");
          }
          output[idx++] = code;
        }
        return {
          name: chunkName,
          data: output
        };
      }
      __name(textEncode, "textEncode");
      function textDecode(data2) {
        if (data2.data && data2.name) {
          data2 = data2.data;
        }
        let naming = true;
        let text = "";
        let name2 = "";
        for (let i2 = 0; i2 < data2.length; i2++) {
          let code = data2[i2];
          if (naming) {
            if (code) {
              name2 += String.fromCharCode(code);
            } else {
              naming = false;
            }
          } else {
            if (code) {
              text += String.fromCharCode(code);
            } else {
              throw new Error(
                "Invalid NULL character found. 0x00 character is not permitted in tEXt content"
              );
            }
          }
        }
        return {
          keyword: name2,
          text
        };
      }
      __name(textDecode, "textDecode");
      function extractChunks2(data2) {
        if (data2[0] !== 137)
          throw new Error("Invalid .png file header");
        if (data2[1] !== 80)
          throw new Error("Invalid .png file header");
        if (data2[2] !== 78)
          throw new Error("Invalid .png file header");
        if (data2[3] !== 71)
          throw new Error("Invalid .png file header");
        if (data2[4] !== 13)
          throw new Error(
            "Invalid .png file header: possibly caused by DOS-Unix line ending conversion?"
          );
        if (data2[5] !== 10)
          throw new Error(
            "Invalid .png file header: possibly caused by DOS-Unix line ending conversion?"
          );
        if (data2[6] !== 26)
          throw new Error("Invalid .png file header");
        if (data2[7] !== 10)
          throw new Error(
            "Invalid .png file header: possibly caused by DOS-Unix line ending conversion?"
          );
        let ended = false;
        let chunks = [];
        let idx = 8;
        while (idx < data2.length) {
          uint8[3] = data2[idx++];
          uint8[2] = data2[idx++];
          uint8[1] = data2[idx++];
          uint8[0] = data2[idx++];
          let length = uint32[0] + 4;
          let chunk = new Uint8Array(length);
          chunk[0] = data2[idx++];
          chunk[1] = data2[idx++];
          chunk[2] = data2[idx++];
          chunk[3] = data2[idx++];
          let name2 = String.fromCharCode(chunk[0]) + String.fromCharCode(chunk[1]) + String.fromCharCode(chunk[2]) + String.fromCharCode(chunk[3]);
          if (!chunks.length && name2 !== "IHDR") {
            throw new Error("IHDR header missing");
          }
          if (name2 === "IEND") {
            ended = true;
            chunks.push({
              name: name2,
              data: new Uint8Array(0)
            });
            break;
          }
          for (let i2 = 4; i2 < length; i2++) {
            chunk[i2] = data2[idx++];
          }
          uint8[3] = data2[idx++];
          uint8[2] = data2[idx++];
          uint8[1] = data2[idx++];
          uint8[0] = data2[idx++];
          let crcActual = int32[0];
          let crcExpect = crc32.buf(chunk);
          if (crcExpect !== crcActual) {
            throw new Error(
              "CRC values for " + name2 + " header do not match, PNG file is likely corrupted"
            );
          }
          let chunkData = new Uint8Array(chunk.buffer.slice(4));
          chunks.push({
            name: name2,
            data: chunkData
          });
        }
        if (!ended) {
          throw new Error(".png file ended prematurely: no IEND header was found");
        }
        return chunks;
      }
      __name(extractChunks2, "extractChunks");
      function encodeChunks2(chunks) {
        let totalSize = 8;
        let idx = totalSize;
        let i2;
        for (i2 = 0; i2 < chunks.length; i2++) {
          totalSize += chunks[i2].data.length;
          totalSize += 12;
        }
        let output = new Uint8Array(totalSize);
        output[0] = 137;
        output[1] = 80;
        output[2] = 78;
        output[3] = 71;
        output[4] = 13;
        output[5] = 10;
        output[6] = 26;
        output[7] = 10;
        for (i2 = 0; i2 < chunks.length; i2++) {
          let chunk = chunks[i2];
          let name2 = chunk.name;
          let data2 = chunk.data;
          let size = data2.length;
          let nameChars = [
            name2.charCodeAt(0),
            name2.charCodeAt(1),
            name2.charCodeAt(2),
            name2.charCodeAt(3)
          ];
          uint32[0] = size;
          output[idx++] = uint8[3];
          output[idx++] = uint8[2];
          output[idx++] = uint8[1];
          output[idx++] = uint8[0];
          output[idx++] = nameChars[0];
          output[idx++] = nameChars[1];
          output[idx++] = nameChars[2];
          output[idx++] = nameChars[3];
          for (let j = 0; j < size; ) {
            output[idx++] = data2[j++];
          }
          let crcCheck = nameChars.concat(sliced(data2));
          int32[0] = crc32.buf(crcCheck);
          output[idx++] = uint8[3];
          output[idx++] = uint8[2];
          output[idx++] = uint8[1];
          output[idx++] = uint8[0];
        }
        return output;
      }
      __name(encodeChunks2, "encodeChunks");
      function readUint32(uint8array, offset2) {
        let byte1, byte2, byte3, byte4;
        byte1 = uint8array[offset2++];
        byte2 = uint8array[offset2++];
        byte3 = uint8array[offset2++];
        byte4 = uint8array[offset2];
        return 0 | byte1 << 24 | byte2 << 16 | byte3 << 8 | byte4;
      }
      __name(readUint32, "readUint32");
      function writeUInt32(uint8array, num, offset2) {
        uint8array[offset2] = (num & 4278190080) >> 24;
        uint8array[offset2 + 1] = (num & 16711680) >> 16;
        uint8array[offset2 + 2] = (num & 65280) >> 8;
        uint8array[offset2 + 3] = num & 255;
      }
      __name(writeUInt32, "writeUInt32");
      function readMetadata2(buffer) {
        let result = {};
        const chunks = extractChunks2(buffer);
        chunks.forEach((chunk) => {
          switch (chunk.name) {
            case "tEXt":
              if (!result.tEXt) {
                result.tEXt = {};
              }
              let textChunk = textDecode(chunk.data);
              result.tEXt[textChunk.keyword] = textChunk.text;
              break;
            case "pHYs":
              result.pHYs = {
                // Pixels per unit, X axis: 4 bytes (unsigned integer)
                x: readUint32(chunk.data, 0),
                // Pixels per unit, Y axis: 4 bytes (unsigned integer)
                y: readUint32(chunk.data, 4),
                unit: chunk.data[8]
              };
              break;
            case "gAMA":
            case "cHRM":
            case "sRGB":
            case "IHDR":
            case "iCCP":
            default:
              result[chunk.name] = true;
          }
        });
        return result;
      }
      __name(readMetadata2, "readMetadata");
      function writeMetadata(buffer, metadata) {
        const chunks = extractChunks2(buffer);
        insertMetadata2(chunks, metadata);
        return new Buffer.from(encodeChunks2(chunks));
      }
      __name(writeMetadata, "writeMetadata");
      function insertMetadata2(chunks, metadata) {
        if (metadata.clear) {
          for (let i2 = chunks.length - 1; i2--; ) {
            switch (chunks[i2].name) {
              case "IHDR":
              case "IDAT":
              case "IEND":
                break;
              default:
                chunks.splice(i2, 1);
            }
          }
        }
        if (metadata.tEXt) {
          for (var keyword in metadata.tEXt) {
            chunks.splice(-1, 0, textEncode(keyword, metadata.tEXt[keyword]));
          }
        }
        if (metadata.pHYs) {
          const data2 = new Uint8Array(9);
          writeUInt32(data2, metadata.pHYs.x, 0);
          writeUInt32(data2, metadata.pHYs.y, 4);
          data2[8] = metadata.pHYs.units;
          let pHYs = chunks.find((chunk) => chunk.name === "pHYs");
          if (pHYs) {
            pHYs.data = data2;
          } else {
            chunks.splice(1, 0, { name: "pHYs", data: data2 });
          }
        }
      }
      __name(insertMetadata2, "insertMetadata");
      module.exports = {
        RESOLUTION_UNITS,
        insertMetadata: insertMetadata2,
        readMetadata: readMetadata2,
        writeMetadata,
        textEncode,
        textDecode,
        extractChunks: extractChunks2,
        encodeChunks: encodeChunks2
      };
    }
  });

  // node_modules/fp-ts/lib/function.js
  var require_function = __commonJS({
    "node_modules/fp-ts/lib/function.js"(exports) {
      "use strict";
      var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
            if (ar || !(i2 in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i2);
              ar[i2] = from[i2];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.dual = exports.getEndomorphismMonoid = exports.SK = exports.hole = exports.constVoid = exports.constUndefined = exports.constNull = exports.constFalse = exports.constTrue = exports.unsafeCoerce = exports.apply = exports.getRing = exports.getSemiring = exports.getMonoid = exports.getSemigroup = exports.getBooleanAlgebra = void 0;
      exports.identity = identity2;
      exports.constant = constant;
      exports.flip = flip2;
      exports.flow = flow;
      exports.tuple = tuple4;
      exports.increment = increment;
      exports.decrement = decrement;
      exports.absurd = absurd;
      exports.tupled = tupled;
      exports.untupled = untupled;
      exports.pipe = pipe;
      exports.not = not;
      var getBooleanAlgebra = /* @__PURE__ */ __name(function(B) {
        return function() {
          return {
            meet: function(x, y) {
              return function(a2) {
                return B.meet(x(a2), y(a2));
              };
            },
            join: function(x, y) {
              return function(a2) {
                return B.join(x(a2), y(a2));
              };
            },
            zero: function() {
              return B.zero;
            },
            one: function() {
              return B.one;
            },
            implies: function(x, y) {
              return function(a2) {
                return B.implies(x(a2), y(a2));
              };
            },
            not: function(x) {
              return function(a2) {
                return B.not(x(a2));
              };
            }
          };
        };
      }, "getBooleanAlgebra");
      exports.getBooleanAlgebra = getBooleanAlgebra;
      var getSemigroup = /* @__PURE__ */ __name(function(S2) {
        return function() {
          return {
            concat: function(f, g) {
              return function(a2) {
                return S2.concat(f(a2), g(a2));
              };
            }
          };
        };
      }, "getSemigroup");
      exports.getSemigroup = getSemigroup;
      var getMonoid = /* @__PURE__ */ __name(function(M) {
        var getSemigroupM = (0, exports.getSemigroup)(M);
        return function() {
          return {
            concat: getSemigroupM().concat,
            empty: function() {
              return M.empty;
            }
          };
        };
      }, "getMonoid");
      exports.getMonoid = getMonoid;
      var getSemiring = /* @__PURE__ */ __name(function(S2) {
        return {
          add: function(f, g) {
            return function(x) {
              return S2.add(f(x), g(x));
            };
          },
          zero: function() {
            return S2.zero;
          },
          mul: function(f, g) {
            return function(x) {
              return S2.mul(f(x), g(x));
            };
          },
          one: function() {
            return S2.one;
          }
        };
      }, "getSemiring");
      exports.getSemiring = getSemiring;
      var getRing = /* @__PURE__ */ __name(function(R) {
        var S2 = (0, exports.getSemiring)(R);
        return {
          add: S2.add,
          mul: S2.mul,
          one: S2.one,
          zero: S2.zero,
          sub: function(f, g) {
            return function(x) {
              return R.sub(f(x), g(x));
            };
          }
        };
      }, "getRing");
      exports.getRing = getRing;
      var apply = /* @__PURE__ */ __name(function(a2) {
        return function(f) {
          return f(a2);
        };
      }, "apply");
      exports.apply = apply;
      function identity2(a2) {
        return a2;
      }
      __name(identity2, "identity");
      exports.unsafeCoerce = identity2;
      function constant(a2) {
        return function() {
          return a2;
        };
      }
      __name(constant, "constant");
      exports.constTrue = constant(true);
      exports.constFalse = constant(false);
      exports.constNull = constant(null);
      exports.constUndefined = constant(void 0);
      exports.constVoid = exports.constUndefined;
      function flip2(f) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (args.length > 1) {
            return f(args[1], args[0]);
          }
          return function(a2) {
            return f(a2)(args[0]);
          };
        };
      }
      __name(flip2, "flip");
      function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
        switch (arguments.length) {
          case 1:
            return ab;
          case 2:
            return function() {
              return bc(ab.apply(this, arguments));
            };
          case 3:
            return function() {
              return cd(bc(ab.apply(this, arguments)));
            };
          case 4:
            return function() {
              return de(cd(bc(ab.apply(this, arguments))));
            };
          case 5:
            return function() {
              return ef(de(cd(bc(ab.apply(this, arguments)))));
            };
          case 6:
            return function() {
              return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
            };
          case 7:
            return function() {
              return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
            };
          case 8:
            return function() {
              return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
            };
          case 9:
            return function() {
              return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
            };
        }
        return;
      }
      __name(flow, "flow");
      function tuple4() {
        var t38 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          t38[_i] = arguments[_i];
        }
        return t38;
      }
      __name(tuple4, "tuple");
      function increment(n) {
        return n + 1;
      }
      __name(increment, "increment");
      function decrement(n) {
        return n - 1;
      }
      __name(decrement, "decrement");
      function absurd(_) {
        throw new Error("Called `absurd` function which should be uncallable");
      }
      __name(absurd, "absurd");
      function tupled(f) {
        return function(a2) {
          return f.apply(void 0, a2);
        };
      }
      __name(tupled, "tupled");
      function untupled(f) {
        return function() {
          var a2 = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            a2[_i] = arguments[_i];
          }
          return f(a2);
        };
      }
      __name(untupled, "untupled");
      function pipe(a2, ab, bc, cd, de, ef, fg, gh, hi) {
        switch (arguments.length) {
          case 1:
            return a2;
          case 2:
            return ab(a2);
          case 3:
            return bc(ab(a2));
          case 4:
            return cd(bc(ab(a2)));
          case 5:
            return de(cd(bc(ab(a2))));
          case 6:
            return ef(de(cd(bc(ab(a2)))));
          case 7:
            return fg(ef(de(cd(bc(ab(a2))))));
          case 8:
            return gh(fg(ef(de(cd(bc(ab(a2)))))));
          case 9:
            return hi(gh(fg(ef(de(cd(bc(ab(a2))))))));
          default: {
            var ret = arguments[0];
            for (var i2 = 1; i2 < arguments.length; i2++) {
              ret = arguments[i2](ret);
            }
            return ret;
          }
        }
      }
      __name(pipe, "pipe");
      exports.hole = absurd;
      var SK = /* @__PURE__ */ __name(function(_, b2) {
        return b2;
      }, "SK");
      exports.SK = SK;
      function not(predicate) {
        return function(a2) {
          return !predicate(a2);
        };
      }
      __name(not, "not");
      var getEndomorphismMonoid = /* @__PURE__ */ __name(function() {
        return {
          concat: function(first, second) {
            return flow(first, second);
          },
          empty: identity2
        };
      }, "getEndomorphismMonoid");
      exports.getEndomorphismMonoid = getEndomorphismMonoid;
      var dual = /* @__PURE__ */ __name(function(arity, body) {
        var isDataFirst = typeof arity === "number" ? function(args) {
          return args.length >= arity;
        } : arity;
        return function() {
          var args = Array.from(arguments);
          if (isDataFirst(arguments)) {
            return body.apply(this, args);
          }
          return function(self2) {
            return body.apply(void 0, __spreadArray([self2], args, false));
          };
        };
      }, "dual");
      exports.dual = dual;
    }
  });

  // node_modules/fp-ts/lib/internal.js
  var require_internal = __commonJS({
    "node_modules/fp-ts/lib/internal.js"(exports) {
      "use strict";
      var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
            if (ar || !(i2 in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i2);
              ar[i2] = from[i2];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.flatMapReader = exports.flatMapTask = exports.flatMapIO = exports.flatMapEither = exports.flatMapOption = exports.flatMapNullable = exports.liftOption = exports.liftNullable = exports.fromReadonlyNonEmptyArray = exports.has = exports.emptyRecord = exports.emptyReadonlyArray = exports.tail = exports.head = exports.isNonEmpty = exports.singleton = exports.right = exports.left = exports.isRight = exports.isLeft = exports.some = exports.none = exports.isSome = exports.isNone = void 0;
      var function_1 = require_function();
      var isNone = /* @__PURE__ */ __name(function(fa) {
        return fa._tag === "None";
      }, "isNone");
      exports.isNone = isNone;
      var isSome = /* @__PURE__ */ __name(function(fa) {
        return fa._tag === "Some";
      }, "isSome");
      exports.isSome = isSome;
      exports.none = { _tag: "None" };
      var some = /* @__PURE__ */ __name(function(a2) {
        return { _tag: "Some", value: a2 };
      }, "some");
      exports.some = some;
      var isLeft2 = /* @__PURE__ */ __name(function(ma) {
        return ma._tag === "Left";
      }, "isLeft");
      exports.isLeft = isLeft2;
      var isRight = /* @__PURE__ */ __name(function(ma) {
        return ma._tag === "Right";
      }, "isRight");
      exports.isRight = isRight;
      var left2 = /* @__PURE__ */ __name(function(e) {
        return { _tag: "Left", left: e };
      }, "left");
      exports.left = left2;
      var right2 = /* @__PURE__ */ __name(function(a2) {
        return { _tag: "Right", right: a2 };
      }, "right");
      exports.right = right2;
      var singleton = /* @__PURE__ */ __name(function(a2) {
        return [a2];
      }, "singleton");
      exports.singleton = singleton;
      var isNonEmpty = /* @__PURE__ */ __name(function(as) {
        return as.length > 0;
      }, "isNonEmpty");
      exports.isNonEmpty = isNonEmpty;
      var head = /* @__PURE__ */ __name(function(as) {
        return as[0];
      }, "head");
      exports.head = head;
      var tail = /* @__PURE__ */ __name(function(as) {
        return as.slice(1);
      }, "tail");
      exports.tail = tail;
      exports.emptyReadonlyArray = [];
      exports.emptyRecord = {};
      exports.has = Object.prototype.hasOwnProperty;
      var fromReadonlyNonEmptyArray = /* @__PURE__ */ __name(function(as) {
        return __spreadArray([as[0]], as.slice(1), true);
      }, "fromReadonlyNonEmptyArray");
      exports.fromReadonlyNonEmptyArray = fromReadonlyNonEmptyArray;
      var liftNullable = /* @__PURE__ */ __name(function(F) {
        return function(f, onNullable) {
          return function() {
            var a2 = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              a2[_i] = arguments[_i];
            }
            var o = f.apply(void 0, a2);
            return F.fromEither(o == null ? (0, exports.left)(onNullable.apply(void 0, a2)) : (0, exports.right)(o));
          };
        };
      }, "liftNullable");
      exports.liftNullable = liftNullable;
      var liftOption = /* @__PURE__ */ __name(function(F) {
        return function(f, onNone) {
          return function() {
            var a2 = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              a2[_i] = arguments[_i];
            }
            var o = f.apply(void 0, a2);
            return F.fromEither((0, exports.isNone)(o) ? (0, exports.left)(onNone.apply(void 0, a2)) : (0, exports.right)(o.value));
          };
        };
      }, "liftOption");
      exports.liftOption = liftOption;
      var flatMapNullable = /* @__PURE__ */ __name(function(F, M) {
        return /* @__PURE__ */ (0, function_1.dual)(3, function(self2, f, onNullable) {
          return M.flatMap(self2, (0, exports.liftNullable)(F)(f, onNullable));
        });
      }, "flatMapNullable");
      exports.flatMapNullable = flatMapNullable;
      var flatMapOption = /* @__PURE__ */ __name(function(F, M) {
        return /* @__PURE__ */ (0, function_1.dual)(3, function(self2, f, onNone) {
          return M.flatMap(self2, (0, exports.liftOption)(F)(f, onNone));
        });
      }, "flatMapOption");
      exports.flatMapOption = flatMapOption;
      var flatMapEither = /* @__PURE__ */ __name(function(F, M) {
        return /* @__PURE__ */ (0, function_1.dual)(2, function(self2, f) {
          return M.flatMap(self2, function(a2) {
            return F.fromEither(f(a2));
          });
        });
      }, "flatMapEither");
      exports.flatMapEither = flatMapEither;
      var flatMapIO = /* @__PURE__ */ __name(function(F, M) {
        return /* @__PURE__ */ (0, function_1.dual)(2, function(self2, f) {
          return M.flatMap(self2, function(a2) {
            return F.fromIO(f(a2));
          });
        });
      }, "flatMapIO");
      exports.flatMapIO = flatMapIO;
      var flatMapTask = /* @__PURE__ */ __name(function(F, M) {
        return /* @__PURE__ */ (0, function_1.dual)(2, function(self2, f) {
          return M.flatMap(self2, function(a2) {
            return F.fromTask(f(a2));
          });
        });
      }, "flatMapTask");
      exports.flatMapTask = flatMapTask;
      var flatMapReader = /* @__PURE__ */ __name(function(F, M) {
        return /* @__PURE__ */ (0, function_1.dual)(2, function(self2, f) {
          return M.flatMap(self2, function(a2) {
            return F.fromReader(f(a2));
          });
        });
      }, "flatMapReader");
      exports.flatMapReader = flatMapReader;
    }
  });

  // node_modules/fp-ts/lib/Apply.js
  var require_Apply = __commonJS({
    "node_modules/fp-ts/lib/Apply.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ap = ap;
      exports.apFirst = apFirst;
      exports.apSecond = apSecond;
      exports.apS = apS;
      exports.getApplySemigroup = getApplySemigroup;
      exports.sequenceT = sequenceT;
      exports.sequenceS = sequenceS;
      var function_1 = require_function();
      var _ = __importStar(require_internal());
      function ap(F, G) {
        return function(fa) {
          return function(fab) {
            return F.ap(F.map(fab, function(gab) {
              return function(ga) {
                return G.ap(gab, ga);
              };
            }), fa);
          };
        };
      }
      __name(ap, "ap");
      function apFirst(A) {
        return function(second) {
          return function(first) {
            return A.ap(A.map(first, function(a2) {
              return function() {
                return a2;
              };
            }), second);
          };
        };
      }
      __name(apFirst, "apFirst");
      function apSecond(A) {
        return function(second) {
          return function(first) {
            return A.ap(A.map(first, function() {
              return function(b2) {
                return b2;
              };
            }), second);
          };
        };
      }
      __name(apSecond, "apSecond");
      function apS(F) {
        return function(name2, fb) {
          return function(fa) {
            return F.ap(F.map(fa, function(a2) {
              return function(b2) {
                var _a;
                return Object.assign({}, a2, (_a = {}, _a[name2] = b2, _a));
              };
            }), fb);
          };
        };
      }
      __name(apS, "apS");
      function getApplySemigroup(F) {
        return function(S2) {
          return {
            concat: function(first, second) {
              return F.ap(F.map(first, function(x) {
                return function(y) {
                  return S2.concat(x, y);
                };
              }), second);
            }
          };
        };
      }
      __name(getApplySemigroup, "getApplySemigroup");
      function curried(f, n, acc) {
        return function(x) {
          var combined = Array(acc.length + 1);
          for (var i2 = 0; i2 < acc.length; i2++) {
            combined[i2] = acc[i2];
          }
          combined[acc.length] = x;
          return n === 0 ? f.apply(null, combined) : curried(f, n - 1, combined);
        };
      }
      __name(curried, "curried");
      var tupleConstructors = {
        1: function(a2) {
          return [a2];
        },
        2: function(a2) {
          return function(b2) {
            return [a2, b2];
          };
        },
        3: function(a2) {
          return function(b2) {
            return function(c) {
              return [a2, b2, c];
            };
          };
        },
        4: function(a2) {
          return function(b2) {
            return function(c) {
              return function(d) {
                return [a2, b2, c, d];
              };
            };
          };
        },
        5: function(a2) {
          return function(b2) {
            return function(c) {
              return function(d) {
                return function(e) {
                  return [a2, b2, c, d, e];
                };
              };
            };
          };
        }
      };
      function getTupleConstructor(len) {
        if (!_.has.call(tupleConstructors, len)) {
          tupleConstructors[len] = curried(function_1.tuple, len - 1, []);
        }
        return tupleConstructors[len];
      }
      __name(getTupleConstructor, "getTupleConstructor");
      function sequenceT(F) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var len = args.length;
          var f = getTupleConstructor(len);
          var fas = F.map(args[0], f);
          for (var i2 = 1; i2 < len; i2++) {
            fas = F.ap(fas, args[i2]);
          }
          return fas;
        };
      }
      __name(sequenceT, "sequenceT");
      function getRecordConstructor(keys) {
        var len = keys.length;
        switch (len) {
          case 1:
            return function(a2) {
              var _a;
              return _a = {}, _a[keys[0]] = a2, _a;
            };
          case 2:
            return function(a2) {
              return function(b2) {
                var _a;
                return _a = {}, _a[keys[0]] = a2, _a[keys[1]] = b2, _a;
              };
            };
          case 3:
            return function(a2) {
              return function(b2) {
                return function(c) {
                  var _a;
                  return _a = {}, _a[keys[0]] = a2, _a[keys[1]] = b2, _a[keys[2]] = c, _a;
                };
              };
            };
          case 4:
            return function(a2) {
              return function(b2) {
                return function(c) {
                  return function(d) {
                    var _a;
                    return _a = {}, _a[keys[0]] = a2, _a[keys[1]] = b2, _a[keys[2]] = c, _a[keys[3]] = d, _a;
                  };
                };
              };
            };
          case 5:
            return function(a2) {
              return function(b2) {
                return function(c) {
                  return function(d) {
                    return function(e) {
                      var _a;
                      return _a = {}, _a[keys[0]] = a2, _a[keys[1]] = b2, _a[keys[2]] = c, _a[keys[3]] = d, _a[keys[4]] = e, _a;
                    };
                  };
                };
              };
            };
          default:
            return curried(function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var r = {};
              for (var i2 = 0; i2 < len; i2++) {
                r[keys[i2]] = args[i2];
              }
              return r;
            }, len - 1, []);
        }
      }
      __name(getRecordConstructor, "getRecordConstructor");
      function sequenceS(F) {
        return function(r) {
          var keys = Object.keys(r);
          var len = keys.length;
          var f = getRecordConstructor(keys);
          var fr = F.map(r[keys[0]], f);
          for (var i2 = 1; i2 < len; i2++) {
            fr = F.ap(fr, r[keys[i2]]);
          }
          return fr;
        };
      }
      __name(sequenceS, "sequenceS");
    }
  });

  // node_modules/fp-ts/lib/Functor.js
  var require_Functor = __commonJS({
    "node_modules/fp-ts/lib/Functor.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.map = map;
      exports.flap = flap;
      exports.bindTo = bindTo;
      exports.let = let_;
      exports.getFunctorComposition = getFunctorComposition;
      exports.as = as;
      exports.asUnit = asUnit;
      var function_1 = require_function();
      function map(F, G) {
        return function(f) {
          return function(fa) {
            return F.map(fa, function(ga) {
              return G.map(ga, f);
            });
          };
        };
      }
      __name(map, "map");
      function flap(F) {
        return function(a2) {
          return function(fab) {
            return F.map(fab, function(f) {
              return f(a2);
            });
          };
        };
      }
      __name(flap, "flap");
      function bindTo(F) {
        return function(name2) {
          return function(fa) {
            return F.map(fa, function(a2) {
              var _a;
              return _a = {}, _a[name2] = a2, _a;
            });
          };
        };
      }
      __name(bindTo, "bindTo");
      function let_(F) {
        return function(name2, f) {
          return function(fa) {
            return F.map(fa, function(a2) {
              var _a;
              return Object.assign({}, a2, (_a = {}, _a[name2] = f(a2), _a));
            });
          };
        };
      }
      __name(let_, "let_");
      function getFunctorComposition(F, G) {
        var _map = map(F, G);
        return {
          map: function(fga, f) {
            return (0, function_1.pipe)(fga, _map(f));
          }
        };
      }
      __name(getFunctorComposition, "getFunctorComposition");
      function as(F) {
        return function(self2, b2) {
          return F.map(self2, function() {
            return b2;
          });
        };
      }
      __name(as, "as");
      function asUnit(F) {
        var asM = as(F);
        return function(self2) {
          return asM(self2, void 0);
        };
      }
      __name(asUnit, "asUnit");
    }
  });

  // node_modules/fp-ts/lib/Applicative.js
  var require_Applicative = __commonJS({
    "node_modules/fp-ts/lib/Applicative.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getApplicativeMonoid = getApplicativeMonoid;
      exports.getApplicativeComposition = getApplicativeComposition;
      var Apply_1 = require_Apply();
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      function getApplicativeMonoid(F) {
        var f = (0, Apply_1.getApplySemigroup)(F);
        return function(M) {
          return {
            concat: f(M).concat,
            empty: F.of(M.empty)
          };
        };
      }
      __name(getApplicativeMonoid, "getApplicativeMonoid");
      function getApplicativeComposition(F, G) {
        var map = (0, Functor_1.getFunctorComposition)(F, G).map;
        var _ap = (0, Apply_1.ap)(F, G);
        return {
          map,
          of: function(a2) {
            return F.of(G.of(a2));
          },
          ap: function(fgab, fga) {
            return (0, function_1.pipe)(fgab, _ap(fga));
          }
        };
      }
      __name(getApplicativeComposition, "getApplicativeComposition");
    }
  });

  // node_modules/fp-ts/lib/Chain.js
  var require_Chain = __commonJS({
    "node_modules/fp-ts/lib/Chain.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.chainFirst = chainFirst;
      exports.tap = tap;
      exports.bind = bind;
      function chainFirst(M) {
        var tapM = tap(M);
        return function(f) {
          return function(first) {
            return tapM(first, f);
          };
        };
      }
      __name(chainFirst, "chainFirst");
      function tap(M) {
        return function(first, f) {
          return M.chain(first, function(a2) {
            return M.map(f(a2), function() {
              return a2;
            });
          });
        };
      }
      __name(tap, "tap");
      function bind(M) {
        return function(name2, f) {
          return function(ma) {
            return M.chain(ma, function(a2) {
              return M.map(f(a2), function(b2) {
                var _a;
                return Object.assign({}, a2, (_a = {}, _a[name2] = b2, _a));
              });
            });
          };
        };
      }
      __name(bind, "bind");
    }
  });

  // node_modules/fp-ts/lib/ChainRec.js
  var require_ChainRec = __commonJS({
    "node_modules/fp-ts/lib/ChainRec.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.tailRec = void 0;
      var tailRec = /* @__PURE__ */ __name(function(startWith, f) {
        var ab = f(startWith);
        while (ab._tag === "Left") {
          ab = f(ab.left);
        }
        return ab.right;
      }, "tailRec");
      exports.tailRec = tailRec;
    }
  });

  // node_modules/fp-ts/lib/FromEither.js
  var require_FromEither = __commonJS({
    "node_modules/fp-ts/lib/FromEither.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fromOption = fromOption;
      exports.fromPredicate = fromPredicate;
      exports.fromOptionK = fromOptionK;
      exports.chainOptionK = chainOptionK;
      exports.fromEitherK = fromEitherK;
      exports.chainEitherK = chainEitherK;
      exports.chainFirstEitherK = chainFirstEitherK;
      exports.filterOrElse = filterOrElse;
      exports.tapEither = tapEither;
      var Chain_1 = require_Chain();
      var function_1 = require_function();
      var _ = __importStar(require_internal());
      function fromOption(F) {
        return function(onNone) {
          return function(ma) {
            return F.fromEither(_.isNone(ma) ? _.left(onNone()) : _.right(ma.value));
          };
        };
      }
      __name(fromOption, "fromOption");
      function fromPredicate(F) {
        return function(predicate, onFalse) {
          return function(a2) {
            return F.fromEither(predicate(a2) ? _.right(a2) : _.left(onFalse(a2)));
          };
        };
      }
      __name(fromPredicate, "fromPredicate");
      function fromOptionK(F) {
        var fromOptionF = fromOption(F);
        return function(onNone) {
          var from = fromOptionF(onNone);
          return function(f) {
            return (0, function_1.flow)(f, from);
          };
        };
      }
      __name(fromOptionK, "fromOptionK");
      function chainOptionK(F, M) {
        var fromOptionKF = fromOptionK(F);
        return function(onNone) {
          var from = fromOptionKF(onNone);
          return function(f) {
            return function(ma) {
              return M.chain(ma, from(f));
            };
          };
        };
      }
      __name(chainOptionK, "chainOptionK");
      function fromEitherK(F) {
        return function(f) {
          return (0, function_1.flow)(f, F.fromEither);
        };
      }
      __name(fromEitherK, "fromEitherK");
      function chainEitherK(F, M) {
        var fromEitherKF = fromEitherK(F);
        return function(f) {
          return function(ma) {
            return M.chain(ma, fromEitherKF(f));
          };
        };
      }
      __name(chainEitherK, "chainEitherK");
      function chainFirstEitherK(F, M) {
        var tapEitherM = tapEither(F, M);
        return function(f) {
          return function(ma) {
            return tapEitherM(ma, f);
          };
        };
      }
      __name(chainFirstEitherK, "chainFirstEitherK");
      function filterOrElse(F, M) {
        return function(predicate, onFalse) {
          return function(ma) {
            return M.chain(ma, function(a2) {
              return F.fromEither(predicate(a2) ? _.right(a2) : _.left(onFalse(a2)));
            });
          };
        };
      }
      __name(filterOrElse, "filterOrElse");
      function tapEither(F, M) {
        var fromEither = fromEitherK(F);
        var tapM = (0, Chain_1.tap)(M);
        return function(self2, f) {
          return tapM(self2, fromEither(f));
        };
      }
      __name(tapEither, "tapEither");
    }
  });

  // node_modules/fp-ts/lib/Separated.js
  var require_Separated = __commonJS({
    "node_modules/fp-ts/lib/Separated.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.right = exports.left = exports.flap = exports.Functor = exports.Bifunctor = exports.URI = exports.bimap = exports.mapLeft = exports.map = exports.separated = void 0;
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      var separated = /* @__PURE__ */ __name(function(left3, right3) {
        return { left: left3, right: right3 };
      }, "separated");
      exports.separated = separated;
      var _map = /* @__PURE__ */ __name(function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f));
      }, "_map");
      var _mapLeft = /* @__PURE__ */ __name(function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f));
      }, "_mapLeft");
      var _bimap = /* @__PURE__ */ __name(function(fa, g, f) {
        return (0, function_1.pipe)(fa, (0, exports.bimap)(g, f));
      }, "_bimap");
      var map = /* @__PURE__ */ __name(function(f) {
        return function(fa) {
          return (0, exports.separated)((0, exports.left)(fa), f((0, exports.right)(fa)));
        };
      }, "map");
      exports.map = map;
      var mapLeft = /* @__PURE__ */ __name(function(f) {
        return function(fa) {
          return (0, exports.separated)(f((0, exports.left)(fa)), (0, exports.right)(fa));
        };
      }, "mapLeft");
      exports.mapLeft = mapLeft;
      var bimap = /* @__PURE__ */ __name(function(f, g) {
        return function(fa) {
          return (0, exports.separated)(f((0, exports.left)(fa)), g((0, exports.right)(fa)));
        };
      }, "bimap");
      exports.bimap = bimap;
      exports.URI = "Separated";
      exports.Bifunctor = {
        URI: exports.URI,
        mapLeft: _mapLeft,
        bimap: _bimap
      };
      exports.Functor = {
        URI: exports.URI,
        map: _map
      };
      exports.flap = (0, Functor_1.flap)(exports.Functor);
      var left2 = /* @__PURE__ */ __name(function(s) {
        return s.left;
      }, "left");
      exports.left = left2;
      var right2 = /* @__PURE__ */ __name(function(s) {
        return s.right;
      }, "right");
      exports.right = right2;
    }
  });

  // node_modules/fp-ts/lib/Witherable.js
  var require_Witherable = __commonJS({
    "node_modules/fp-ts/lib/Witherable.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.wiltDefault = wiltDefault;
      exports.witherDefault = witherDefault;
      exports.filterE = filterE;
      var _ = __importStar(require_internal());
      function wiltDefault(T, C) {
        return function(F) {
          var traverseF = T.traverse(F);
          return function(wa, f) {
            return F.map(traverseF(wa, f), C.separate);
          };
        };
      }
      __name(wiltDefault, "wiltDefault");
      function witherDefault(T, C) {
        return function(F) {
          var traverseF = T.traverse(F);
          return function(wa, f) {
            return F.map(traverseF(wa, f), C.compact);
          };
        };
      }
      __name(witherDefault, "witherDefault");
      function filterE(W) {
        return function(F) {
          var witherF = W.wither(F);
          return function(predicate) {
            return function(ga) {
              return witherF(ga, function(a2) {
                return F.map(predicate(a2), function(b2) {
                  return b2 ? _.some(a2) : _.none;
                });
              });
            };
          };
        };
      }
      __name(filterE, "filterE");
    }
  });

  // node_modules/fp-ts/lib/Either.js
  var require_Either = __commonJS({
    "node_modules/fp-ts/lib/Either.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.match = exports.foldW = exports.matchW = exports.isRight = exports.isLeft = exports.fromOption = exports.fromPredicate = exports.FromEither = exports.MonadThrow = exports.throwError = exports.ChainRec = exports.Extend = exports.extend = exports.Alt = exports.alt = exports.altW = exports.Bifunctor = exports.mapLeft = exports.bimap = exports.Traversable = exports.sequence = exports.traverse = exports.Foldable = exports.reduceRight = exports.foldMap = exports.reduce = exports.Monad = exports.Chain = exports.Applicative = exports.Apply = exports.ap = exports.apW = exports.Pointed = exports.of = exports.asUnit = exports.as = exports.Functor = exports.map = exports.getAltValidation = exports.getApplicativeValidation = exports.getWitherable = exports.getFilterable = exports.getCompactable = exports.getSemigroup = exports.getEq = exports.getShow = exports.URI = exports.flatMap = exports.right = exports.left = void 0;
      exports.either = exports.stringifyJSON = exports.chainFirstW = exports.chainFirst = exports.chain = exports.chainW = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.let = exports.bindTo = exports.Do = exports.exists = exports.toUnion = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.orElse = exports.orElseW = exports.swap = exports.filterOrElseW = exports.filterOrElse = exports.flatMapOption = exports.flatMapNullable = exports.liftOption = exports.liftNullable = exports.chainOptionKW = exports.chainOptionK = exports.fromOptionK = exports.duplicate = exports.flatten = exports.flattenW = exports.tap = exports.apSecondW = exports.apSecond = exports.apFirstW = exports.apFirst = exports.flap = exports.getOrElse = exports.getOrElseW = exports.fold = void 0;
      exports.getValidationMonoid = exports.getValidationSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = void 0;
      exports.toError = toError;
      exports.elem = elem;
      exports.parseJSON = parseJSON;
      exports.getValidation = getValidation;
      var Applicative_1 = require_Applicative();
      var Apply_1 = require_Apply();
      var chainable = __importStar(require_Chain());
      var ChainRec_1 = require_ChainRec();
      var FromEither_1 = require_FromEither();
      var function_1 = require_function();
      var Functor_1 = require_Functor();
      var _ = __importStar(require_internal());
      var Separated_1 = require_Separated();
      var Witherable_1 = require_Witherable();
      exports.left = _.left;
      exports.right = _.right;
      exports.flatMap = (0, function_1.dual)(2, function(ma, f) {
        return (0, exports.isLeft)(ma) ? ma : f(ma.right);
      });
      var _map = /* @__PURE__ */ __name(function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.map)(f));
      }, "_map");
      var _ap = /* @__PURE__ */ __name(function(fab, fa) {
        return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
      }, "_ap");
      var _reduce = /* @__PURE__ */ __name(function(fa, b2, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduce)(b2, f));
      }, "_reduce");
      var _foldMap = /* @__PURE__ */ __name(function(M) {
        return function(fa, f) {
          var foldMapM = (0, exports.foldMap)(M);
          return (0, function_1.pipe)(fa, foldMapM(f));
        };
      }, "_foldMap");
      var _reduceRight = /* @__PURE__ */ __name(function(fa, b2, f) {
        return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b2, f));
      }, "_reduceRight");
      var _traverse = /* @__PURE__ */ __name(function(F) {
        var traverseF = (0, exports.traverse)(F);
        return function(ta, f) {
          return (0, function_1.pipe)(ta, traverseF(f));
        };
      }, "_traverse");
      var _bimap = /* @__PURE__ */ __name(function(fa, f, g) {
        return (0, function_1.pipe)(fa, (0, exports.bimap)(f, g));
      }, "_bimap");
      var _mapLeft = /* @__PURE__ */ __name(function(fa, f) {
        return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f));
      }, "_mapLeft");
      var _alt = /* @__PURE__ */ __name(function(fa, that) {
        return (0, function_1.pipe)(fa, (0, exports.alt)(that));
      }, "_alt");
      var _extend = /* @__PURE__ */ __name(function(wa, f) {
        return (0, function_1.pipe)(wa, (0, exports.extend)(f));
      }, "_extend");
      var _chainRec = /* @__PURE__ */ __name(function(a2, f) {
        return (0, ChainRec_1.tailRec)(f(a2), function(e) {
          return (0, exports.isLeft)(e) ? (0, exports.right)((0, exports.left)(e.left)) : (0, exports.isLeft)(e.right) ? (0, exports.left)(f(e.right.left)) : (0, exports.right)((0, exports.right)(e.right.right));
        });
      }, "_chainRec");
      exports.URI = "Either";
      var getShow = /* @__PURE__ */ __name(function(SE, SA) {
        return {
          show: function(ma) {
            return (0, exports.isLeft)(ma) ? "left(".concat(SE.show(ma.left), ")") : "right(".concat(SA.show(ma.right), ")");
          }
        };
      }, "getShow");
      exports.getShow = getShow;
      var getEq = /* @__PURE__ */ __name(function(EL, EA) {
        return {
          equals: function(x, y) {
            return x === y || ((0, exports.isLeft)(x) ? (0, exports.isLeft)(y) && EL.equals(x.left, y.left) : (0, exports.isRight)(y) && EA.equals(x.right, y.right));
          }
        };
      }, "getEq");
      exports.getEq = getEq;
      var getSemigroup = /* @__PURE__ */ __name(function(S2) {
        return {
          concat: function(x, y) {
            return (0, exports.isLeft)(y) ? x : (0, exports.isLeft)(x) ? y : (0, exports.right)(S2.concat(x.right, y.right));
          }
        };
      }, "getSemigroup");
      exports.getSemigroup = getSemigroup;
      var getCompactable = /* @__PURE__ */ __name(function(M) {
        var empty = (0, exports.left)(M.empty);
        return {
          URI: exports.URI,
          _E: void 0,
          compact: function(ma) {
            return (0, exports.isLeft)(ma) ? ma : ma.right._tag === "None" ? empty : (0, exports.right)(ma.right.value);
          },
          separate: function(ma) {
            return (0, exports.isLeft)(ma) ? (0, Separated_1.separated)(ma, ma) : (0, exports.isLeft)(ma.right) ? (0, Separated_1.separated)((0, exports.right)(ma.right.left), empty) : (0, Separated_1.separated)(empty, (0, exports.right)(ma.right.right));
          }
        };
      }, "getCompactable");
      exports.getCompactable = getCompactable;
      var getFilterable = /* @__PURE__ */ __name(function(M) {
        var empty = (0, exports.left)(M.empty);
        var _a = (0, exports.getCompactable)(M), compact = _a.compact, separate = _a.separate;
        var filter = /* @__PURE__ */ __name(function(ma, predicate) {
          return (0, exports.isLeft)(ma) ? ma : predicate(ma.right) ? ma : empty;
        }, "filter");
        var partition = /* @__PURE__ */ __name(function(ma, p) {
          return (0, exports.isLeft)(ma) ? (0, Separated_1.separated)(ma, ma) : p(ma.right) ? (0, Separated_1.separated)(empty, (0, exports.right)(ma.right)) : (0, Separated_1.separated)((0, exports.right)(ma.right), empty);
        }, "partition");
        return {
          URI: exports.URI,
          _E: void 0,
          map: _map,
          compact,
          separate,
          filter,
          filterMap: function(ma, f) {
            if ((0, exports.isLeft)(ma)) {
              return ma;
            }
            var ob = f(ma.right);
            return ob._tag === "None" ? empty : (0, exports.right)(ob.value);
          },
          partition,
          partitionMap: function(ma, f) {
            if ((0, exports.isLeft)(ma)) {
              return (0, Separated_1.separated)(ma, ma);
            }
            var e = f(ma.right);
            return (0, exports.isLeft)(e) ? (0, Separated_1.separated)((0, exports.right)(e.left), empty) : (0, Separated_1.separated)(empty, (0, exports.right)(e.right));
          }
        };
      }, "getFilterable");
      exports.getFilterable = getFilterable;
      var getWitherable = /* @__PURE__ */ __name(function(M) {
        var F_ = (0, exports.getFilterable)(M);
        var C = (0, exports.getCompactable)(M);
        return {
          URI: exports.URI,
          _E: void 0,
          map: _map,
          compact: F_.compact,
          separate: F_.separate,
          filter: F_.filter,
          filterMap: F_.filterMap,
          partition: F_.partition,
          partitionMap: F_.partitionMap,
          traverse: _traverse,
          sequence: exports.sequence,
          reduce: _reduce,
          foldMap: _foldMap,
          reduceRight: _reduceRight,
          wither: (0, Witherable_1.witherDefault)(exports.Traversable, C),
          wilt: (0, Witherable_1.wiltDefault)(exports.Traversable, C)
        };
      }, "getWitherable");
      exports.getWitherable = getWitherable;
      var getApplicativeValidation = /* @__PURE__ */ __name(function(SE) {
        return {
          URI: exports.URI,
          _E: void 0,
          map: _map,
          ap: function(fab, fa) {
            return (0, exports.isLeft)(fab) ? (0, exports.isLeft)(fa) ? (0, exports.left)(SE.concat(fab.left, fa.left)) : fab : (0, exports.isLeft)(fa) ? fa : (0, exports.right)(fab.right(fa.right));
          },
          of: exports.of
        };
      }, "getApplicativeValidation");
      exports.getApplicativeValidation = getApplicativeValidation;
      var getAltValidation = /* @__PURE__ */ __name(function(SE) {
        return {
          URI: exports.URI,
          _E: void 0,
          map: _map,
          alt: function(me, that) {
            if ((0, exports.isRight)(me)) {
              return me;
            }
            var ea = that();
            return (0, exports.isLeft)(ea) ? (0, exports.left)(SE.concat(me.left, ea.left)) : ea;
          }
        };
      }, "getAltValidation");
      exports.getAltValidation = getAltValidation;
      var map = /* @__PURE__ */ __name(function(f) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? fa : (0, exports.right)(f(fa.right));
        };
      }, "map");
      exports.map = map;
      exports.Functor = {
        URI: exports.URI,
        map: _map
      };
      exports.as = (0, function_1.dual)(2, (0, Functor_1.as)(exports.Functor));
      exports.asUnit = (0, Functor_1.asUnit)(exports.Functor);
      exports.of = exports.right;
      exports.Pointed = {
        URI: exports.URI,
        of: exports.of
      };
      var apW = /* @__PURE__ */ __name(function(fa) {
        return function(fab) {
          return (0, exports.isLeft)(fab) ? fab : (0, exports.isLeft)(fa) ? fa : (0, exports.right)(fab.right(fa.right));
        };
      }, "apW");
      exports.apW = apW;
      exports.ap = exports.apW;
      exports.Apply = {
        URI: exports.URI,
        map: _map,
        ap: _ap
      };
      exports.Applicative = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of
      };
      exports.Chain = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: exports.flatMap
      };
      exports.Monad = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: exports.flatMap
      };
      var reduce = /* @__PURE__ */ __name(function(b2, f) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? b2 : f(b2, fa.right);
        };
      }, "reduce");
      exports.reduce = reduce;
      var foldMap = /* @__PURE__ */ __name(function(M) {
        return function(f) {
          return function(fa) {
            return (0, exports.isLeft)(fa) ? M.empty : f(fa.right);
          };
        };
      }, "foldMap");
      exports.foldMap = foldMap;
      var reduceRight = /* @__PURE__ */ __name(function(b2, f) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? b2 : f(fa.right, b2);
        };
      }, "reduceRight");
      exports.reduceRight = reduceRight;
      exports.Foldable = {
        URI: exports.URI,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight
      };
      var traverse = /* @__PURE__ */ __name(function(F) {
        return function(f) {
          return function(ta) {
            return (0, exports.isLeft)(ta) ? F.of((0, exports.left)(ta.left)) : F.map(f(ta.right), exports.right);
          };
        };
      }, "traverse");
      exports.traverse = traverse;
      var sequence = /* @__PURE__ */ __name(function(F) {
        return function(ma) {
          return (0, exports.isLeft)(ma) ? F.of((0, exports.left)(ma.left)) : F.map(ma.right, exports.right);
        };
      }, "sequence");
      exports.sequence = sequence;
      exports.Traversable = {
        URI: exports.URI,
        map: _map,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence
      };
      var bimap = /* @__PURE__ */ __name(function(f, g) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? (0, exports.left)(f(fa.left)) : (0, exports.right)(g(fa.right));
        };
      }, "bimap");
      exports.bimap = bimap;
      var mapLeft = /* @__PURE__ */ __name(function(f) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? (0, exports.left)(f(fa.left)) : fa;
        };
      }, "mapLeft");
      exports.mapLeft = mapLeft;
      exports.Bifunctor = {
        URI: exports.URI,
        bimap: _bimap,
        mapLeft: _mapLeft
      };
      var altW = /* @__PURE__ */ __name(function(that) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? that() : fa;
        };
      }, "altW");
      exports.altW = altW;
      exports.alt = exports.altW;
      exports.Alt = {
        URI: exports.URI,
        map: _map,
        alt: _alt
      };
      var extend = /* @__PURE__ */ __name(function(f) {
        return function(wa) {
          return (0, exports.isLeft)(wa) ? wa : (0, exports.right)(f(wa));
        };
      }, "extend");
      exports.extend = extend;
      exports.Extend = {
        URI: exports.URI,
        map: _map,
        extend: _extend
      };
      exports.ChainRec = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        chain: exports.flatMap,
        chainRec: _chainRec
      };
      exports.throwError = exports.left;
      exports.MonadThrow = {
        URI: exports.URI,
        map: _map,
        ap: _ap,
        of: exports.of,
        chain: exports.flatMap,
        throwError: exports.throwError
      };
      exports.FromEither = {
        URI: exports.URI,
        fromEither: function_1.identity
      };
      exports.fromPredicate = (0, FromEither_1.fromPredicate)(exports.FromEither);
      exports.fromOption = /* @__PURE__ */ (0, FromEither_1.fromOption)(exports.FromEither);
      exports.isLeft = _.isLeft;
      exports.isRight = _.isRight;
      var matchW = /* @__PURE__ */ __name(function(onLeft, onRight) {
        return function(ma) {
          return (0, exports.isLeft)(ma) ? onLeft(ma.left) : onRight(ma.right);
        };
      }, "matchW");
      exports.matchW = matchW;
      exports.foldW = exports.matchW;
      exports.match = exports.matchW;
      exports.fold = exports.match;
      var getOrElseW = /* @__PURE__ */ __name(function(onLeft) {
        return function(ma) {
          return (0, exports.isLeft)(ma) ? onLeft(ma.left) : ma.right;
        };
      }, "getOrElseW");
      exports.getOrElseW = getOrElseW;
      exports.getOrElse = exports.getOrElseW;
      exports.flap = (0, Functor_1.flap)(exports.Functor);
      exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
      exports.apFirstW = exports.apFirst;
      exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
      exports.apSecondW = exports.apSecond;
      exports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));
      exports.flattenW = /* @__PURE__ */ (0, exports.flatMap)(function_1.identity);
      exports.flatten = exports.flattenW;
      exports.duplicate = (0, exports.extend)(function_1.identity);
      exports.fromOptionK = /* @__PURE__ */ (0, FromEither_1.fromOptionK)(exports.FromEither);
      exports.chainOptionK = (0, FromEither_1.chainOptionK)(exports.FromEither, exports.Chain);
      exports.chainOptionKW = exports.chainOptionK;
      var _FromEither = {
        fromEither: exports.FromEither.fromEither
      };
      exports.liftNullable = _.liftNullable(_FromEither);
      exports.liftOption = _.liftOption(_FromEither);
      var _FlatMap = {
        flatMap: exports.flatMap
      };
      exports.flatMapNullable = _.flatMapNullable(_FromEither, _FlatMap);
      exports.flatMapOption = _.flatMapOption(_FromEither, _FlatMap);
      exports.filterOrElse = (0, FromEither_1.filterOrElse)(exports.FromEither, exports.Chain);
      exports.filterOrElseW = exports.filterOrElse;
      var swap = /* @__PURE__ */ __name(function(ma) {
        return (0, exports.isLeft)(ma) ? (0, exports.right)(ma.left) : (0, exports.left)(ma.right);
      }, "swap");
      exports.swap = swap;
      var orElseW = /* @__PURE__ */ __name(function(onLeft) {
        return function(ma) {
          return (0, exports.isLeft)(ma) ? onLeft(ma.left) : ma;
        };
      }, "orElseW");
      exports.orElseW = orElseW;
      exports.orElse = exports.orElseW;
      var fromNullable = /* @__PURE__ */ __name(function(e) {
        return function(a2) {
          return a2 == null ? (0, exports.left)(e) : (0, exports.right)(a2);
        };
      }, "fromNullable");
      exports.fromNullable = fromNullable;
      var tryCatch = /* @__PURE__ */ __name(function(f, onThrow) {
        try {
          return (0, exports.right)(f());
        } catch (e) {
          return (0, exports.left)(onThrow(e));
        }
      }, "tryCatch");
      exports.tryCatch = tryCatch;
      var tryCatchK = /* @__PURE__ */ __name(function(f, onThrow) {
        return function() {
          var a2 = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            a2[_i] = arguments[_i];
          }
          return (0, exports.tryCatch)(function() {
            return f.apply(void 0, a2);
          }, onThrow);
        };
      }, "tryCatchK");
      exports.tryCatchK = tryCatchK;
      var fromNullableK = /* @__PURE__ */ __name(function(e) {
        var from = (0, exports.fromNullable)(e);
        return function(f) {
          return (0, function_1.flow)(f, from);
        };
      }, "fromNullableK");
      exports.fromNullableK = fromNullableK;
      var chainNullableK = /* @__PURE__ */ __name(function(e) {
        var from = (0, exports.fromNullableK)(e);
        return function(f) {
          return (0, exports.flatMap)(from(f));
        };
      }, "chainNullableK");
      exports.chainNullableK = chainNullableK;
      exports.toUnion = (0, exports.foldW)(function_1.identity, function_1.identity);
      function toError(e) {
        try {
          return e instanceof Error ? e : new Error(String(e));
        } catch (error) {
          return new Error();
        }
      }
      __name(toError, "toError");
      function elem(E) {
        return function(a2, ma) {
          if (ma === void 0) {
            var elemE_1 = elem(E);
            return function(ma2) {
              return elemE_1(a2, ma2);
            };
          }
          return (0, exports.isLeft)(ma) ? false : E.equals(a2, ma.right);
        };
      }
      __name(elem, "elem");
      var exists = /* @__PURE__ */ __name(function(predicate) {
        return function(ma) {
          return (0, exports.isLeft)(ma) ? false : predicate(ma.right);
        };
      }, "exists");
      exports.exists = exists;
      exports.Do = (0, exports.of)(_.emptyRecord);
      exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
      var let_ = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
      exports.let = let_;
      exports.bind = chainable.bind(exports.Chain);
      exports.bindW = exports.bind;
      exports.apS = (0, Apply_1.apS)(exports.Apply);
      exports.apSW = exports.apS;
      exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
      var traverseReadonlyNonEmptyArrayWithIndex = /* @__PURE__ */ __name(function(f) {
        return function(as) {
          var e = f(0, _.head(as));
          if ((0, exports.isLeft)(e)) {
            return e;
          }
          var out = [e.right];
          for (var i2 = 1; i2 < as.length; i2++) {
            var e_1 = f(i2, as[i2]);
            if ((0, exports.isLeft)(e_1)) {
              return e_1;
            }
            out.push(e_1.right);
          }
          return (0, exports.right)(out);
        };
      }, "traverseReadonlyNonEmptyArrayWithIndex");
      exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
      var traverseReadonlyArrayWithIndex = /* @__PURE__ */ __name(function(f) {
        var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f);
        return function(as) {
          return _.isNonEmpty(as) ? g(as) : exports.ApT;
        };
      }, "traverseReadonlyArrayWithIndex");
      exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
      exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
      var traverseArray = /* @__PURE__ */ __name(function(f) {
        return (0, exports.traverseReadonlyArrayWithIndex)(function(_2, a2) {
          return f(a2);
        });
      }, "traverseArray");
      exports.traverseArray = traverseArray;
      exports.sequenceArray = /* @__PURE__ */ (0, exports.traverseArray)(function_1.identity);
      exports.chainW = exports.flatMap;
      exports.chain = exports.flatMap;
      exports.chainFirst = exports.tap;
      exports.chainFirstW = exports.tap;
      function parseJSON(s, onError) {
        return (0, exports.tryCatch)(function() {
          return JSON.parse(s);
        }, onError);
      }
      __name(parseJSON, "parseJSON");
      var stringifyJSON = /* @__PURE__ */ __name(function(u, onError) {
        return (0, exports.tryCatch)(function() {
          var s = JSON.stringify(u);
          if (typeof s !== "string") {
            throw new Error("Converting unsupported structure to JSON");
          }
          return s;
        }, onError);
      }, "stringifyJSON");
      exports.stringifyJSON = stringifyJSON;
      exports.either = {
        URI: exports.URI,
        map: _map,
        of: exports.of,
        ap: _ap,
        chain: exports.flatMap,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        traverse: _traverse,
        sequence: exports.sequence,
        bimap: _bimap,
        mapLeft: _mapLeft,
        alt: _alt,
        extend: _extend,
        chainRec: _chainRec,
        throwError: exports.throwError
      };
      exports.getApplySemigroup = /* @__PURE__ */ (0, Apply_1.getApplySemigroup)(exports.Apply);
      exports.getApplyMonoid = /* @__PURE__ */ (0, Applicative_1.getApplicativeMonoid)(exports.Applicative);
      var getValidationSemigroup = /* @__PURE__ */ __name(function(SE, SA) {
        return (0, Apply_1.getApplySemigroup)((0, exports.getApplicativeValidation)(SE))(SA);
      }, "getValidationSemigroup");
      exports.getValidationSemigroup = getValidationSemigroup;
      var getValidationMonoid = /* @__PURE__ */ __name(function(SE, MA) {
        return (0, Applicative_1.getApplicativeMonoid)((0, exports.getApplicativeValidation)(SE))(MA);
      }, "getValidationMonoid");
      exports.getValidationMonoid = getValidationMonoid;
      function getValidation(SE) {
        var ap = (0, exports.getApplicativeValidation)(SE).ap;
        var alt = (0, exports.getAltValidation)(SE).alt;
        return {
          URI: exports.URI,
          _E: void 0,
          map: _map,
          of: exports.of,
          chain: exports.flatMap,
          bimap: _bimap,
          mapLeft: _mapLeft,
          reduce: _reduce,
          foldMap: _foldMap,
          reduceRight: _reduceRight,
          extend: _extend,
          traverse: _traverse,
          sequence: exports.sequence,
          chainRec: _chainRec,
          throwError: exports.throwError,
          ap,
          alt
        };
      }
      __name(getValidation, "getValidation");
    }
  });

  // node_modules/io-ts/lib/index.js
  var require_lib = __commonJS({
    "node_modules/io-ts/lib/index.js"(exports) {
      "use strict";
      var __extends = exports && exports.__extends || function() {
        var extendStatics = /* @__PURE__ */ __name(function(d, b2) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p))
                d2[p] = b3[p];
          };
          return extendStatics(d, b2);
        }, "extendStatics");
        return function(d, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d, b2);
          function __() {
            this.constructor = d;
          }
          __name(__, "__");
          d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      var __assign = exports && exports.__assign || function() {
        __assign = Object.assign || function(t38) {
          for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
            s = arguments[i2];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t38[p] = s[p];
          }
          return t38;
        };
        return __assign.apply(this, arguments);
      };
      var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
            if (ar || !(i2 in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i2);
              ar[i2] = from[i2];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.partial = exports.PartialType = exports.type = exports.InterfaceType = exports.array = exports.ArrayType = exports.recursion = exports.RecursiveType = exports.Int = exports.brand = exports.RefinementType = exports.keyof = exports.KeyofType = exports.literal = exports.LiteralType = exports.void = exports.undefined = exports.null = exports.UnknownRecord = exports.AnyDictionaryType = exports.UnknownArray = exports.AnyArrayType = exports.boolean = exports.BooleanType = exports.bigint = exports.BigIntType = exports.number = exports.NumberType = exports.string = exports.StringType = exports.unknown = exports.UnknownType = exports.voidType = exports.VoidType = exports.UndefinedType = exports.nullType = exports.NullType = exports.getIndex = exports.getTags = exports.emptyTags = exports.mergeAll = exports.getDomainKeys = exports.appendContext = exports.getContextEntry = exports.getFunctionName = exports.identity = exports.Type = exports.success = exports.failure = exports.failures = void 0;
      exports.alias = exports.clean = exports.StrictType = exports.dictionary = exports.object = exports.ObjectType = exports.Dictionary = exports.getDefaultContext = exports.getValidationError = exports.interface = exports.Array = exports.taggedUnion = exports.TaggedUnionType = exports.Integer = exports.refinement = exports.any = exports.AnyType = exports.never = exports.NeverType = exports.Function = exports.FunctionType = exports.exact = exports.ExactType = exports.strict = exports.readonlyArray = exports.ReadonlyArrayType = exports.readonly = exports.ReadonlyType = exports.tuple = exports.TupleType = exports.intersection = exports.IntersectionType = exports.union = exports.UnionType = exports.record = exports.DictionaryType = void 0;
      var Either_1 = require_Either();
      exports.failures = Either_1.left;
      var failure2 = /* @__PURE__ */ __name(function(value, context, message) {
        return (0, exports.failures)([{ value, context, message }]);
      }, "failure");
      exports.failure = failure2;
      exports.success = Either_1.right;
      var Type2 = (
        /** @class */
        function() {
          function Type3(name2, is, validate, encode) {
            this.name = name2;
            this.is = is;
            this.validate = validate;
            this.encode = encode;
            this.decode = this.decode.bind(this);
          }
          __name(Type3, "Type");
          Type3.prototype.pipe = function(ab, name2) {
            var _this = this;
            if (name2 === void 0) {
              name2 = "pipe(".concat(this.name, ", ").concat(ab.name, ")");
            }
            return new Type3(name2, ab.is, function(i2, c) {
              var e = _this.validate(i2, c);
              if ((0, Either_1.isLeft)(e)) {
                return e;
              }
              return ab.validate(e.right, c);
            }, this.encode === exports.identity && ab.encode === exports.identity ? exports.identity : function(b2) {
              return _this.encode(ab.encode(b2));
            });
          };
          Type3.prototype.asDecoder = function() {
            return this;
          };
          Type3.prototype.asEncoder = function() {
            return this;
          };
          Type3.prototype.decode = function(i2) {
            return this.validate(i2, [{ key: "", type: this, actual: i2 }]);
          };
          return Type3;
        }()
      );
      exports.Type = Type2;
      var identity2 = /* @__PURE__ */ __name(function(a2) {
        return a2;
      }, "identity");
      exports.identity = identity2;
      function getFunctionName(f) {
        return f.displayName || f.name || "<function".concat(f.length, ">");
      }
      __name(getFunctionName, "getFunctionName");
      exports.getFunctionName = getFunctionName;
      function getContextEntry(key, decoder) {
        return { key, type: decoder };
      }
      __name(getContextEntry, "getContextEntry");
      exports.getContextEntry = getContextEntry;
      function appendContext(c, key, decoder, actual) {
        var len = c.length;
        var r = Array(len + 1);
        for (var i2 = 0; i2 < len; i2++) {
          r[i2] = c[i2];
        }
        r[len] = { key, type: decoder, actual };
        return r;
      }
      __name(appendContext, "appendContext");
      exports.appendContext = appendContext;
      function pushAll(xs, ys) {
        var l = ys.length;
        for (var i2 = 0; i2 < l; i2++) {
          xs.push(ys[i2]);
        }
      }
      __name(pushAll, "pushAll");
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function getNameFromProps(props) {
        return Object.keys(props).map(function(k) {
          return "".concat(k, ": ").concat(props[k].name);
        }).join(", ");
      }
      __name(getNameFromProps, "getNameFromProps");
      function useIdentity(codecs) {
        for (var i2 = 0; i2 < codecs.length; i2++) {
          if (codecs[i2].encode !== exports.identity) {
            return false;
          }
        }
        return true;
      }
      __name(useIdentity, "useIdentity");
      function getInterfaceTypeName(props) {
        return "{ ".concat(getNameFromProps(props), " }");
      }
      __name(getInterfaceTypeName, "getInterfaceTypeName");
      function getPartialTypeName(inner) {
        return "Partial<".concat(inner, ">");
      }
      __name(getPartialTypeName, "getPartialTypeName");
      function enumerableRecord(keys, domain, codomain, name2) {
        if (name2 === void 0) {
          name2 = "{ [K in ".concat(domain.name, "]: ").concat(codomain.name, " }");
        }
        var len = keys.length;
        var props = {};
        for (var i2 = 0; i2 < len; i2++) {
          props[keys[i2]] = codomain;
        }
        var exactCodec = (0, exports.strict)(props, name2);
        return new DictionaryType(name2, function(u) {
          return exactCodec.is(u);
        }, exactCodec.validate, exactCodec.encode, domain, codomain);
      }
      __name(enumerableRecord, "enumerableRecord");
      function getDomainKeys(domain) {
        var _a;
        if (isLiteralC(domain)) {
          var literal_1 = domain.value;
          if (exports.string.is(literal_1)) {
            return _a = {}, _a[literal_1] = null, _a;
          }
        } else if (isKeyofC(domain)) {
          return domain.keys;
        } else if (isUnionC(domain)) {
          var keys = domain.types.map(function(type8) {
            return getDomainKeys(type8);
          });
          return keys.some(undefinedType.is) ? void 0 : Object.assign.apply(Object, __spreadArray([{}], keys, false));
        }
        return void 0;
      }
      __name(getDomainKeys, "getDomainKeys");
      exports.getDomainKeys = getDomainKeys;
      function stripNonDomainKeys(o, domain) {
        var keys = Object.keys(o);
        var len = keys.length;
        var shouldStrip = false;
        var r = {};
        for (var i2 = 0; i2 < len; i2++) {
          var k = keys[i2];
          if (domain.is(k)) {
            r[k] = o[k];
          } else {
            shouldStrip = true;
          }
        }
        return shouldStrip ? r : o;
      }
      __name(stripNonDomainKeys, "stripNonDomainKeys");
      function nonEnumerableRecord(domain, codomain, name2) {
        if (name2 === void 0) {
          name2 = "{ [K in ".concat(domain.name, "]: ").concat(codomain.name, " }");
        }
        return new DictionaryType(name2, function(u) {
          if (exports.UnknownRecord.is(u)) {
            return Object.keys(u).every(function(k) {
              return !domain.is(k) || codomain.is(u[k]);
            });
          }
          return isAnyC(codomain) && Array.isArray(u);
        }, function(u, c) {
          if (exports.UnknownRecord.is(u)) {
            var a2 = {};
            var errors = [];
            var keys = Object.keys(u);
            var len = keys.length;
            var changed = false;
            for (var i2 = 0; i2 < len; i2++) {
              var k = keys[i2];
              var ok = u[k];
              var domainResult = domain.validate(k, appendContext(c, k, domain, k));
              if ((0, Either_1.isLeft)(domainResult)) {
                changed = true;
              } else {
                var vk = domainResult.right;
                changed = changed || vk !== k;
                k = vk;
                var codomainResult = codomain.validate(ok, appendContext(c, k, codomain, ok));
                if ((0, Either_1.isLeft)(codomainResult)) {
                  pushAll(errors, codomainResult.left);
                } else {
                  var vok = codomainResult.right;
                  changed = changed || vok !== ok;
                  a2[k] = vok;
                }
              }
            }
            return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(changed ? a2 : u);
          }
          if (isAnyC(codomain) && Array.isArray(u)) {
            return (0, exports.success)(u);
          }
          return (0, exports.failure)(u, c);
        }, domain.encode === exports.identity && codomain.encode === exports.identity ? function(a2) {
          return stripNonDomainKeys(a2, domain);
        } : function(a2) {
          var s = {};
          var keys = Object.keys(stripNonDomainKeys(a2, domain));
          var len = keys.length;
          for (var i2 = 0; i2 < len; i2++) {
            var k = keys[i2];
            s[String(domain.encode(k))] = codomain.encode(a2[k]);
          }
          return s;
        }, domain, codomain);
      }
      __name(nonEnumerableRecord, "nonEnumerableRecord");
      function getUnionName(codecs) {
        return "(" + codecs.map(function(type8) {
          return type8.name;
        }).join(" | ") + ")";
      }
      __name(getUnionName, "getUnionName");
      function mergeAll(base, us) {
        var equal = true;
        var primitive = true;
        var baseIsNotADictionary = !exports.UnknownRecord.is(base);
        for (var _i = 0, us_1 = us; _i < us_1.length; _i++) {
          var u = us_1[_i];
          if (u !== base) {
            equal = false;
          }
          if (exports.UnknownRecord.is(u)) {
            primitive = false;
          }
        }
        if (equal) {
          return base;
        } else if (primitive) {
          return us[us.length - 1];
        }
        var r = {};
        for (var _a = 0, us_2 = us; _a < us_2.length; _a++) {
          var u = us_2[_a];
          for (var k in u) {
            if (!hasOwnProperty.call(r, k) || baseIsNotADictionary || u[k] !== base[k]) {
              r[k] = u[k];
            }
          }
        }
        return r;
      }
      __name(mergeAll, "mergeAll");
      exports.mergeAll = mergeAll;
      function getProps(codec) {
        switch (codec._tag) {
          case "RefinementType":
          case "ReadonlyType":
            return getProps(codec.type);
          case "InterfaceType":
          case "StrictType":
          case "PartialType":
            return codec.props;
          case "IntersectionType":
            return codec.types.reduce(function(props, type8) {
              return Object.assign(props, getProps(type8));
            }, {});
        }
      }
      __name(getProps, "getProps");
      function stripKeys(o, props) {
        var keys = Object.getOwnPropertyNames(o);
        var shouldStrip = false;
        var r = {};
        for (var i2 = 0; i2 < keys.length; i2++) {
          var key = keys[i2];
          if (!hasOwnProperty.call(props, key)) {
            shouldStrip = true;
          } else {
            r[key] = o[key];
          }
        }
        return shouldStrip ? r : o;
      }
      __name(stripKeys, "stripKeys");
      function getExactTypeName(codec) {
        if (isTypeC(codec)) {
          return "{| ".concat(getNameFromProps(codec.props), " |}");
        } else if (isPartialC(codec)) {
          return getPartialTypeName("{| ".concat(getNameFromProps(codec.props), " |}"));
        }
        return "Exact<".concat(codec.name, ">");
      }
      __name(getExactTypeName, "getExactTypeName");
      function isNonEmpty(as) {
        return as.length > 0;
      }
      __name(isNonEmpty, "isNonEmpty");
      exports.emptyTags = {};
      function intersect(a2, b2) {
        var r = [];
        for (var _i = 0, a_1 = a2; _i < a_1.length; _i++) {
          var v = a_1[_i];
          if (b2.indexOf(v) !== -1) {
            r.push(v);
          }
        }
        return r;
      }
      __name(intersect, "intersect");
      function mergeTags(a2, b2) {
        if (a2 === exports.emptyTags) {
          return b2;
        }
        if (b2 === exports.emptyTags) {
          return a2;
        }
        var r = Object.assign({}, a2);
        for (var k in b2) {
          if (hasOwnProperty.call(a2, k)) {
            var intersection_1 = intersect(a2[k], b2[k]);
            if (isNonEmpty(intersection_1)) {
              r[k] = intersection_1;
            } else {
              r = exports.emptyTags;
              break;
            }
          } else {
            r[k] = b2[k];
          }
        }
        return r;
      }
      __name(mergeTags, "mergeTags");
      function intersectTags(a2, b2) {
        if (a2 === exports.emptyTags || b2 === exports.emptyTags) {
          return exports.emptyTags;
        }
        var r = exports.emptyTags;
        for (var k in a2) {
          if (hasOwnProperty.call(b2, k)) {
            var intersection_2 = intersect(a2[k], b2[k]);
            if (intersection_2.length === 0) {
              if (r === exports.emptyTags) {
                r = {};
              }
              r[k] = a2[k].concat(b2[k]);
            }
          }
        }
        return r;
      }
      __name(intersectTags, "intersectTags");
      function isAnyC(codec) {
        return codec._tag === "AnyType";
      }
      __name(isAnyC, "isAnyC");
      function isLiteralC(codec) {
        return codec._tag === "LiteralType";
      }
      __name(isLiteralC, "isLiteralC");
      function isKeyofC(codec) {
        return codec._tag === "KeyofType";
      }
      __name(isKeyofC, "isKeyofC");
      function isTypeC(codec) {
        return codec._tag === "InterfaceType";
      }
      __name(isTypeC, "isTypeC");
      function isPartialC(codec) {
        return codec._tag === "PartialType";
      }
      __name(isPartialC, "isPartialC");
      function isStrictC(codec) {
        return codec._tag === "StrictType";
      }
      __name(isStrictC, "isStrictC");
      function isExactC(codec) {
        return codec._tag === "ExactType";
      }
      __name(isExactC, "isExactC");
      function isRefinementC(codec) {
        return codec._tag === "RefinementType";
      }
      __name(isRefinementC, "isRefinementC");
      function isIntersectionC(codec) {
        return codec._tag === "IntersectionType";
      }
      __name(isIntersectionC, "isIntersectionC");
      function isUnionC(codec) {
        return codec._tag === "UnionType";
      }
      __name(isUnionC, "isUnionC");
      function isRecursiveC(codec) {
        return codec._tag === "RecursiveType";
      }
      __name(isRecursiveC, "isRecursiveC");
      function isReadonlyC(codec) {
        return codec._tag === "ReadonlyType";
      }
      __name(isReadonlyC, "isReadonlyC");
      var lazyCodecs = [];
      function getTags(codec) {
        if (lazyCodecs.indexOf(codec) !== -1) {
          return exports.emptyTags;
        }
        if (isTypeC(codec) || isStrictC(codec)) {
          var index = exports.emptyTags;
          for (var k in codec.props) {
            var prop = codec.props[k];
            if (isLiteralC(prop)) {
              if (index === exports.emptyTags) {
                index = {};
              }
              index[k] = [prop.value];
            }
          }
          return index;
        } else if (isExactC(codec) || isRefinementC(codec) || isReadonlyC(codec)) {
          return getTags(codec.type);
        } else if (isIntersectionC(codec)) {
          return codec.types.reduce(function(tags2, codec2) {
            return mergeTags(tags2, getTags(codec2));
          }, exports.emptyTags);
        } else if (isUnionC(codec)) {
          return codec.types.slice(1).reduce(function(tags2, codec2) {
            return intersectTags(tags2, getTags(codec2));
          }, getTags(codec.types[0]));
        } else if (isRecursiveC(codec)) {
          lazyCodecs.push(codec);
          var tags = getTags(codec.type);
          lazyCodecs.pop();
          return tags;
        }
        return exports.emptyTags;
      }
      __name(getTags, "getTags");
      exports.getTags = getTags;
      function getIndex(codecs) {
        var tags = getTags(codecs[0]);
        var keys = Object.keys(tags);
        var len = codecs.length;
        var _loop_1 = /* @__PURE__ */ __name(function(k2) {
          var all = tags[k2].slice();
          var index = [tags[k2]];
          for (var i2 = 1; i2 < len; i2++) {
            var codec = codecs[i2];
            var ctags = getTags(codec);
            var values = ctags[k2];
            if (values === void 0) {
              return "continue-keys";
            } else {
              if (values.some(function(v) {
                return all.indexOf(v) !== -1;
              })) {
                return "continue-keys";
              } else {
                all.push.apply(all, values);
                index.push(values);
              }
            }
          }
          return { value: [k2, index] };
        }, "_loop_1");
        keys:
          for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var k = keys_1[_i];
            var state_1 = _loop_1(k);
            if (typeof state_1 === "object")
              return state_1.value;
            switch (state_1) {
              case "continue-keys":
                continue keys;
            }
          }
        return void 0;
      }
      __name(getIndex, "getIndex");
      exports.getIndex = getIndex;
      var NullType = (
        /** @class */
        function(_super) {
          __extends(NullType2, _super);
          function NullType2() {
            var _this = _super.call(this, "null", function(u) {
              return u === null;
            }, function(u, c) {
              return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
            }, exports.identity) || this;
            _this._tag = "NullType";
            return _this;
          }
          __name(NullType2, "NullType");
          return NullType2;
        }(Type2)
      );
      exports.NullType = NullType;
      exports.nullType = new NullType();
      exports.null = exports.nullType;
      var UndefinedType = (
        /** @class */
        function(_super) {
          __extends(UndefinedType2, _super);
          function UndefinedType2() {
            var _this = _super.call(this, "undefined", function(u) {
              return u === void 0;
            }, function(u, c) {
              return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
            }, exports.identity) || this;
            _this._tag = "UndefinedType";
            return _this;
          }
          __name(UndefinedType2, "UndefinedType");
          return UndefinedType2;
        }(Type2)
      );
      exports.UndefinedType = UndefinedType;
      var undefinedType = new UndefinedType();
      exports.undefined = undefinedType;
      var VoidType = (
        /** @class */
        function(_super) {
          __extends(VoidType2, _super);
          function VoidType2() {
            var _this = _super.call(this, "void", undefinedType.is, undefinedType.validate, exports.identity) || this;
            _this._tag = "VoidType";
            return _this;
          }
          __name(VoidType2, "VoidType");
          return VoidType2;
        }(Type2)
      );
      exports.VoidType = VoidType;
      exports.voidType = new VoidType();
      exports.void = exports.voidType;
      var UnknownType = (
        /** @class */
        function(_super) {
          __extends(UnknownType2, _super);
          function UnknownType2() {
            var _this = _super.call(this, "unknown", function(_) {
              return true;
            }, exports.success, exports.identity) || this;
            _this._tag = "UnknownType";
            return _this;
          }
          __name(UnknownType2, "UnknownType");
          return UnknownType2;
        }(Type2)
      );
      exports.UnknownType = UnknownType;
      exports.unknown = new UnknownType();
      var StringType = (
        /** @class */
        function(_super) {
          __extends(StringType2, _super);
          function StringType2() {
            var _this = _super.call(this, "string", function(u) {
              return typeof u === "string";
            }, function(u, c) {
              return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
            }, exports.identity) || this;
            _this._tag = "StringType";
            return _this;
          }
          __name(StringType2, "StringType");
          return StringType2;
        }(Type2)
      );
      exports.StringType = StringType;
      exports.string = new StringType();
      var NumberType = (
        /** @class */
        function(_super) {
          __extends(NumberType2, _super);
          function NumberType2() {
            var _this = _super.call(this, "number", function(u) {
              return typeof u === "number";
            }, function(u, c) {
              return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
            }, exports.identity) || this;
            _this._tag = "NumberType";
            return _this;
          }
          __name(NumberType2, "NumberType");
          return NumberType2;
        }(Type2)
      );
      exports.NumberType = NumberType;
      exports.number = new NumberType();
      var BigIntType = (
        /** @class */
        function(_super) {
          __extends(BigIntType2, _super);
          function BigIntType2() {
            var _this = _super.call(
              this,
              "bigint",
              // tslint:disable-next-line: valid-typeof
              function(u) {
                return typeof u === "bigint";
              },
              function(u, c) {
                return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
              },
              exports.identity
            ) || this;
            _this._tag = "BigIntType";
            return _this;
          }
          __name(BigIntType2, "BigIntType");
          return BigIntType2;
        }(Type2)
      );
      exports.BigIntType = BigIntType;
      exports.bigint = new BigIntType();
      var BooleanType = (
        /** @class */
        function(_super) {
          __extends(BooleanType2, _super);
          function BooleanType2() {
            var _this = _super.call(this, "boolean", function(u) {
              return typeof u === "boolean";
            }, function(u, c) {
              return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
            }, exports.identity) || this;
            _this._tag = "BooleanType";
            return _this;
          }
          __name(BooleanType2, "BooleanType");
          return BooleanType2;
        }(Type2)
      );
      exports.BooleanType = BooleanType;
      exports.boolean = new BooleanType();
      var AnyArrayType = (
        /** @class */
        function(_super) {
          __extends(AnyArrayType2, _super);
          function AnyArrayType2() {
            var _this = _super.call(this, "UnknownArray", Array.isArray, function(u, c) {
              return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
            }, exports.identity) || this;
            _this._tag = "AnyArrayType";
            return _this;
          }
          __name(AnyArrayType2, "AnyArrayType");
          return AnyArrayType2;
        }(Type2)
      );
      exports.AnyArrayType = AnyArrayType;
      exports.UnknownArray = new AnyArrayType();
      exports.Array = exports.UnknownArray;
      var AnyDictionaryType = (
        /** @class */
        function(_super) {
          __extends(AnyDictionaryType2, _super);
          function AnyDictionaryType2() {
            var _this = _super.call(this, "UnknownRecord", function(u) {
              return u !== null && typeof u === "object" && !Array.isArray(u);
            }, function(u, c) {
              return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
            }, exports.identity) || this;
            _this._tag = "AnyDictionaryType";
            return _this;
          }
          __name(AnyDictionaryType2, "AnyDictionaryType");
          return AnyDictionaryType2;
        }(Type2)
      );
      exports.AnyDictionaryType = AnyDictionaryType;
      exports.UnknownRecord = new AnyDictionaryType();
      var LiteralType = (
        /** @class */
        function(_super) {
          __extends(LiteralType2, _super);
          function LiteralType2(name2, is, validate, encode, value) {
            var _this = _super.call(this, name2, is, validate, encode) || this;
            _this.value = value;
            _this._tag = "LiteralType";
            return _this;
          }
          __name(LiteralType2, "LiteralType");
          return LiteralType2;
        }(Type2)
      );
      exports.LiteralType = LiteralType;
      function literal(value, name2) {
        if (name2 === void 0) {
          name2 = JSON.stringify(value);
        }
        var is = /* @__PURE__ */ __name(function(u) {
          return u === value;
        }, "is");
        return new LiteralType(name2, is, function(u, c) {
          return is(u) ? (0, exports.success)(value) : (0, exports.failure)(u, c);
        }, exports.identity, value);
      }
      __name(literal, "literal");
      exports.literal = literal;
      var KeyofType = (
        /** @class */
        function(_super) {
          __extends(KeyofType2, _super);
          function KeyofType2(name2, is, validate, encode, keys) {
            var _this = _super.call(this, name2, is, validate, encode) || this;
            _this.keys = keys;
            _this._tag = "KeyofType";
            return _this;
          }
          __name(KeyofType2, "KeyofType");
          return KeyofType2;
        }(Type2)
      );
      exports.KeyofType = KeyofType;
      function keyof16(keys, name2) {
        if (name2 === void 0) {
          name2 = Object.keys(keys).map(function(k) {
            return JSON.stringify(k);
          }).join(" | ");
        }
        var is = /* @__PURE__ */ __name(function(u) {
          return exports.string.is(u) && hasOwnProperty.call(keys, u);
        }, "is");
        return new KeyofType(name2, is, function(u, c) {
          return is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
        }, exports.identity, keys);
      }
      __name(keyof16, "keyof");
      exports.keyof = keyof16;
      var RefinementType2 = (
        /** @class */
        function(_super) {
          __extends(RefinementType3, _super);
          function RefinementType3(name2, is, validate, encode, type8, predicate) {
            var _this = _super.call(this, name2, is, validate, encode) || this;
            _this.type = type8;
            _this.predicate = predicate;
            _this._tag = "RefinementType";
            return _this;
          }
          __name(RefinementType3, "RefinementType");
          return RefinementType3;
        }(Type2)
      );
      exports.RefinementType = RefinementType2;
      function brand2(codec, predicate, name2) {
        return refinement(codec, predicate, name2);
      }
      __name(brand2, "brand");
      exports.brand = brand2;
      exports.Int = brand2(exports.number, function(n) {
        return Number.isInteger(n);
      }, "Int");
      var RecursiveType = (
        /** @class */
        function(_super) {
          __extends(RecursiveType2, _super);
          function RecursiveType2(name2, is, validate, encode, runDefinition) {
            var _this = _super.call(this, name2, is, validate, encode) || this;
            _this.runDefinition = runDefinition;
            _this._tag = "RecursiveType";
            return _this;
          }
          __name(RecursiveType2, "RecursiveType");
          return RecursiveType2;
        }(Type2)
      );
      exports.RecursiveType = RecursiveType;
      Object.defineProperty(RecursiveType.prototype, "type", {
        get: function() {
          return this.runDefinition();
        },
        enumerable: true,
        configurable: true
      });
      function recursion(name2, definition) {
        var cache;
        var runDefinition = /* @__PURE__ */ __name(function() {
          if (!cache) {
            cache = definition(Self);
            cache.name = name2;
          }
          return cache;
        }, "runDefinition");
        var Self = new RecursiveType(name2, function(u) {
          return runDefinition().is(u);
        }, function(u, c) {
          return runDefinition().validate(u, c);
        }, function(a2) {
          return runDefinition().encode(a2);
        }, runDefinition);
        return Self;
      }
      __name(recursion, "recursion");
      exports.recursion = recursion;
      var ArrayType = (
        /** @class */
        function(_super) {
          __extends(ArrayType2, _super);
          function ArrayType2(name2, is, validate, encode, type8) {
            var _this = _super.call(this, name2, is, validate, encode) || this;
            _this.type = type8;
            _this._tag = "ArrayType";
            return _this;
          }
          __name(ArrayType2, "ArrayType");
          return ArrayType2;
        }(Type2)
      );
      exports.ArrayType = ArrayType;
      function array8(item, name2) {
        if (name2 === void 0) {
          name2 = "Array<".concat(item.name, ">");
        }
        return new ArrayType(name2, function(u) {
          return exports.UnknownArray.is(u) && u.every(item.is);
        }, function(u, c) {
          var e = exports.UnknownArray.validate(u, c);
          if ((0, Either_1.isLeft)(e)) {
            return e;
          }
          var us = e.right;
          var len = us.length;
          var as = us;
          var errors = [];
          for (var i2 = 0; i2 < len; i2++) {
            var ui = us[i2];
            var result = item.validate(ui, appendContext(c, String(i2), item, ui));
            if ((0, Either_1.isLeft)(result)) {
              pushAll(errors, result.left);
            } else {
              var ai = result.right;
              if (ai !== ui) {
                if (as === us) {
                  as = us.slice();
                }
                as[i2] = ai;
              }
            }
          }
          return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(as);
        }, item.encode === exports.identity ? exports.identity : function(a2) {
          return a2.map(item.encode);
        }, item);
      }
      __name(array8, "array");
      exports.array = array8;
      var InterfaceType = (
        /** @class */
        function(_super) {
          __extends(InterfaceType2, _super);
          function InterfaceType2(name2, is, validate, encode, props) {
            var _this = _super.call(this, name2, is, validate, encode) || this;
            _this.props = props;
            _this._tag = "InterfaceType";
            return _this;
          }
          __name(InterfaceType2, "InterfaceType");
          return InterfaceType2;
        }(Type2)
      );
      exports.InterfaceType = InterfaceType;
      function type7(props, name2) {
        if (name2 === void 0) {
          name2 = getInterfaceTypeName(props);
        }
        var keys = Object.keys(props);
        var types = keys.map(function(key) {
          return props[key];
        });
        var len = keys.length;
        return new InterfaceType(name2, function(u) {
          if (exports.UnknownRecord.is(u)) {
            for (var i2 = 0; i2 < len; i2++) {
              var k = keys[i2];
              var uk = u[k];
              if (uk === void 0 && !hasOwnProperty.call(u, k) || !types[i2].is(uk)) {
                return false;
              }
            }
            return true;
          }
          return false;
        }, function(u, c) {
          var e = exports.UnknownRecord.validate(u, c);
          if ((0, Either_1.isLeft)(e)) {
            return e;
          }
          var o = e.right;
          var a2 = o;
          var errors = [];
          for (var i2 = 0; i2 < len; i2++) {
            var k = keys[i2];
            var ak = a2[k];
            var type_1 = types[i2];
            var result = type_1.validate(ak, appendContext(c, k, type_1, ak));
            if ((0, Either_1.isLeft)(result)) {
              pushAll(errors, result.left);
            } else {
              var vak = result.right;
              if (vak !== ak || vak === void 0 && !hasOwnProperty.call(a2, k)) {
                if (a2 === o) {
                  a2 = __assign({}, o);
                }
                a2[k] = vak;
              }
            }
          }
          return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(a2);
        }, useIdentity(types) ? exports.identity : function(a2) {
          var s = __assign({}, a2);
          for (var i2 = 0; i2 < len; i2++) {
            var k = keys[i2];
            var encode = types[i2].encode;
            if (encode !== exports.identity) {
              s[k] = encode(a2[k]);
            }
          }
          return s;
        }, props);
      }
      __name(type7, "type");
      exports.type = type7;
      exports.interface = type7;
      var PartialType = (
        /** @class */
        function(_super) {
          __extends(PartialType2, _super);
          function PartialType2(name2, is, validate, encode, props) {
            var _this = _super.call(this, name2, is, validate, encode) || this;
            _this.props = props;
            _this._tag = "PartialType";
            return _this;
          }
          __name(PartialType2, "PartialType");
          return PartialType2;
        }(Type2)
      );
      exports.PartialType = PartialType;
      function partial4(props, name2) {
        if (name2 === void 0) {
          name2 = getPartialTypeName(getInterfaceTypeName(props));
        }
        var keys = Object.keys(props);
        var types = keys.map(function(key) {
          return props[key];
        });
        var len = keys.length;
        return new PartialType(name2, function(u) {
          if (exports.UnknownRecord.is(u)) {
            for (var i2 = 0; i2 < len; i2++) {
              var k = keys[i2];
              var uk = u[k];
              if (uk !== void 0 && !props[k].is(uk)) {
                return false;
              }
            }
            return true;
          }
          return false;
        }, function(u, c) {
          var e = exports.UnknownRecord.validate(u, c);
          if ((0, Either_1.isLeft)(e)) {
            return e;
          }
          var o = e.right;
          var a2 = o;
          var errors = [];
          for (var i2 = 0; i2 < len; i2++) {
            var k = keys[i2];
            var ak = a2[k];
            var type_2 = props[k];
            var result = type_2.validate(ak, appendContext(c, k, type_2, ak));
            if ((0, Either_1.isLeft)(result)) {
              if (ak !== void 0) {
                pushAll(errors, result.left);
              }
            } else {
              var vak = result.right;
              if (vak !== ak) {
                if (a2 === o) {
                  a2 = __assign({}, o);
                }
                a2[k] = vak;
              }
            }
          }
          return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(a2);
        }, useIdentity(types) ? exports.identity : function(a2) {
          var s = __assign({}, a2);
          for (var i2 = 0; i2 < len; i2++) {
            var k = keys[i2];
            var ak = a2[k];
            if (ak !== void 0) {
              s[k] = types[i2].encode(ak);
            }
          }
          return s;
        }, props);
      }
      __name(partial4, "partial");
      exports.partial = partial4;
      var DictionaryType = (
        /** @class */
        function(_super) {
          __extends(DictionaryType2, _super);
          function DictionaryType2(name2, is, validate, encode, domain, codomain) {
            var _this = _super.call(this, name2, is, validate, encode) || this;
            _this.domain = domain;
            _this.codomain = codomain;
            _this._tag = "DictionaryType";
            return _this;
          }
          __name(DictionaryType2, "DictionaryType");
          return DictionaryType2;
        }(Type2)
      );
      exports.DictionaryType = DictionaryType;
      function record4(domain, codomain, name2) {
        var keys = getDomainKeys(domain);
        return keys ? enumerableRecord(Object.keys(keys), domain, codomain, name2) : nonEnumerableRecord(domain, codomain, name2);
      }
      __name(record4, "record");
      exports.record = record4;
      var UnionType = (
        /** @class */
        function(_super) {
          __extends(UnionType2, _super);
          function UnionType2(name2, is, validate, encode, types) {
            var _this = _super.call(this, name2, is, validate, encode) || this;
            _this.types = types;
            _this._tag = "UnionType";
            return _this;
          }
          __name(UnionType2, "UnionType");
          return UnionType2;
        }(Type2)
      );
      exports.UnionType = UnionType;
      function union6(codecs, name2) {
        if (name2 === void 0) {
          name2 = getUnionName(codecs);
        }
        var index = getIndex(codecs);
        if (index !== void 0 && codecs.length > 0) {
          var tag_1 = index[0], groups_1 = index[1];
          var len_1 = groups_1.length;
          var find_1 = /* @__PURE__ */ __name(function(value) {
            for (var i2 = 0; i2 < len_1; i2++) {
              if (groups_1[i2].indexOf(value) !== -1) {
                return i2;
              }
            }
            return void 0;
          }, "find_1");
          return new TaggedUnionType(name2, function(u) {
            if (exports.UnknownRecord.is(u)) {
              var i2 = find_1(u[tag_1]);
              return i2 !== void 0 ? codecs[i2].is(u) : false;
            }
            return false;
          }, function(u, c) {
            var e = exports.UnknownRecord.validate(u, c);
            if ((0, Either_1.isLeft)(e)) {
              return e;
            }
            var r = e.right;
            var i2 = find_1(r[tag_1]);
            if (i2 === void 0) {
              return (0, exports.failure)(u, c);
            }
            var codec = codecs[i2];
            return codec.validate(r, appendContext(c, String(i2), codec, r));
          }, useIdentity(codecs) ? exports.identity : function(a2) {
            var i2 = find_1(a2[tag_1]);
            if (i2 === void 0) {
              throw new Error("no codec found to encode value in union codec ".concat(name2));
            } else {
              return codecs[i2].encode(a2);
            }
          }, codecs, tag_1);
        } else {
          return new UnionType(name2, function(u) {
            return codecs.some(function(type8) {
              return type8.is(u);
            });
          }, function(u, c) {
            var errors = [];
            for (var i2 = 0; i2 < codecs.length; i2++) {
              var codec = codecs[i2];
              var result = codec.validate(u, appendContext(c, String(i2), codec, u));
              if ((0, Either_1.isLeft)(result)) {
                pushAll(errors, result.left);
              } else {
                return (0, exports.success)(result.right);
              }
            }
            return (0, exports.failures)(errors);
          }, useIdentity(codecs) ? exports.identity : function(a2) {
            for (var _i = 0, codecs_1 = codecs; _i < codecs_1.length; _i++) {
              var codec = codecs_1[_i];
              if (codec.is(a2)) {
                return codec.encode(a2);
              }
            }
            throw new Error("no codec found to encode value in union type ".concat(name2));
          }, codecs);
        }
      }
      __name(union6, "union");
      exports.union = union6;
      var IntersectionType = (
        /** @class */
        function(_super) {
          __extends(IntersectionType2, _super);
          function IntersectionType2(name2, is, validate, encode, types) {
            var _this = _super.call(this, name2, is, validate, encode) || this;
            _this.types = types;
            _this._tag = "IntersectionType";
            return _this;
          }
          __name(IntersectionType2, "IntersectionType");
          return IntersectionType2;
        }(Type2)
      );
      exports.IntersectionType = IntersectionType;
      function intersection3(codecs, name2) {
        if (name2 === void 0) {
          name2 = "(".concat(codecs.map(function(type8) {
            return type8.name;
          }).join(" & "), ")");
        }
        var len = codecs.length;
        return new IntersectionType(name2, function(u) {
          return codecs.every(function(type8) {
            return type8.is(u);
          });
        }, codecs.length === 0 ? exports.success : function(u, c) {
          var us = [];
          var errors = [];
          for (var i2 = 0; i2 < len; i2++) {
            var codec = codecs[i2];
            var result = codec.validate(u, appendContext(c, String(i2), codec, u));
            if ((0, Either_1.isLeft)(result)) {
              pushAll(errors, result.left);
            } else {
              us.push(result.right);
            }
          }
          return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(mergeAll(u, us));
        }, codecs.length === 0 ? exports.identity : function(a2) {
          return mergeAll(a2, codecs.map(function(codec) {
            return codec.encode(a2);
          }));
        }, codecs);
      }
      __name(intersection3, "intersection");
      exports.intersection = intersection3;
      var TupleType = (
        /** @class */
        function(_super) {
          __extends(TupleType2, _super);
          function TupleType2(name2, is, validate, encode, types) {
            var _this = _super.call(this, name2, is, validate, encode) || this;
            _this.types = types;
            _this._tag = "TupleType";
            return _this;
          }
          __name(TupleType2, "TupleType");
          return TupleType2;
        }(Type2)
      );
      exports.TupleType = TupleType;
      function tuple4(codecs, name2) {
        if (name2 === void 0) {
          name2 = "[".concat(codecs.map(function(type8) {
            return type8.name;
          }).join(", "), "]");
        }
        var len = codecs.length;
        return new TupleType(name2, function(u) {
          return exports.UnknownArray.is(u) && u.length === len && codecs.every(function(type8, i2) {
            return type8.is(u[i2]);
          });
        }, function(u, c) {
          var e = exports.UnknownArray.validate(u, c);
          if ((0, Either_1.isLeft)(e)) {
            return e;
          }
          var us = e.right;
          var as = us.length > len ? us.slice(0, len) : us;
          var errors = [];
          for (var i2 = 0; i2 < len; i2++) {
            var a2 = us[i2];
            var type_3 = codecs[i2];
            var result = type_3.validate(a2, appendContext(c, String(i2), type_3, a2));
            if ((0, Either_1.isLeft)(result)) {
              pushAll(errors, result.left);
            } else {
              var va = result.right;
              if (va !== a2) {
                if (as === us) {
                  as = us.slice();
                }
                as[i2] = va;
              }
            }
          }
          return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(as);
        }, useIdentity(codecs) ? exports.identity : function(a2) {
          return codecs.map(function(type8, i2) {
            return type8.encode(a2[i2]);
          });
        }, codecs);
      }
      __name(tuple4, "tuple");
      exports.tuple = tuple4;
      var ReadonlyType = (
        /** @class */
        function(_super) {
          __extends(ReadonlyType2, _super);
          function ReadonlyType2(name2, is, validate, encode, type8) {
            var _this = _super.call(this, name2, is, validate, encode) || this;
            _this.type = type8;
            _this._tag = "ReadonlyType";
            return _this;
          }
          __name(ReadonlyType2, "ReadonlyType");
          return ReadonlyType2;
        }(Type2)
      );
      exports.ReadonlyType = ReadonlyType;
      function readonly2(codec, name2) {
        if (name2 === void 0) {
          name2 = "Readonly<".concat(codec.name, ">");
        }
        return new ReadonlyType(name2, codec.is, codec.validate, codec.encode, codec);
      }
      __name(readonly2, "readonly");
      exports.readonly = readonly2;
      var ReadonlyArrayType = (
        /** @class */
        function(_super) {
          __extends(ReadonlyArrayType2, _super);
          function ReadonlyArrayType2(name2, is, validate, encode, type8) {
            var _this = _super.call(this, name2, is, validate, encode) || this;
            _this.type = type8;
            _this._tag = "ReadonlyArrayType";
            return _this;
          }
          __name(ReadonlyArrayType2, "ReadonlyArrayType");
          return ReadonlyArrayType2;
        }(Type2)
      );
      exports.ReadonlyArrayType = ReadonlyArrayType;
      function readonlyArray(item, name2) {
        if (name2 === void 0) {
          name2 = "ReadonlyArray<".concat(item.name, ">");
        }
        var codec = array8(item);
        return new ReadonlyArrayType(name2, codec.is, codec.validate, codec.encode, item);
      }
      __name(readonlyArray, "readonlyArray");
      exports.readonlyArray = readonlyArray;
      var strict = /* @__PURE__ */ __name(function(props, name2) {
        return exact(type7(props), name2);
      }, "strict");
      exports.strict = strict;
      var ExactType = (
        /** @class */
        function(_super) {
          __extends(ExactType2, _super);
          function ExactType2(name2, is, validate, encode, type8) {
            var _this = _super.call(this, name2, is, validate, encode) || this;
            _this.type = type8;
            _this._tag = "ExactType";
            return _this;
          }
          __name(ExactType2, "ExactType");
          return ExactType2;
        }(Type2)
      );
      exports.ExactType = ExactType;
      function exact(codec, name2) {
        if (name2 === void 0) {
          name2 = getExactTypeName(codec);
        }
        var props = getProps(codec);
        return new ExactType(name2, codec.is, function(u, c) {
          var e = exports.UnknownRecord.validate(u, c);
          if ((0, Either_1.isLeft)(e)) {
            return e;
          }
          var ce = codec.validate(u, c);
          if ((0, Either_1.isLeft)(ce)) {
            return ce;
          }
          return (0, Either_1.right)(stripKeys(ce.right, props));
        }, function(a2) {
          return codec.encode(stripKeys(a2, props));
        }, codec);
      }
      __name(exact, "exact");
      exports.exact = exact;
      var FunctionType = (
        /** @class */
        function(_super) {
          __extends(FunctionType2, _super);
          function FunctionType2() {
            var _this = _super.call(
              this,
              "Function",
              // tslint:disable-next-line:strict-type-predicates
              function(u) {
                return typeof u === "function";
              },
              function(u, c) {
                return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
              },
              exports.identity
            ) || this;
            _this._tag = "FunctionType";
            return _this;
          }
          __name(FunctionType2, "FunctionType");
          return FunctionType2;
        }(Type2)
      );
      exports.FunctionType = FunctionType;
      exports.Function = new FunctionType();
      var NeverType = (
        /** @class */
        function(_super) {
          __extends(NeverType2, _super);
          function NeverType2() {
            var _this = _super.call(
              this,
              "never",
              function(_) {
                return false;
              },
              function(u, c) {
                return (0, exports.failure)(u, c);
              },
              /* istanbul ignore next */
              function() {
                throw new Error("cannot encode never");
              }
            ) || this;
            _this._tag = "NeverType";
            return _this;
          }
          __name(NeverType2, "NeverType");
          return NeverType2;
        }(Type2)
      );
      exports.NeverType = NeverType;
      exports.never = new NeverType();
      var AnyType = (
        /** @class */
        function(_super) {
          __extends(AnyType2, _super);
          function AnyType2() {
            var _this = _super.call(this, "any", function(_) {
              return true;
            }, exports.success, exports.identity) || this;
            _this._tag = "AnyType";
            return _this;
          }
          __name(AnyType2, "AnyType");
          return AnyType2;
        }(Type2)
      );
      exports.AnyType = AnyType;
      exports.any = new AnyType();
      function refinement(codec, predicate, name2) {
        if (name2 === void 0) {
          name2 = "(".concat(codec.name, " | ").concat(getFunctionName(predicate), ")");
        }
        return new RefinementType2(name2, function(u) {
          return codec.is(u) && predicate(u);
        }, function(i2, c) {
          var e = codec.validate(i2, c);
          if ((0, Either_1.isLeft)(e)) {
            return e;
          }
          var a2 = e.right;
          return predicate(a2) ? (0, exports.success)(a2) : (0, exports.failure)(a2, c);
        }, codec.encode, codec, predicate);
      }
      __name(refinement, "refinement");
      exports.refinement = refinement;
      exports.Integer = refinement(exports.number, Number.isInteger, "Integer");
      var TaggedUnionType = (
        /** @class */
        function(_super) {
          __extends(TaggedUnionType2, _super);
          function TaggedUnionType2(name2, is, validate, encode, codecs, tag) {
            var _this = _super.call(this, name2, is, validate, encode, codecs) || this;
            _this.tag = tag;
            return _this;
          }
          __name(TaggedUnionType2, "TaggedUnionType");
          return TaggedUnionType2;
        }(UnionType)
      );
      exports.TaggedUnionType = TaggedUnionType;
      var taggedUnion = /* @__PURE__ */ __name(function(tag, codecs, name2) {
        if (name2 === void 0) {
          name2 = getUnionName(codecs);
        }
        var U = union6(codecs, name2);
        if (U instanceof TaggedUnionType) {
          return U;
        } else {
          console.warn("[io-ts] Cannot build a tagged union for ".concat(name2, ", returning a de-optimized union"));
          return new TaggedUnionType(name2, U.is, U.validate, U.encode, codecs, tag);
        }
      }, "taggedUnion");
      exports.taggedUnion = taggedUnion;
      var getValidationError = /* @__PURE__ */ __name(function(value, context) {
        return {
          value,
          context
        };
      }, "getValidationError");
      exports.getValidationError = getValidationError;
      var getDefaultContext = /* @__PURE__ */ __name(function(decoder) {
        return [
          { key: "", type: decoder }
        ];
      }, "getDefaultContext");
      exports.getDefaultContext = getDefaultContext;
      exports.Dictionary = exports.UnknownRecord;
      var ObjectType = (
        /** @class */
        function(_super) {
          __extends(ObjectType2, _super);
          function ObjectType2() {
            var _this = _super.call(this, "object", function(u) {
              return u !== null && typeof u === "object";
            }, function(u, c) {
              return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
            }, exports.identity) || this;
            _this._tag = "ObjectType";
            return _this;
          }
          __name(ObjectType2, "ObjectType");
          return ObjectType2;
        }(Type2)
      );
      exports.ObjectType = ObjectType;
      exports.object = new ObjectType();
      exports.dictionary = record4;
      var StrictType = (
        /** @class */
        function(_super) {
          __extends(StrictType2, _super);
          function StrictType2(name2, is, validate, encode, props) {
            var _this = _super.call(this, name2, is, validate, encode) || this;
            _this.props = props;
            _this._tag = "StrictType";
            return _this;
          }
          __name(StrictType2, "StrictType");
          return StrictType2;
        }(Type2)
      );
      exports.StrictType = StrictType;
      function clean(codec) {
        return codec;
      }
      __name(clean, "clean");
      exports.clean = clean;
      function alias(codec) {
        return function() {
          return codec;
        };
      }
      __name(alias, "alias");
      exports.alias = alias;
    }
  });

  // node_modules/json5/lib/unicode.js
  var require_unicode = __commonJS({
    "node_modules/json5/lib/unicode.js"(exports, module) {
      module.exports.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
      module.exports.ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
      module.exports.ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
    }
  });

  // node_modules/json5/lib/util.js
  var require_util = __commonJS({
    "node_modules/json5/lib/util.js"(exports, module) {
      var unicode = require_unicode();
      module.exports = {
        isSpaceSeparator(c) {
          return typeof c === "string" && unicode.Space_Separator.test(c);
        },
        isIdStartChar(c) {
          return typeof c === "string" && (c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "$" || c === "_" || unicode.ID_Start.test(c));
        },
        isIdContinueChar(c) {
          return typeof c === "string" && (c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c >= "0" && c <= "9" || c === "$" || c === "_" || c === "\u200C" || c === "\u200D" || unicode.ID_Continue.test(c));
        },
        isDigit(c) {
          return typeof c === "string" && /[0-9]/.test(c);
        },
        isHexDigit(c) {
          return typeof c === "string" && /[0-9A-Fa-f]/.test(c);
        }
      };
    }
  });

  // node_modules/io-ts/lib/PathReporter.js
  var require_PathReporter = __commonJS({
    "node_modules/io-ts/lib/PathReporter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PathReporter = exports.success = exports.failure = void 0;
      var Either_1 = require_Either();
      var _1 = require_lib();
      function stringify(v) {
        if (typeof v === "function") {
          return (0, _1.getFunctionName)(v);
        }
        if (typeof v === "number" && !isFinite(v)) {
          if (isNaN(v)) {
            return "NaN";
          }
          return v > 0 ? "Infinity" : "-Infinity";
        }
        return JSON.stringify(v);
      }
      __name(stringify, "stringify");
      function getContextPath(context) {
        return context.map(function(_a) {
          var key = _a.key, type7 = _a.type;
          return "".concat(key, ": ").concat(type7.name);
        }).join("/");
      }
      __name(getContextPath, "getContextPath");
      function getMessage(e) {
        return e.message !== void 0 ? e.message : "Invalid value ".concat(stringify(e.value), " supplied to ").concat(getContextPath(e.context));
      }
      __name(getMessage, "getMessage");
      function failure2(es) {
        return es.map(getMessage);
      }
      __name(failure2, "failure");
      exports.failure = failure2;
      function success2() {
        return ["No errors!"];
      }
      __name(success2, "success");
      exports.success = success2;
      exports.PathReporter = {
        report: (0, Either_1.fold)(failure2, success2)
      };
    }
  });

  // simulator/html/LogicEditorTemplate.html
  var LogicEditorTemplate_default = '<div id="logicEditorRoot" style="width: 100%; height: 100%; display: flex; align-items: stretch;">\n\n    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" integrity="sha384-zCbKRCUGaJDkqS1kPbPd7TveP5iyJE0EjAuZQTgFLD2ylzuqKfdKlfG/eSrtxUkn" crossorigin="anonymous">\n    <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"><\/script>\n    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-fQybjgWLrvvRgtW6bFlB7jaZrFsaBXjsOMm/tB9LTS58ONXgqbR9W8oWht/amnpF" crossorigin="anonymous"><\/script>\n\n    <!-- Has to appear *after* the other bootstrap styles -->\n    <style id="inlineStyle"></style>\n\n    <div id="leftToolbar" style="flex:none; min-width: 50px; max-width: 60px;overflow-y: scroll;display: none;">\n    </div>\n\n    <div id="centerCol" style="flex: auto; display: flex; flex-direction: column; justify-content: stretch;">\n\n        <div id="canvas-sim" style="flex: auto; position: relative; display: flex; align-items: stretch; min-width: 0; max-width: 100%; overflow: hidden;">\n\n            <canvas id="mainCanvas" tabindex="0" style="flex:auto"></canvas>\n\n            <div style="padding: 5px;\n            position: absolute; top: 10px; right: 10px;display:flex; flex-direction: column; align-items: flex-end;">\n                <div class="sim-toolbar-right" style="margin-bottom: 15px; display: none;" id="modeChangeMenu">\n                </div>\n\n                <div id="rightToolbarContainer" class="sim-toolbar-right" style="display: none;">\n                    <div class="btn-group-vertical">\n                        <button type="button" class="btn btn-sm btn-outline-light sim-toolbar-button-right" tool="reset" id="rightResetButton">\n                            <i class="svgicon" data-icon="reset"></i>\n                            <span style="margin-left: -20px">&nbsp;</span>\n                        </button>\n                    </div>\n                </div>\n\n                <div id="testResultsPalette">\n                </div>\n\n                <div id="settingsPalette" class="sim-toolbar-right" style="display: none; flex-direction:column; align-items: stretch; font-size: 75%; padding: 0 5px 5px" data-prev-display="flex">\n                </div>\n\n\n            </div>\n        </div>\n\n    </div>\n\n\n    <dialog id="embedDialog" style="display: none; border: 1px solid gray; border-radius: 10px; box-shadow: 0px 0px 16px 5px rgba(0,0,0,0.2); padding: 5px 10px; width: 100%; max-width: 600px;">\n        <div style="display: flex; flex-direction: column; font-size: 80%">\n            <div style="flex:none; font-weight: bold; text-align: center; width: 100%;padding: 10px 0; border-bottom: 1px solid lightgrey; margin-bottom: 10px; font-size: 120%" id="shareDialogTitle"></div>\n            <div style="flex: auto; display: flex; flex-direction: row;">\n                <div style="flex:auto; flex-direction: column;">\n                    <div>\n                        <span style="font-weight: bolder" id="shareDialogUrl"></span><br>\n                        <textarea id="embedUrl" readonly rows="2" style="width:100%; resize: none"></textarea>\n                    </div>\n                    <div style="margin-top: 10px; flex:auto">\n                        <span style="font-weight: bolder" id="shareDialogIframe"></span><br>\n                        <textarea id="embedIframe" readonly rows="4" style="width:100%; font-family: monospace;"></textarea>\n                    </div>\n                    <div style="margin-top: 10px; flex:auto">\n                        <span style="font-weight: bolder" id="shareDialogWebComp"></span><br>\n                        <textarea id="embedWebcomp" readonly rows="4" style="width:100%; font-family: monospace;"></textarea>\n                    </div>\n                    <div style="margin-top: 10px; flex:auto">\n                        <span style="font-weight: bolder;" id="shareDialogMarkdown"></span><br>\n                        <textarea id="embedMarkdown" readonly rows="7" style="width:100%; font-family: monospace"></textarea>\n                    </div>\n                </div>\n                <!-- <div style="flex:none; margin-top: 10px">\n                    <img id="embedUrlQRCode" style="margin-left: 10px">\n                </div> -->\n            </div>\n            <div style="flex: none; margin-top: 15px; text-align: center;">\n                <form method="dialog">\n                    <button value="close" id="shareDialogClose"></button>\n                </form>\n            </div>\n        </div>\n    </dialog>\n\n    <input id="fileChooser" type="file" style="display:none"></input>\n\n    <div id="tooltip" role="tooltip" style="display:none">\n        <div id="tooltipContents"></div>\n        <div id="arrow" data-popper-arrow></div>\n    </div>\n\n    <ul class="menu" id="mainContextMenu"></ul>\n\n</div>';

  // simulator/css/LogicEditor.css
  var LogicEditor_default = `* {
  box-sizing: border-box;
}

canvas:focus {
  outline: none;
}

#logicEditorRoot {
  font-family: 'Roboto', sans-serif;
  background-color: #EEEEEE;
}

#logicEditorRoot.dark {
  background-color: #373737;
}

/* TODO would that go in some global CSS?
logic-editor:not(:defined) {
  opacity: 0;
  width: 100%;
  height: 20px;
}
*/

/* btn btn-sm  */


.navGroupTools {
  padding-left: 2px;
  padding-right: 2px;
  border-right-style: dotted;
  border-color: gray;
}

.nav-item {
  display: inline-flex;
}

#leftToolbar {
  display: flex;
  flex-direction: column;
  color: black;
}

.leftToolbarHeader {
  font-size: 80%;
  font-weight: bold;
  padding: 1px;
  /* word-break: break-all; */
  text-align: center;
  background-color: lightgray;
}

.leftToolbarMore {
  text-align: center;
  font-style: italic;
  font-size: 75%;
  padding: 3px 0;
  cursor: pointer;
  opacity: 0.6;
  color: rgb(33, 33, 33);
}

.dark a {
  color: #8e81ff;
}

.dark .leftToolbarHeader {
  background-color: rgb(56, 56, 56);
}

.dark #leftToolbar {
  background-color: #5e5e5e;
  color: rgb(181, 181, 181);
}

.dark .leftToolbarMore {
  color: rgb(204, 204, 204);
}

.dark #leftToolbar .list-group-item {
  background-color: #5e5e5e;
}

.sim-toolbar-right {
  background: rgba(136, 136, 136, 0.5);
  box-shadow: 0px 0px 10px 1px rgb(201, 201, 201);
  border-radius: 5px;
  position: relative;
  right: 0px;
  top: 0px;
}

.sim-toolbar-right .toolbar-title {
  text-align: center;
  width: 100%;
  font-weight: bold;
  font-size: 12px;
  color: #444;
  padding: 2px;
  cursor: grab;
}

.dark .sim-toolbar-right .toolbar-title {
  color: rgb(181, 181, 181);
}

.dark .sim-toolbar-right {
  color: rgb(204, 204, 204);
}

.sim-toolbar-right .toolbar-title.with-border {
  border-bottom: 1px solid rgba(255, 255, 255, 0.4);
  margin-bottom: 5px;
}

.sim-toolbar-right .close-palette {
  position: absolute;
  top: 2px;
  right: 2px;
  cursor: pointer;
  margin-left: 5px;
  color: rgb(112, 112, 112)
}

.dark .sim-toolbar-right .close-palette {
  color: rgb(204, 204, 204);
}

#settingsPalette label span,
.noselect {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.sim-component-button {
  padding: 8px 0;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.sim-component-button-extra {
  background-color: #ededed;
}

.sim-toolbar-button-right {
  text-align: left;
  cursor: pointer;
  height: 30px;
}

.sim-toolbar-button-right>i {
  width: 16px;
}

.sim-mode-link {
  margin: -8px 0 -8px 5px;
  border: 1px solid rgba(0, 0, 0, 0);
  border-radius: 3px;
  padding: 5px;
  cursor: pointer;
}

.sim-toolbar-button-right:not(.active) .sim-mode-link {
  opacity: 0.0;
}

.sim-mode-link:hover {
  border-color: grey;
}

#leftToolbar .barLabel {
  font-size: 52%;
  font-weight: bold;
  text-align: center;
  word-break: break-all;
}

.truth-table {
  color: white;
  font-weight: normal;
  font-size: 90%;
  text-align: center;
  border: 1px solid gray;
  margin: 5px 0;
}

.truth-table th {
  padding: 3px 8px;
  margin: 0 0 2px 0;
  border-bottom: 1px solid grey;
}

.truth-table tr.current {
  background: grey;
  color: rgb(255, 192, 8);
}

.truth-table th:last-child,
.truth-table td:last-child {
  border-left: 1px solid grey;
}

/* Tooltips by Popper */

#tooltip {
  background: #333;
  color: white;
  padding: 6px;
  font-size: 13px;
  line-height: 1.2em;
  border-radius: 4px;
  display: none;
  opacity: 0.95;
}

#tooltip div+div {
  margin-top: 5px;
}

#tooltip[data-show] {
  display: block;
}

#arrow,
#arrow::before {
  position: absolute;
  width: 8px;
  height: 8px;
  background: inherit;
}

#arrow {
  visibility: hidden;
}

#arrow::before {
  visibility: visible;
  content: '';
  transform: rotate(45deg);
}

#tooltip[data-popper-placement^='top']>#arrow {
  bottom: -4px;
}

#tooltip[data-popper-placement^='bottom']>#arrow {
  top: -4px;
}

#tooltip[data-popper-placement^='left']>#arrow {
  right: -4px;
}

#tooltip[data-popper-placement^='right']>#arrow {
  left: -4px;
}

/* Menus */

.menu {
  position: absolute;
  min-width: 200px;
  padding: 2px;
  margin: 0;
  border: 1px solid #bbb;
  background: #EAEAEA;
  background: -webkit-linear-gradient(to bottom, #F2F2F2 0%, #EAEAEA 100px, #EAEAEA 100%);
  background: linear-gradient(to bottom, #F2F2F2 0%, #EAEAEA 100px, #EAEAEA 100%);
  z-index: 100;
  border-radius: 3px;
  box-shadow: 1px 1px 4px rgba(0, 0, 0, .2);
  opacity: 0;
  -webkit-transform: translate(0, 15px) scale(.95);
  transform: translate(0, 15px) scale(.95);
  transition: transform 0.1s ease-out, opacity 0.1s ease-out;
  pointer-events: none;
}

.menu-item {
  display: block;
  position: relative;
  margin: 0;
  padding: 0;
  white-space: nowrap;
}

.menu-btn {
  background: none;
  line-height: normal;
  overflow: visible;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  display: block;
  width: 100%;
  color: #444;
  font-family: 'Roboto', sans-serif;
  font-size: 13px;
  text-align: left;
  cursor: pointer;
  border: 1px solid transparent;
  white-space: nowrap;
  padding: 6px 8px;
  border-radius: 3px;
}

.menu-btn::-moz-focus-inner,
.menu-btn::-moz-focus-inner {
  border: 0;
  padding: 0;
}

.menu-text {
  margin-left: 10px;
  margin-right: 22px;
}

.menu-item-static {
  display: block;
  padding: 0 5px;
  color: rgb(150, 150, 150);
  font-size: 70%;
  font-style: italic;
  width: 100%;
  white-space: normal;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  cursor: default;
}

.menu-btn .fa {
  position: absolute;
  left: 8px;
  top: 50%;
  -webkit-transform: translateY(-50%);
  transform: translateY(-50%);
}

.menu-shortcut {
  position: absolute;
  right: 8px;
  font-size: 85%;
}

.menu-item:hover>.menu-btn {
  color: #fff;
  outline: none;
  background-color: #2865E1;
  background: -webkit-linear-gradient(to bottom, #2A6BED, #2865E1);
  background: linear-gradient(to bottom, #2A6BED, #2865E1);
  border: 1px solid #2865E1;
}

.menu-item:hover>.menu-btn.danger {
  color: #fff;
  background-color: #C1210E;
  background: -webkit-linear-gradient(to bottom, #DE2610, #C1210E);
  background: linear-gradient(to bottom, #DE2610, #C1210E);
  border: 1px solid #C1210E;
}

.menu-item.disabled {
  opacity: .5;
  pointer-events: none;
}

.menu-item.disabled .menu-btn {
  cursor: default;
}

.menu-separator {
  display: block;
  margin: 3px 5px;
  height: 1px;
  border-bottom: 1px solid #D0CFD0;
  background-color: #aaa;
}

.menu-item.submenu::after {
  content: "";
  position: absolute;
  right: 6px;
  top: 50%;
  -webkit-transform: translateY(-50%);
  transform: translateY(-50%);
  border: 5px solid transparent;
  border-left-color: #808080;
}

.menu-item.submenu:hover::after {
  border-left-color: #fff;
}

.menu .menu {
  top: 4px;
  left: 99%;
}

.show-menu,
.menu-item:hover>.menu {
  opacity: 1;
  -webkit-transform: translate(0, 0) scale(1);
  transform: translate(0, 0) scale(1);
  pointer-events: auto;
}

.menu-item:hover>.menu {
  -webkit-transition-delay: 100ms;
  transition-delay: 300ms;
}

i.svgicon {
  display: inline-block;
  width: 16px;
}

i.svgicon svg {
  width: 100%;
}

i.svgicon path {
  fill: currentColor;
}



i.svgimg svg {
  width: 100%;
  font-family: Arial, Helvetica, sans-serif;
  font-style: normal;
}

i.svgimg {
  color: black;
}

.dark i.svgimg {
  color: rgb(230, 230, 230);
}

.dark .barLabel {
  color: rgb(220, 220, 220);
}

svg text {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  pointer-events: none;
}


/* Top bar */

.topBar {
  background-color: rgb(239, 239, 239);
  border-left: 1px solid lightgray;
}

.dark .topBar {
  background-color: rgb(94, 94, 94);
  border-left-color: #525252;
}

.topBar * {
  font: 10pt 'Roboto', sans-serif;
}

.dark .topBar * {
  color: rgb(220, 220, 220);
}

.topBar button {
  border: none;
  background: none;
  box-shadow: none;
  border-radius: 5px;
  display: inline-flex;
  align-items: center;
  gap: 3px;
}

.dark .topBar button:disabled * {
  color: #808080;
}

.topBar button:not(:disabled, .active):hover {
  background: #d5d5d5;
}

.topBar button:not(:disabled, .active):active {
  background: #b2b2b2;
  transform: translate(1px, 1px);
}

.topBar button.active {
  background: #ffffff;
  font-weight: bolder;
  cursor: unset;
}


.dark .topBar button:not(:disabled, .active):hover {
  background: #404040;
}

.dark .topBar button:not(:disabled, .active):active {
  background: #313131;
}

.dark .topBar button.active {
  background: #1E1E1E;
}

.topBar .sep {
  border-left: 1px solid #d5d5d5;
  margin: 0 4px;
}

.topBar .sep.fat {
  border-left-width: 5px;
}

.dark .topBar .sep {
  border-left-color: #525252;
}

.topBar .barLabel {
  display: inline-flex;
  align-items: center;
  white-space: pre;
  margin: 0 5px;
  cursor: default;
}

.topBar.compact .btnLabel {
  display: none;
}

.topBar a.barLabel {
  color: inherit;
  cursor: pointer;
}

.topBar .barTab {
  flex: none;
  display: inline-flex;
  margin: 0 0 -3px;
  padding: 3px;
}

.topBar .barTab.active {
  background-color: white;
  border-top-left-radius: 10px;
  border-top-right-radius: 10px;
  border: 1px solid rgb(200, 200, 200);
  border-bottom: none;
}

.dark .topBar .barTab.active {
  background-color: rgb(30, 30, 30);
  border-color: #555555;
}


.msgZone {
  position: absolute;
  top: -40px;
  width: 100%;
  display: flex;
  visibility: hidden;
  justify-content: center;
  align-items: center;
  transition: all 0.15s ease-in-out
}

.msgZone.visible {
  top: 10px;
  visibility: visible;
}

.msgZone .msgBar {
  padding: 5px 10px;
  border-radius: 20px;
  text-align: center;
  max-width: 80%;
  box-shadow: 0px 0px 5px 0px rgba(128, 128, 128, 0.5);
  font-size: 10pt;
  background-color: rgb(190, 190, 190, 0.2);
}

.dark .msgZone .msgBar {
  color: rgb(220, 220, 220);
}

.test-disclosable {
  cursor: pointer;
  border: none;
}

.test-disclosable::before {
  content: '\\25B6';
  /* Right-pointing triangle */
  display: inline-block;
  margin-right: 5px;
  transition: transform 0.1s;
}

.testcase-button {
  background: none;
  width: 100%;
  text-align: left;
  display: flex;
}

.testcase-button.test-disclosable::before {
  font-size: 80%;
}

.test-disclosable.expanded::before {
  transform: rotate(90deg);
  /* Down-pointing triangle */
}

.test-suite {
  background-color: #ccc;
  color: #444;
  font-weight: bold;
  padding: 5px;
  width: 100%;
}

.dark .test-suite {
  background-color: #333;
  color: #ccc;
}

.test-cases {
  padding: 0;
  display: none;
  overflow: hidden;
  background-color: #f1f1f1;
}

.dark .test-cases {
  background-color: #444;
}

.testcase {
  padding: 2px 5px;
  border-top: 1px solid #ccc;
}

.testcase.wait {
  background: #f1f1f1;
}

.dark .testcase.wait {
  background: #444;
}

.testcase.pass {
  background: #d3f3d3;
}

.dark .testcase.pass {
  background: rgb(25, 48, 25);
}

.testcase.fail {
  background: #f3d3d3;
}

.dark .testcase.fail {
  background: #412626;
}

.testcase.error {
  background: #f3f3d3;
}

.dark .testcase.error {
  background: #363616;
}

.testcase.skip {
  background: #d3d3f3;
}

.dark .testcase.skip {
  background: #666;
}

.testcase.running {
  background: repeating-linear-gradient(135deg,
      #e2e2e2,
      #e2e2e2 10px,
      #f7f6f6 10px,
      #f7f6f6 20px);
  background-size: 200% 100%;
  animation: barberpole 5s linear infinite;
}

.dark .testcase.running {
  background: repeating-linear-gradient(135deg,
      #555,
      #555 10px,
      #444 10px,
      #444 20px);
}

@keyframes barberpole {
  0% {
    background-position: 0% 0%;
  }

  100% {
    background-position: -100% 0%;
  }
}

.testcase-details {
  padding: 5px 5px 10px 20px;
}

#logicEditorRoot[nomodes~=full] .testcase-change-button {
  display: none;
}

.testcase-table {
  width: 100%;
  font-size: 90%;
  border-collapse: collapse;
  border-bottom: 1px solid rgba(255, 255, 255, 0.6);
  border-left: 2px solid rgba(255, 255, 255, 0.6);
  opacity: 0.8;
}

.testcase-table th {
  padding-left: 5px;
}

.testcase-table td {
  padding-left: 10px;
}

.testcase-table :is(td, th) {
  white-space: nowrap;
}

.testcase-table :is(td, th):first-child {
  width: 50%;
}

.testcase-table :is(td, th):nth-child(2) {
  border-left: 1px solid rgba(255, 255, 255, 0.6);
}

.testcase-wrongvalue {
  color: #8f2626;
  font-weight: bold;
}

.dark .testcase-wrongvalue {
  color: #ff9898;
}`;

  // node_modules/dialog-polyfill/dist/dialog-polyfill.css
  var dialog_polyfill_default = "dialog {\n  position: absolute;\n  left: 0; right: 0;\n  width: -moz-fit-content;\n  width: -webkit-fit-content;\n  width: fit-content;\n  height: -moz-fit-content;\n  height: -webkit-fit-content;\n  height: fit-content;\n  margin: auto;\n  border: solid;\n  padding: 1em;\n  background: white;\n  color: black;\n  display: block;\n}\n\ndialog:not([open]) {\n  display: none;\n}\n\ndialog + .backdrop {\n  position: fixed;\n  top: 0; right: 0; bottom: 0; left: 0;\n  background: rgba(0,0,0,0.1);\n}\n\n._dialog_overlay {\n  position: fixed;\n  top: 0; right: 0; bottom: 0; left: 0;\n}\n\ndialog.fixed {\n  position: fixed;\n  top: 50%;\n  transform: translate(0, -50%);\n}";

  // node_modules/dialog-polyfill/dist/dialog-polyfill.esm.js
  var supportCustomEvent = window.CustomEvent;
  if (!supportCustomEvent || typeof supportCustomEvent === "object") {
    supportCustomEvent = /* @__PURE__ */ __name(function CustomEvent(event, x) {
      x = x || {};
      var ev = document.createEvent("CustomEvent");
      ev.initCustomEvent(event, !!x.bubbles, !!x.cancelable, x.detail || null);
      return ev;
    }, "CustomEvent");
    supportCustomEvent.prototype = window.Event.prototype;
  }
  function safeDispatchEvent(target2, event) {
    var check = "on" + event.type.toLowerCase();
    if (typeof target2[check] === "function") {
      target2[check](event);
    }
    return target2.dispatchEvent(event);
  }
  __name(safeDispatchEvent, "safeDispatchEvent");
  function createsStackingContext(el) {
    while (el && el !== document.body) {
      var s = window.getComputedStyle(el);
      var invalid = /* @__PURE__ */ __name(function(k, ok) {
        return !(s[k] === void 0 || s[k] === ok);
      }, "invalid");
      if (s.opacity < 1 || invalid("zIndex", "auto") || invalid("transform", "none") || invalid("mixBlendMode", "normal") || invalid("filter", "none") || invalid("perspective", "none") || s["isolation"] === "isolate" || s.position === "fixed" || s.webkitOverflowScrolling === "touch") {
        return true;
      }
      el = el.parentElement;
    }
    return false;
  }
  __name(createsStackingContext, "createsStackingContext");
  function findNearestDialog(el) {
    while (el) {
      if (el.localName === "dialog") {
        return (
          /** @type {HTMLDialogElement} */
          el
        );
      }
      if (el.parentElement) {
        el = el.parentElement;
      } else if (el.parentNode) {
        el = el.parentNode.host;
      } else {
        el = null;
      }
    }
    return null;
  }
  __name(findNearestDialog, "findNearestDialog");
  function safeBlur(el) {
    while (el && el.shadowRoot && el.shadowRoot.activeElement) {
      el = el.shadowRoot.activeElement;
    }
    if (el && el.blur && el !== document.body) {
      el.blur();
    }
  }
  __name(safeBlur, "safeBlur");
  function inNodeList(nodeList, node) {
    for (var i2 = 0; i2 < nodeList.length; ++i2) {
      if (nodeList[i2] === node) {
        return true;
      }
    }
    return false;
  }
  __name(inNodeList, "inNodeList");
  function isFormMethodDialog(el) {
    if (!el || !el.hasAttribute("method")) {
      return false;
    }
    return el.getAttribute("method").toLowerCase() === "dialog";
  }
  __name(isFormMethodDialog, "isFormMethodDialog");
  function findFocusableElementWithin(hostElement) {
    var opts = ["button", "input", "keygen", "select", "textarea"];
    var query = opts.map(function(el) {
      return el + ":not([disabled])";
    });
    query.push('[tabindex]:not([disabled]):not([tabindex=""])');
    var target2 = hostElement.querySelector(query.join(", "));
    if (!target2 && "attachShadow" in Element.prototype) {
      var elems = hostElement.querySelectorAll("*");
      for (var i2 = 0; i2 < elems.length; i2++) {
        if (elems[i2].tagName && elems[i2].shadowRoot) {
          target2 = findFocusableElementWithin(elems[i2].shadowRoot);
          if (target2) {
            break;
          }
        }
      }
    }
    return target2;
  }
  __name(findFocusableElementWithin, "findFocusableElementWithin");
  function isConnected(element) {
    return element.isConnected || document.body.contains(element);
  }
  __name(isConnected, "isConnected");
  function findFormSubmitter(event) {
    if (event.submitter) {
      return event.submitter;
    }
    var form = event.target;
    if (!(form instanceof HTMLFormElement)) {
      return null;
    }
    var submitter = dialogPolyfill.formSubmitter;
    if (!submitter) {
      var target2 = event.target;
      var root = "getRootNode" in target2 && target2.getRootNode() || document;
      submitter = root.activeElement;
    }
    if (!submitter || submitter.form !== form) {
      return null;
    }
    return submitter;
  }
  __name(findFormSubmitter, "findFormSubmitter");
  function maybeHandleSubmit(event) {
    if (event.defaultPrevented) {
      return;
    }
    var form = (
      /** @type {!HTMLFormElement} */
      event.target
    );
    var value = dialogPolyfill.imagemapUseValue;
    var submitter = findFormSubmitter(event);
    if (value === null && submitter) {
      value = submitter.value;
    }
    var dialog = findNearestDialog(form);
    if (!dialog) {
      return;
    }
    var formmethod = submitter && submitter.getAttribute("formmethod") || form.getAttribute("method");
    if (formmethod !== "dialog") {
      return;
    }
    event.preventDefault();
    if (value != null) {
      dialog.close(value);
    } else {
      dialog.close();
    }
  }
  __name(maybeHandleSubmit, "maybeHandleSubmit");
  function dialogPolyfillInfo(dialog) {
    this.dialog_ = dialog;
    this.replacedStyleTop_ = false;
    this.openAsModal_ = false;
    if (!dialog.hasAttribute("role")) {
      dialog.setAttribute("role", "dialog");
    }
    dialog.show = this.show.bind(this);
    dialog.showModal = this.showModal.bind(this);
    dialog.close = this.close.bind(this);
    dialog.addEventListener("submit", maybeHandleSubmit, false);
    if (!("returnValue" in dialog)) {
      dialog.returnValue = "";
    }
    if ("MutationObserver" in window) {
      var mo = new MutationObserver(this.maybeHideModal.bind(this));
      mo.observe(dialog, { attributes: true, attributeFilter: ["open"] });
    } else {
      var removed = false;
      var cb = function() {
        removed ? this.downgradeModal() : this.maybeHideModal();
        removed = false;
      }.bind(this);
      var timeout;
      var delayModel = /* @__PURE__ */ __name(function(ev) {
        if (ev.target !== dialog) {
          return;
        }
        var cand = "DOMNodeRemoved";
        removed |= ev.type.substr(0, cand.length) === cand;
        window.clearTimeout(timeout);
        timeout = window.setTimeout(cb, 0);
      }, "delayModel");
      ["DOMAttrModified", "DOMNodeRemoved", "DOMNodeRemovedFromDocument"].forEach(function(name2) {
        dialog.addEventListener(name2, delayModel);
      });
    }
    Object.defineProperty(dialog, "open", {
      set: this.setOpen.bind(this),
      get: dialog.hasAttribute.bind(dialog, "open")
    });
    this.backdrop_ = document.createElement("div");
    this.backdrop_.className = "backdrop";
    this.backdrop_.addEventListener("mouseup", this.backdropMouseEvent_.bind(this));
    this.backdrop_.addEventListener("mousedown", this.backdropMouseEvent_.bind(this));
    this.backdrop_.addEventListener("click", this.backdropMouseEvent_.bind(this));
  }
  __name(dialogPolyfillInfo, "dialogPolyfillInfo");
  dialogPolyfillInfo.prototype = /** @type {HTMLDialogElement.prototype} */
  {
    get dialog() {
      return this.dialog_;
    },
    /**
     * Maybe remove this dialog from the modal top layer. This is called when
     * a modal dialog may no longer be tenable, e.g., when the dialog is no
     * longer open or is no longer part of the DOM.
     */
    maybeHideModal: function() {
      if (this.dialog_.hasAttribute("open") && isConnected(this.dialog_)) {
        return;
      }
      this.downgradeModal();
    },
    /**
     * Remove this dialog from the modal top layer, leaving it as a non-modal.
     */
    downgradeModal: function() {
      if (!this.openAsModal_) {
        return;
      }
      this.openAsModal_ = false;
      this.dialog_.style.zIndex = "";
      if (this.replacedStyleTop_) {
        this.dialog_.style.top = "";
        this.replacedStyleTop_ = false;
      }
      this.backdrop_.parentNode && this.backdrop_.parentNode.removeChild(this.backdrop_);
      dialogPolyfill.dm.removeDialog(this);
    },
    /**
     * @param {boolean} value whether to open or close this dialog
     */
    setOpen: function(value) {
      if (value) {
        this.dialog_.hasAttribute("open") || this.dialog_.setAttribute("open", "");
      } else {
        this.dialog_.removeAttribute("open");
        this.maybeHideModal();
      }
    },
    /**
     * Handles mouse events ('mouseup', 'mousedown', 'click') on the fake .backdrop element, redirecting them as if
     * they were on the dialog itself.
     *
     * @param {!Event} e to redirect
     */
    backdropMouseEvent_: function(e) {
      if (!this.dialog_.hasAttribute("tabindex")) {
        var fake = document.createElement("div");
        this.dialog_.insertBefore(fake, this.dialog_.firstChild);
        fake.tabIndex = -1;
        fake.focus();
        this.dialog_.removeChild(fake);
      } else {
        this.dialog_.focus();
      }
      var redirectedEvent = document.createEvent("MouseEvents");
      redirectedEvent.initMouseEvent(
        e.type,
        e.bubbles,
        e.cancelable,
        window,
        e.detail,
        e.screenX,
        e.screenY,
        e.clientX,
        e.clientY,
        e.ctrlKey,
        e.altKey,
        e.shiftKey,
        e.metaKey,
        e.button,
        e.relatedTarget
      );
      this.dialog_.dispatchEvent(redirectedEvent);
      e.stopPropagation();
    },
    /**
     * Focuses on the first focusable element within the dialog. This will always blur the current
     * focus, even if nothing within the dialog is found.
     */
    focus_: function() {
      var target2 = this.dialog_.querySelector("[autofocus]:not([disabled])");
      if (!target2 && this.dialog_.tabIndex >= 0) {
        target2 = this.dialog_;
      }
      if (!target2) {
        target2 = findFocusableElementWithin(this.dialog_);
      }
      safeBlur(document.activeElement);
      target2 && target2.focus();
    },
    /**
     * Sets the zIndex for the backdrop and dialog.
     *
     * @param {number} dialogZ
     * @param {number} backdropZ
     */
    updateZIndex: function(dialogZ, backdropZ) {
      if (dialogZ < backdropZ) {
        throw new Error("dialogZ should never be < backdropZ");
      }
      this.dialog_.style.zIndex = dialogZ;
      this.backdrop_.style.zIndex = backdropZ;
    },
    /**
     * Shows the dialog. If the dialog is already open, this does nothing.
     */
    show: function() {
      if (!this.dialog_.open) {
        this.setOpen(true);
        this.focus_();
      }
    },
    /**
     * Show this dialog modally.
     */
    showModal: function() {
      if (this.dialog_.hasAttribute("open")) {
        throw new Error("Failed to execute 'showModal' on dialog: The element is already open, and therefore cannot be opened modally.");
      }
      if (!isConnected(this.dialog_)) {
        throw new Error("Failed to execute 'showModal' on dialog: The element is not in a Document.");
      }
      if (!dialogPolyfill.dm.pushDialog(this)) {
        throw new Error("Failed to execute 'showModal' on dialog: There are too many open modal dialogs.");
      }
      if (createsStackingContext(this.dialog_.parentElement)) {
        console.warn("A dialog is being shown inside a stacking context. This may cause it to be unusable. For more information, see this link: https://github.com/GoogleChrome/dialog-polyfill/#stacking-context");
      }
      this.setOpen(true);
      this.openAsModal_ = true;
      if (dialogPolyfill.needsCentering(this.dialog_)) {
        dialogPolyfill.reposition(this.dialog_);
        this.replacedStyleTop_ = true;
      } else {
        this.replacedStyleTop_ = false;
      }
      this.dialog_.parentNode.insertBefore(this.backdrop_, this.dialog_.nextSibling);
      this.focus_();
    },
    /**
     * Closes this HTMLDialogElement. This is optional vs clearing the open
     * attribute, however this fires a 'close' event.
     *
     * @param {string=} opt_returnValue to use as the returnValue
     */
    close: function(opt_returnValue) {
      if (!this.dialog_.hasAttribute("open")) {
        throw new Error("Failed to execute 'close' on dialog: The element does not have an 'open' attribute, and therefore cannot be closed.");
      }
      this.setOpen(false);
      if (opt_returnValue !== void 0) {
        this.dialog_.returnValue = opt_returnValue;
      }
      var closeEvent = new supportCustomEvent("close", {
        bubbles: false,
        cancelable: false
      });
      safeDispatchEvent(this.dialog_, closeEvent);
    }
  };
  var dialogPolyfill = {};
  dialogPolyfill.reposition = function(element) {
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
    var topValue = scrollTop + (window.innerHeight - element.offsetHeight) / 2;
    element.style.top = Math.max(scrollTop, topValue) + "px";
  };
  dialogPolyfill.isInlinePositionSetByStylesheet = function(element) {
    for (var i2 = 0; i2 < document.styleSheets.length; ++i2) {
      var styleSheet = document.styleSheets[i2];
      var cssRules = null;
      try {
        cssRules = styleSheet.cssRules;
      } catch (e) {
      }
      if (!cssRules) {
        continue;
      }
      for (var j = 0; j < cssRules.length; ++j) {
        var rule = cssRules[j];
        var selectedNodes = null;
        try {
          selectedNodes = document.querySelectorAll(rule.selectorText);
        } catch (e) {
        }
        if (!selectedNodes || !inNodeList(selectedNodes, element)) {
          continue;
        }
        var cssTop = rule.style.getPropertyValue("top");
        var cssBottom = rule.style.getPropertyValue("bottom");
        if (cssTop && cssTop !== "auto" || cssBottom && cssBottom !== "auto") {
          return true;
        }
      }
    }
    return false;
  };
  dialogPolyfill.needsCentering = function(dialog) {
    var computedStyle = window.getComputedStyle(dialog);
    if (computedStyle.position !== "absolute") {
      return false;
    }
    if (dialog.style.top !== "auto" && dialog.style.top !== "" || dialog.style.bottom !== "auto" && dialog.style.bottom !== "") {
      return false;
    }
    return !dialogPolyfill.isInlinePositionSetByStylesheet(dialog);
  };
  dialogPolyfill.forceRegisterDialog = function(element) {
    if (window.HTMLDialogElement || element.showModal) {
      console.warn("This browser already supports <dialog>, the polyfill may not work correctly", element);
    }
    if (element.localName !== "dialog") {
      throw new Error("Failed to register dialog: The element is not a dialog.");
    }
    new dialogPolyfillInfo(
      /** @type {!HTMLDialogElement} */
      element
    );
  };
  dialogPolyfill.registerDialog = function(element) {
    if (!element.showModal) {
      dialogPolyfill.forceRegisterDialog(element);
    }
  };
  dialogPolyfill.DialogManager = function() {
    this.pendingDialogStack = [];
    var checkDOM = this.checkDOM_.bind(this);
    this.overlay = document.createElement("div");
    this.overlay.className = "_dialog_overlay";
    this.overlay.addEventListener("click", function(e) {
      this.forwardTab_ = void 0;
      e.stopPropagation();
      checkDOM([]);
    }.bind(this));
    this.handleKey_ = this.handleKey_.bind(this);
    this.handleFocus_ = this.handleFocus_.bind(this);
    this.zIndexLow_ = 1e5;
    this.zIndexHigh_ = 1e5 + 150;
    this.forwardTab_ = void 0;
    if ("MutationObserver" in window) {
      this.mo_ = new MutationObserver(function(records) {
        var removed = [];
        records.forEach(function(rec) {
          for (var i2 = 0, c; c = rec.removedNodes[i2]; ++i2) {
            if (!(c instanceof Element)) {
              continue;
            } else if (c.localName === "dialog") {
              removed.push(c);
            }
            removed = removed.concat(c.querySelectorAll("dialog"));
          }
        });
        removed.length && checkDOM(removed);
      });
    }
  };
  dialogPolyfill.DialogManager.prototype.blockDocument = function() {
    document.documentElement.addEventListener("focus", this.handleFocus_, true);
    document.addEventListener("keydown", this.handleKey_);
    this.mo_ && this.mo_.observe(document, { childList: true, subtree: true });
  };
  dialogPolyfill.DialogManager.prototype.unblockDocument = function() {
    document.documentElement.removeEventListener("focus", this.handleFocus_, true);
    document.removeEventListener("keydown", this.handleKey_);
    this.mo_ && this.mo_.disconnect();
  };
  dialogPolyfill.DialogManager.prototype.updateStacking = function() {
    var zIndex = this.zIndexHigh_;
    for (var i2 = 0, dpi; dpi = this.pendingDialogStack[i2]; ++i2) {
      dpi.updateZIndex(--zIndex, --zIndex);
      if (i2 === 0) {
        this.overlay.style.zIndex = --zIndex;
      }
    }
    var last = this.pendingDialogStack[0];
    if (last) {
      var p = last.dialog.parentNode || document.body;
      p.appendChild(this.overlay);
    } else if (this.overlay.parentNode) {
      this.overlay.parentNode.removeChild(this.overlay);
    }
  };
  dialogPolyfill.DialogManager.prototype.containedByTopDialog_ = function(candidate) {
    while (candidate = findNearestDialog(candidate)) {
      for (var i2 = 0, dpi; dpi = this.pendingDialogStack[i2]; ++i2) {
        if (dpi.dialog === candidate) {
          return i2 === 0;
        }
      }
      candidate = candidate.parentElement;
    }
    return false;
  };
  dialogPolyfill.DialogManager.prototype.handleFocus_ = function(event) {
    var target2 = event.composedPath ? event.composedPath()[0] : event.target;
    if (this.containedByTopDialog_(target2)) {
      return;
    }
    if (document.activeElement === document.documentElement) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    safeBlur(
      /** @type {Element} */
      target2
    );
    if (this.forwardTab_ === void 0) {
      return;
    }
    var dpi = this.pendingDialogStack[0];
    var dialog = dpi.dialog;
    var position = dialog.compareDocumentPosition(target2);
    if (position & Node.DOCUMENT_POSITION_PRECEDING) {
      if (this.forwardTab_) {
        dpi.focus_();
      } else if (target2 !== document.documentElement) {
        document.documentElement.focus();
      }
    }
    return false;
  };
  dialogPolyfill.DialogManager.prototype.handleKey_ = function(event) {
    this.forwardTab_ = void 0;
    if (event.keyCode === 27) {
      event.preventDefault();
      event.stopPropagation();
      var cancelEvent = new supportCustomEvent("cancel", {
        bubbles: false,
        cancelable: true
      });
      var dpi = this.pendingDialogStack[0];
      if (dpi && safeDispatchEvent(dpi.dialog, cancelEvent)) {
        dpi.dialog.close();
      }
    } else if (event.keyCode === 9) {
      this.forwardTab_ = !event.shiftKey;
    }
  };
  dialogPolyfill.DialogManager.prototype.checkDOM_ = function(removed) {
    var clone = this.pendingDialogStack.slice();
    clone.forEach(function(dpi) {
      if (removed.indexOf(dpi.dialog) !== -1) {
        dpi.downgradeModal();
      } else {
        dpi.maybeHideModal();
      }
    });
  };
  dialogPolyfill.DialogManager.prototype.pushDialog = function(dpi) {
    var allowed = (this.zIndexHigh_ - this.zIndexLow_) / 2 - 1;
    if (this.pendingDialogStack.length >= allowed) {
      return false;
    }
    if (this.pendingDialogStack.unshift(dpi) === 1) {
      this.blockDocument();
    }
    this.updateStacking();
    return true;
  };
  dialogPolyfill.DialogManager.prototype.removeDialog = function(dpi) {
    var index = this.pendingDialogStack.indexOf(dpi);
    if (index === -1) {
      return;
    }
    this.pendingDialogStack.splice(index, 1);
    if (this.pendingDialogStack.length === 0) {
      this.unblockDocument();
    }
    this.updateStacking();
  };
  dialogPolyfill.dm = new dialogPolyfill.DialogManager();
  dialogPolyfill.formSubmitter = null;
  dialogPolyfill.imagemapUseValue = null;
  if (window.HTMLDialogElement === void 0) {
    testForm = document.createElement("form");
    testForm.setAttribute("method", "dialog");
    if (testForm.method !== "dialog") {
      methodDescriptor = Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, "method");
      if (methodDescriptor) {
        realGet = methodDescriptor.get;
        methodDescriptor.get = function() {
          if (isFormMethodDialog(this)) {
            return "dialog";
          }
          return realGet.call(this);
        };
        realSet = methodDescriptor.set;
        methodDescriptor.set = function(v) {
          if (typeof v === "string" && v.toLowerCase() === "dialog") {
            return this.setAttribute("method", v);
          }
          return realSet.call(this, v);
        };
        Object.defineProperty(HTMLFormElement.prototype, "method", methodDescriptor);
      }
    }
    document.addEventListener("click", function(ev) {
      dialogPolyfill.formSubmitter = null;
      dialogPolyfill.imagemapUseValue = null;
      if (ev.defaultPrevented) {
        return;
      }
      var target2 = (
        /** @type {Element} */
        ev.target
      );
      if ("composedPath" in ev) {
        var path = ev.composedPath();
        target2 = path.shift() || target2;
      }
      if (!target2 || !isFormMethodDialog(target2.form)) {
        return;
      }
      var valid = target2.type === "submit" && ["button", "input"].indexOf(target2.localName) > -1;
      if (!valid) {
        if (!(target2.localName === "input" && target2.type === "image")) {
          return;
        }
        dialogPolyfill.imagemapUseValue = ev.offsetX + "," + ev.offsetY;
      }
      var dialog = findNearestDialog(target2);
      if (!dialog) {
        return;
      }
      dialogPolyfill.formSubmitter = target2;
    }, false);
    document.addEventListener("submit", function(ev) {
      var form = ev.target;
      var dialog = findNearestDialog(form);
      if (dialog) {
        return;
      }
      var submitter = findFormSubmitter(ev);
      var formmethod = submitter && submitter.getAttribute("formmethod") || form.getAttribute("method");
      if (formmethod === "dialog") {
        ev.preventDefault();
      }
    });
    nativeFormSubmit = HTMLFormElement.prototype.submit;
    replacementFormSubmit = /* @__PURE__ */ __name(function() {
      if (!isFormMethodDialog(this)) {
        return nativeFormSubmit.call(this);
      }
      var dialog = findNearestDialog(this);
      dialog && dialog.close();
    }, "replacementFormSubmit");
    HTMLFormElement.prototype.submit = replacementFormSubmit;
  }
  var testForm;
  var methodDescriptor;
  var realGet;
  var realSet;
  var nativeFormSubmit;
  var replacementFormSubmit;
  var dialog_polyfill_esm_default = dialogPolyfill;

  // simulator/src/LogicEditor.ts
  var import_file_saver3 = __toESM(require_FileSaver_min());
  var import_json57 = __toESM(require_dist());
  var LZString = __toESM(require_lz_string());
  var pngMeta = __toESM(require_png_metadata_writer());

  // simulator/src/ComponentFactory.ts
  var t37 = __toESM(require_lib());
  var import_json55 = __toESM(require_dist());

  // simulator/src/Serialization.ts
  var import_file_saver = __toESM(require_FileSaver_min());
  var import_json53 = __toESM(require_dist());
  var json5util = __toESM(require_util());

  // simulator/src/utils.ts
  var import_Either = __toESM(require_Either());
  var t2 = __toESM(require_lib());
  var import_PathReporter = __toESM(require_PathReporter());
  var import_json5 = __toESM(require_dist());
  var InBrowser = typeof window !== "undefined";
  var Any = void 0;
  function keysOf(o) {
    return Object.keys(o);
  }
  __name(keysOf, "keysOf");
  var RichStringEnum = class {
    constructor(props) {
      this.props = props;
      this._values = keysOf(props);
      for (let i2 = 0; i2 < this._values.length; i2++) {
        this[i2] = this._values[i2];
      }
    }
    static withProps() {
      return function(defs) {
        return new RichStringEnum(defs);
      };
    }
    get type() {
      throw new Error();
    }
    get values() {
      return this._values;
    }
    get length() {
      return this._values.length;
    }
    get definitions() {
      const defs = [];
      for (const i2 of this._values) {
        defs.push([i2, this.props[i2]]);
      }
      return defs;
    }
    includes(val) {
      return this.values.includes(val);
    }
    indexOf(val) {
      return this.values.indexOf(val);
    }
    *[Symbol.iterator]() {
      for (const i2 of this._values) {
        yield i2;
      }
    }
  };
  __name(RichStringEnum, "RichStringEnum");
  function tuple(...items) {
    return items;
  }
  __name(tuple, "tuple");
  function mergeWhereDefined(a2, b2) {
    const obj = __spreadValues({}, a2);
    for (const [k, v] of Object.entries(b2)) {
      if (v !== void 0) {
        obj[k] = v;
      }
    }
    return obj;
  }
  __name(mergeWhereDefined, "mergeWhereDefined");
  function brand() {
    return (val) => {
      return val;
    };
  }
  __name(brand, "brand");
  function defineADTStatics(cases, statics) {
    return __spreadValues(__spreadValues({}, statics), cases);
  }
  __name(defineADTStatics, "defineADTStatics");
  function isString(v) {
    return typeof v === "string";
  }
  __name(isString, "isString");
  function isArray(arg) {
    return Array.isArray(arg);
  }
  __name(isArray, "isArray");
  function isNumber(arg) {
    return typeof arg === "number";
  }
  __name(isNumber, "isNumber");
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  __name(isBoolean, "isBoolean");
  function isRecord(arg) {
    return typeof arg === "object" && arg !== null;
  }
  __name(isRecord, "isRecord");
  function ArrayFillWith(val, n) {
    return Array(n).fill(val);
  }
  __name(ArrayFillWith, "ArrayFillWith");
  function ArrayFillUsing(val, n) {
    const arr = Array(n);
    for (let i2 = 0; i2 < n; i2++) {
      arr[i2] = val(i2);
    }
    return arr;
  }
  __name(ArrayFillUsing, "ArrayFillUsing");
  function ArrayClampOrPad(arr, len, padValue) {
    const missing = len - arr.length;
    if (missing === 0) {
      return arr;
    }
    if (missing > 0) {
      for (let i2 = 0; i2 < missing; i2++) {
        arr.push(padValue);
      }
    } else {
      arr.splice(len, -missing);
    }
    return arr;
  }
  __name(ArrayClampOrPad, "ArrayClampOrPad");
  function FixedArrayFillWith(val, n) {
    return ArrayFillWith(val, n);
  }
  __name(FixedArrayFillWith, "FixedArrayFillWith");
  function FixedArrayMap(items, fn2) {
    return items.map(fn2);
  }
  __name(FixedArrayMap, "FixedArrayMap");
  function FixedArrayAssert(arr, n) {
    if (arr.length !== n) {
      throw new Error(`FixedArrayAssert: expected length ${n}, got ${arr.length}`);
    }
    return arr;
  }
  __name(FixedArrayAssert, "FixedArrayAssert");
  function JSONParseObject(str) {
    const parsed = import_json5.default.parse(str);
    if (isRecord(parsed)) {
      return parsed;
    }
    throw new Error("JSONParseObject: not an object");
  }
  __name(JSONParseObject, "JSONParseObject");
  function isTruthyString(str) {
    return str !== null && str !== void 0 && (str === "1" || str.toLowerCase() === "true");
  }
  __name(isTruthyString, "isTruthyString");
  function isFalsyString(str) {
    return str !== null && str !== void 0 && (str === "0" || str.toLowerCase() === "false");
  }
  __name(isFalsyString, "isFalsyString");
  function getURLParameter(sParam, defaultValue) {
    const sPageURL = window.location.search.substring(1);
    const sURLVariables = sPageURL.split("&");
    for (const sURLVariable of sURLVariables) {
      const sParameterName = sURLVariable.split("=");
      if (sParameterName[0] === sParam) {
        return sParameterName[1];
      }
    }
    return defaultValue;
  }
  __name(getURLParameter, "getURLParameter");
  function isEmbeddedInIframe() {
    try {
      return window.self !== window.top;
    } catch (e) {
      return true;
    }
  }
  __name(isEmbeddedInIframe, "isEmbeddedInIframe");
  function onVisible(element, callback) {
    new IntersectionObserver((entries, observer) => {
      entries.forEach((entry) => {
        if (entry.intersectionRatio > 0) {
          callback();
          observer.disconnect();
          return;
        }
      });
    }).observe(element);
  }
  __name(onVisible, "onVisible");
  function setEnabled(elem, enabled) {
    if (enabled) {
      elem.removeAttribute("disabled");
    } else {
      elem.setAttribute("disabled", "disabled");
    }
  }
  __name(setEnabled, "setEnabled");
  function setVisible(elem, visible) {
    if (visible) {
      const prevDisplay = elem.getAttribute("data-prev-display");
      if (prevDisplay === null) {
        if (elem.style.display === "none") {
          elem.style.removeProperty("display");
        } else {
        }
      } else {
        elem.removeAttribute("data-prev-display");
        elem.style.display = prevDisplay;
      }
    } else {
      const currentDisplay = elem.style.display;
      if (currentDisplay.length !== 0 && currentDisplay !== "none") {
        elem.setAttribute("data-prev-display", currentDisplay);
      }
      elem.style.display = "none";
    }
  }
  __name(setVisible, "setVisible");
  function toggleVisible(elem) {
    setVisible(elem, elem.style.display === "none");
  }
  __name(toggleVisible, "toggleVisible");
  function setHidden(elem, hidden) {
    if (hidden) {
      elem.style.visibility = "hidden";
    } else {
      elem.style.removeProperty("visibility");
    }
  }
  __name(setHidden, "setHidden");
  function setDisplay(elem, display) {
    setVisible(elem, display !== "hide");
    setHidden(elem, display === "inactive");
  }
  __name(setDisplay, "setDisplay");
  function setActive(elem, active) {
    if (active) {
      elem.classList.add("active");
    } else {
      elem.classList.remove("active");
    }
  }
  __name(setActive, "setActive");
  function showModal(dlog) {
    if (typeof dlog.showModal === "function") {
      dlog.style.display = "initial";
      dlog.showModal();
      const listener = /* @__PURE__ */ __name(() => {
        dlog.style.display = "none";
        dlog.removeEventListener("close", listener);
      }, "listener");
      dlog.addEventListener("close", listener);
      return true;
    }
    return false;
  }
  __name(showModal, "showModal");
  var InteractionResultCases = {
    NoChange: { _tag: "NoChange", isChange: false },
    SimpleChange: { _tag: "SimpleChange", isChange: true },
    RepeatableChange: (repeat) => ({ _tag: "RepeatableChange", isChange: true, repeat })
  };
  var InteractionResult = defineADTStatics(InteractionResultCases, {
    fromBoolean: (changed) => changed ? InteractionResult.SimpleChange : InteractionResult.NoChange,
    merge: (r0, r1) => {
      if (r0._tag === "NoChange") {
        return r1;
      }
      if (r0._tag === "RepeatableChange") {
        return r0;
      }
      if (r1._tag === "RepeatableChange") {
        return r1;
      }
      return r0;
    }
  });
  var EdgeTrigger = {
    rising: "rising",
    falling: "falling"
  };
  var ComponentTypeInput = "in";
  var ComponentTypeOutput = "out";
  function repeatString(c, n) {
    return Array(n + 1).join(c);
  }
  __name(repeatString, "repeatString");
  function formatString(str, ...varargs) {
    if (varargs.length) {
      const t38 = typeof varargs[0];
      const args = "string" === t38 || "number" === t38 ? Array.prototype.slice.call(varargs) : varargs[0];
      for (const key in args) {
        str = str.replace(new RegExp("\\{" + key + "\\}", "gi"), args[key]);
      }
    }
    return str;
  }
  __name(formatString, "formatString");
  function deepObjectEquals(v1, v2) {
    const keys1 = Object.keys(v1);
    const keys2 = Object.keys(v2);
    if (keys1.length !== keys2.length) {
      return false;
    }
    for (const key of keys1) {
      if (!deepArrayEquals(v1[key], v2[key])) {
        return false;
      }
    }
    return true;
  }
  __name(deepObjectEquals, "deepObjectEquals");
  function deepArrayEquals(v1, v2) {
    if (isArray(v1) && isArray(v2)) {
      if (v1.length !== v2.length) {
        return false;
      }
      for (let i2 = 0; i2 < v1.length; i2++) {
        if (v1[i2] !== v2[i2]) {
          return false;
        }
      }
      return true;
    } else {
      return v1 === v2;
    }
  }
  __name(deepArrayEquals, "deepArrayEquals");
  var typeOrUndefined = /* @__PURE__ */ __name((tpe) => {
    return t2.union([tpe, t2.undefined], tpe.name + " | undefined");
  }, "typeOrUndefined");
  var typeOrNull = /* @__PURE__ */ __name((tpe) => {
    return t2.union([tpe, t2.null], tpe.name + " | null");
  }, "typeOrNull");
  function validateJson(obj, repr, what) {
    const validated = repr.decode(obj);
    if ((0, import_Either.isLeft)(validated)) {
      console.warn(`ERROR while parsing ${what} from %o -> %s: `, obj, import_PathReporter.PathReporter.report(validated).join("; "));
      return void 0;
    }
    return validated.right;
  }
  __name(validateJson, "validateJson");
  var HighImpedance = "Z";
  function isHighImpedance(v) {
    return v === HighImpedance;
  }
  __name(isHighImpedance, "isHighImpedance");
  var Unknown = "?";
  function isUnknown(v) {
    return v === Unknown;
  }
  __name(isUnknown, "isUnknown");
  var TUnknown = new t2.Type(
    "Unknown",
    isUnknown,
    (input2, context) => isUnknown(input2) ? t2.success(input2) : t2.failure(input2, context),
    t2.identity
  );
  var LogicValue = {
    invert(v) {
      return isUnknown(v) || isHighImpedance(v) ? v : !v;
    },
    filterHighZ(v) {
      return isHighImpedance(v) ? Unknown : v;
    }
  };
  var LogicValueRepr = new t2.Type(
    "0|1|?|Z",
    (v) => isUnknown(v) || isHighImpedance(v) || v === 1 || v === 0,
    (input2, context) => isUnknown(input2) ? t2.success(input2) : isHighImpedance(input2) ? t2.success(input2) : input2 === 1 ? t2.success(1) : input2 === 0 ? t2.success(0) : t2.failure(input2, context),
    t2.identity
  );
  function toLogicValueRepr(v) {
    switch (v) {
      case true:
        return 1;
      case false:
        return 0;
      case Unknown:
        return Unknown;
      case HighImpedance:
        return HighImpedance;
      case void 0:
        return void 0;
    }
  }
  __name(toLogicValueRepr, "toLogicValueRepr");
  function toLogicValue(v) {
    switch (v) {
      case 1:
        return true;
      case 0:
        return false;
      case Unknown:
        return Unknown;
      case HighImpedance:
        return HighImpedance;
      case void 0:
        return void 0;
    }
  }
  __name(toLogicValue, "toLogicValue");
  function toLogicValueFromChar(char) {
    switch (char) {
      case "1":
        return true;
      case "0":
        return false;
      case Unknown:
        return Unknown;
      case HighImpedance:
        return HighImpedance;
      default:
        return Unknown;
    }
  }
  __name(toLogicValueFromChar, "toLogicValueFromChar");
  var InputOutputValueRepr = t2.union([
    LogicValueRepr,
    t2.string,
    t2.array(LogicValueRepr)
  ]);
  function allBooleans(values) {
    for (const v of values) {
      if (v !== true && v !== false) {
        return false;
      }
    }
    return true;
  }
  __name(allBooleans, "allBooleans");
  function isAllZeros(s) {
    for (const c of s) {
      if (c !== "0") {
        return false;
      }
    }
    return true;
  }
  __name(isAllZeros, "isAllZeros");
  function binaryStringRepr(values) {
    const binStr = values.map(toLogicValueRepr).reverse().join("");
    return binStr;
  }
  __name(binaryStringRepr, "binaryStringRepr");
  function valuesReprForTest(values) {
    return values.length === 1 ? toLogicValueRepr(values[0]) : binaryStringRepr(values);
  }
  __name(valuesReprForTest, "valuesReprForTest");
  function hexStringRepr(values, hexWidth) {
    const binStr = binaryStringRepr(values);
    return parseInt(binStr, 2).toString(16).toUpperCase().padStart(hexWidth, "0");
  }
  __name(hexStringRepr, "hexStringRepr");
  function valuesFromBinaryOrHexRepr(wordRepr, numBits) {
    const len = wordRepr.length;
    const isBinary = len === numBits;
    const binaryRepr = isBinary ? wordRepr : parseInt(wordRepr, 16).toString(2).padStart(numBits, "0");
    const row = Array(numBits);
    for (let i2 = 0; i2 < numBits; i2++) {
      row[i2] = toLogicValueFromChar(binaryRepr[numBits - i2 - 1]);
    }
    return row;
  }
  __name(valuesFromBinaryOrHexRepr, "valuesFromBinaryOrHexRepr");
  function valuesFromReprForInput(repr, numBits) {
    if (repr === void 0 || isString(repr) && repr.length === 0) {
      return ArrayFillWith(false, numBits);
    }
    if (isArray(repr)) {
      return ArrayClampOrPad(repr.map((v) => toLogicValue(v)), numBits, false);
    }
    if (isNumber(repr)) {
      return ArrayFillWith(toLogicValue(repr), numBits);
    }
    return ArrayClampOrPad(Array.from(repr).reverse().map((v) => toLogicValueFromChar(v)), numBits, false);
  }
  __name(valuesFromReprForInput, "valuesFromReprForInput");
  function reprForLogicValues(values, undefinedIfTrivial) {
    const numBits = values.length;
    if (numBits === 1) {
      const value = values[0];
      return undefinedIfTrivial && value === false ? void 0 : toLogicValueRepr(value);
    }
    if (undefinedIfTrivial) {
      let nontrivial = false;
      for (let i2 = 0; i2 < numBits; i2++) {
        if (values[i2] !== false) {
          nontrivial = true;
          break;
        }
      }
      if (!nontrivial) {
        return void 0;
      }
    }
    return values.map(toLogicValueRepr).reverse().join("");
  }
  __name(reprForLogicValues, "reprForLogicValues");
  function copyToClipboard(textToCopy) {
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    __name(isOS, "isOS");
    const textArea = document.createElement("textarea");
    textArea.readOnly = true;
    textArea.contentEditable = "true";
    textArea.value = textToCopy;
    document.body.appendChild(textArea);
    if (isOS()) {
      const range = document.createRange();
      range.selectNodeContents(textArea);
      const selection = window.getSelection();
      if (selection !== null) {
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      }
    } else {
      textArea.select();
    }
    const ok = document.execCommand("copy");
    document.body.removeChild(textArea);
    return ok;
  }
  __name(copyToClipboard, "copyToClipboard");
  function pasteFromClipboard() {
    const textArea = document.createElement("textarea");
    textArea.readOnly = false;
    textArea.contentEditable = "true";
    document.body.appendChild(textArea);
    let result = void 0;
    textArea.focus();
    const ok = document.execCommand("paste");
    if (ok && textArea.value.length > 0) {
      result = textArea.value;
    }
    document.body.removeChild(textArea);
    return result;
  }
  __name(pasteFromClipboard, "pasteFromClipboard");
  function targetIsFieldOrOtherInput(e) {
    const targets = e.composedPath();
    let elem, tagName;
    return targets.length !== 0 && (elem = targets[0]) instanceof HTMLElement && ((tagName = elem.tagName) === "INPUT" || tagName === "SELECT");
  }
  __name(targetIsFieldOrOtherInput, "targetIsFieldOrOtherInput");
  function getScrollParent(element) {
    let style2 = getComputedStyle(element);
    const excludeStaticParent = style2.position === "absolute";
    const overflowRegex = /(auto|scroll)/;
    if (style2.position === "fixed") {
      return document;
    }
    let parent;
    for (parent = element; parent = parent.parentElement; ) {
      style2 = getComputedStyle(parent);
      if (excludeStaticParent && style2.position === "static") {
        continue;
      }
      if (overflowRegex.test(style2.overflow + style2.overflowY + style2.overflowX)) {
        return parent;
      }
    }
    return document;
  }
  __name(getScrollParent, "getScrollParent");
  var fetchJSONP = ((unique) => (url) => new Promise((resolve) => {
    const script = document.createElement("script");
    const name2 = `_jsonp_${unique++}`;
    if (url.match(/\?/)) {
      url += `&callback=${name2}`;
    } else {
      url += `?callback=${name2}`;
    }
    script.src = url;
    window[name2] = (json) => {
      script.remove();
      delete window[name2];
      resolve(import_json5.default.stringify(json));
    };
    document.body.appendChild(script);
  }))(0);

  // simulator/src/DataMigration.ts
  var CurrentFormatVersion = 6;
  function migrateData(data2) {
    var _a;
    const LogBeforeAfter = false;
    const initialRepr = !LogBeforeAfter ? void 0 : isString(data2) ? data2 : stringifySmart(data2, { maxLength: 140 });
    let jsonVersion = Number((_a = data2.v) != null ? _a : 0);
    const savedVersion = jsonVersion;
    if (savedVersion > CurrentFormatVersion) {
      throw new Error(`Data format v${savedVersion} is newer than what this editor can load (v \u2264 ${CurrentFormatVersion}`);
    }
    while (jsonVersion < CurrentFormatVersion) {
      const migrationFunc = migrateTo[++jsonVersion];
      migrationFunc(data2);
      const defs = data2.defs;
      if (isArray(defs)) {
        for (const def of defs) {
          const circuit = def.circuit;
          if (isRecord(circuit)) {
            migrationFunc(circuit);
          }
        }
      }
      data2.v = jsonVersion;
    }
    if (jsonVersion !== savedVersion) {
      console.log(`Migrated data format from v${savedVersion} to v${jsonVersion}, consider upgrading the source`);
      if (LogBeforeAfter) {
        console.log("BEFORE:\n" + initialRepr);
        console.log("AFTER:\n" + Serialization.stringifyObject(data2, false));
      }
    } else if (LogBeforeAfter) {
      console.log(`Data format ${savedVersion} is up to date, no migration necessary`);
    }
  }
  __name(migrateData, "migrateData");
  var migrateTo = {
    6: (container) => {
      const compFieldsAndCategories = {
        in: "in",
        out: "out",
        gates: "gate",
        ic: "ic",
        labels: "label",
        layout: "layout"
      };
      const oldToNewId = {
        "in": "in",
        "in.clock": "clock",
        "in.random": "rand",
        "out": "out",
        "out.display": "display",
        "out.7seg": "7seg",
        "out.16seg": "16seg",
        "out.ascii": "ascii",
        "out.bar": "bar",
        "out.shift-buffer": "shift-display",
        "out.shift-register": "shift-reg",
        "ic.switched-inverter": "cnot-array",
        "ic.gate-array": "{gatetype}-array",
        "ic.tristate-array": "tristate-array",
        "label": "label",
        "label.rect": "rect",
        "layout.pass": "pass",
        "ic.halfadder": "halfadder",
        "ic.adder": "adder",
        "ic.comparator": "comp",
        "ic.adder-array": "adder-array",
        "ic.alu": "alu",
        "ic.mux": "mux",
        "ic.demux": "demux",
        "ic.latch-sr": "latch-sr",
        "ic.flipflop-jk": "ff-jk",
        "ic.flipflop-t": "ff-t",
        "ic.flipflop-d": "ff-d",
        "ic.register": "reg",
        "ic.shift-register": "shift-reg",
        "ic.counter": "counter",
        "ic.ram": "ram",
        "ic.rom": "rom",
        "ic.decoder": "dec",
        "ic.decoder-7seg": "dec-7seg",
        "ic.decoder-16seg": "dec-16seg",
        "ic.decoder-bcd4": "dec-bcd4"
      };
      function newTypeFor(category, item) {
        if (category === "gate") {
          if (!isString(item.type)) {
            console.warn("Gate with no type found, assuming AND", item);
            return "and";
          }
          const gateType = item.type.toLowerCase();
          return gateType === "tri" ? "tristate" : gateType;
        } else {
          const id = isString(item.type) ? `${category}.${item.type}` : category;
          if (id === "ic.gate-array") {
            let gateType;
            if (!isString(item.subtype)) {
              console.warn("Gate array with no subtype found, assuming AND", item);
              gateType = "and";
            } else {
              gateType = item.subtype.toLowerCase();
            }
            delete item.subtype;
            return `${gateType}-array`;
          } else if (id in oldToNewId) {
            return oldToNewId[id];
          } else if (id.startsWith("ic.custom-")) {
            return id.substring(3);
          } else {
            console.error(`Unknown component type: ${id}`);
            return id;
          }
        }
      }
      __name(newTypeFor, "newTypeFor");
      const components = [];
      for (const [field, category] of Object.entries(compFieldsAndCategories)) {
        const list = container[field];
        if (isArray(list)) {
          for (const compRepr of list) {
            if (isRecord(compRepr)) {
              const newType = newTypeFor(category, compRepr);
              compRepr.type = newType;
              if (category === "gate" && isString(compRepr.poseAs)) {
                compRepr.poseAs = compRepr.poseAs.toLowerCase();
              }
              components.push(compRepr);
            }
          }
        }
        delete container[field];
      }
      container.components = components;
    },
    5: (container) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
      let type7;
      let match;
      const ins = container.in;
      if (isArray(ins)) {
        for (const in_ of ins) {
          if (isString(type7 = in_.type)) {
            if (type7 === "nibble") {
              delete in_.type;
              in_.bits = 4;
            } else if (type7 === "byte") {
              delete in_.type;
              in_.bits = 8;
            }
          }
        }
      }
      const outs = container.out;
      if (isArray(outs)) {
        for (const out of outs) {
          if (isString(type7 = out.type)) {
            if (type7 === "nibble") {
              delete out.type;
              out.bits = 4;
            } else if (type7 === "byte") {
              delete out.type;
              out.bits = 8;
            } else if (type7 === "nibble-display") {
              out.type = "display";
              out.bits = 4;
            } else if (type7 === "byte-display") {
              out.type = "display";
              out.bits = 8;
            } else if (type7 === "shiftbuffer") {
              out.type = "shift-buffer";
            }
          }
        }
      }
      const gates = container.gates;
      if (isArray(gates)) {
        for (const gate of gates) {
          if (isString(type7 = gate.type)) {
            const lastChar = type7[type7.length - 1];
            const maybeBit = parseInt(lastChar);
            if (!isNaN(maybeBit)) {
              gate.bits = maybeBit;
              gate.type = type7.slice(0, -1);
            }
          }
        }
      }
      const components = container.components;
      if (isArray(components)) {
        const ramRegex = new RegExp("^ram-(?<lines>\\d+)x(?<bits>\\d+)$");
        const muxRegex = new RegExp("^mux-(?<from>\\d+)to(?<to>\\d+)$");
        const demuxRegex = new RegExp("^demux-(?<from>\\d+)to(?<to>\\d+)$");
        for (const comp of components) {
          if (isString(type7 = comp.type)) {
            if (type7 === "register") {
              let state;
              if (isArray(state = comp.state)) {
                const binStr = binaryStringRepr(state.map(toLogicValue));
                if (!isAllZeros(binStr)) {
                  comp.content = binStr;
                }
                delete comp.state;
              }
            } else if (type7 === "quad-gate") {
              comp.type = "gate-array";
            } else if (type7 === "quad-tristate") {
              comp.type = "tristate-array";
            } else if ((match = ramRegex.exec(type7)) !== null) {
              comp.type = "ram";
              comp.bits = parseInt((_b = (_a = match.groups) == null ? void 0 : _a.bits) != null ? _b : "4");
              comp.lines = parseInt((_d = (_c = match.groups) == null ? void 0 : _c.lines) != null ? _d : "16");
            } else if ((match = muxRegex.exec(type7)) !== null) {
              comp.type = "mux";
              comp.from = parseInt((_f = (_e = match.groups) == null ? void 0 : _e.from) != null ? _f : "8");
              comp.to = parseInt((_h = (_g = match.groups) == null ? void 0 : _g.to) != null ? _h : "4");
            } else if ((match = demuxRegex.exec(type7)) !== null) {
              comp.type = "demux";
              comp.from = parseInt((_j = (_i = match.groups) == null ? void 0 : _i.from) != null ? _j : "4");
              comp.to = parseInt((_l = (_k = match.groups) == null ? void 0 : _k.to) != null ? _l : "8");
            }
          }
        }
        container.ic = components;
        delete container.components;
      }
      const layouts = container.layout;
      if (isArray(layouts)) {
        const passthroughRegex = new RegExp("^pass-(?<bits>\\d+)$");
        for (const layout of layouts) {
          if (isString(type7 = layout.type)) {
            if ((match = passthroughRegex.exec(type7)) !== null) {
              layout.type = "pass";
              layout.bits = parseInt((_n = (_m = match.groups) == null ? void 0 : _m.bits) != null ? _n : "1");
            }
          }
        }
      }
    },
    4: (container) => {
      let nextNewId = findFirstFreeId(container);
      const outs = container.out;
      if (isArray(outs)) {
        for (const out of outs) {
          if (out.type === "nibble") {
            out.type = "nibble-display";
          }
        }
      }
      const components = container.components;
      if (isArray(components)) {
        for (const comp of components) {
          if (comp.type === "alu") {
            if (isArray(comp.out)) {
              comp.out.push(nextNewId++);
              const t38 = comp.out[4];
              comp.out[4] = comp.out[6];
              comp.out[6] = t38;
            }
          }
        }
      }
    },
    3: (container) => {
      let nextNewId = findFirstFreeId(container);
      const components = container.components;
      if (isArray(components)) {
        for (const comp of components) {
          if (comp.type === "alu") {
            if (isArray(comp.in)) {
              comp.in.push(nextNewId++);
            }
          }
        }
      }
    },
    2: (container) => {
      const wires = container.wires;
      if (isArray(wires)) {
        for (const wire of wires) {
          if (isArray(wire) && wire.length === 3) {
            const wireOptions = wire[2];
            if ("waypoints" in wireOptions) {
              wireOptions.via = wireOptions.waypoints;
              delete wireOptions.waypoints;
            }
          }
        }
      }
    },
    1: (container) => {
      if ("displays" in container) {
        const displays = container.displays;
        delete container.displays;
        if (!("out" in container)) {
          container.out = [];
        }
        if (isArray(displays) && isArray(container.out)) {
          for (const display of displays) {
            container.out.push(display);
          }
        }
      }
      if ("clocks" in container) {
        const clocks = container.clocks;
        delete container.clocks;
        if (!("in" in container)) {
          container.in = [];
        }
        if (isArray(clocks) && isArray(container.in)) {
          for (const clock of clocks) {
            clock.type = "clock";
            container.in.push(clock);
          }
        }
      }
      const components = container.components;
      if (isArray(components)) {
        for (const comp of components) {
          let type7;
          if (isString(type7 = comp.type) && type7.startsWith("flipflop")) {
            const inputs = comp.in;
            const lastThree = inputs.splice(-3);
            comp.in = [...lastThree, ...inputs];
          }
        }
      }
    }
  };
  function findFirstFreeId(parsedContents) {
    let maxId = -1;
    function inspectComponentDef(compDef) {
      for (const fieldName of ["id", "in", "out"]) {
        inspectValue(compDef[fieldName]);
      }
    }
    __name(inspectComponentDef, "inspectComponentDef");
    function inspectValue(value) {
      if (value === void 0) {
        return;
      }
      if (typeof value === "number") {
        if (!isNaN(value) && isFinite(value)) {
          maxId = Math.max(maxId, value);
        }
      } else if (typeof value === "string") {
        for (const val of value.split("-")) {
          inspectValue(parseInt(val));
        }
      } else if (isArray(value)) {
        for (const item of value) {
          inspectValue(item);
        }
      } else if (typeof value === "object" && value !== null) {
        inspectValue(value.id);
      }
    }
    __name(inspectValue, "inspectValue");
    for (const jsonField of Object.keys(parsedContents)) {
      const arr = parsedContents[jsonField];
      if (arr !== void 0 && isArray(arr)) {
        for (const comp of arr) {
          inspectComponentDef(comp);
        }
      }
    }
    return maxId + 1;
  }
  __name(findFirstFreeId, "findFirstFreeId");

  // simulator/src/TestSuite.ts
  var t3 = __toESM(require_lib());

  // simulator/img/icons/add.icon.svg
  var add_icon_default = '<svg viewBox="0 0 20 20"><path d="M10 14.167Q10.354 14.167 10.615 13.906Q10.875 13.646 10.875 13.292V10.875H13.312Q13.667 10.875 13.917 10.625Q14.167 10.375 14.167 10Q14.167 9.646 13.906 9.385Q13.646 9.125 13.292 9.125H10.875V6.688Q10.875 6.333 10.625 6.083Q10.375 5.833 10 5.833Q9.646 5.833 9.385 6.094Q9.125 6.354 9.125 6.708V9.125H6.688Q6.333 9.125 6.083 9.375Q5.833 9.625 5.833 10Q5.833 10.354 6.094 10.615Q6.354 10.875 6.708 10.875H9.125V13.312Q9.125 13.667 9.375 13.917Q9.625 14.167 10 14.167ZM10 18.333Q8.271 18.333 6.75 17.677Q5.229 17.021 4.104 15.896Q2.979 14.771 2.323 13.25Q1.667 11.729 1.667 10Q1.667 8.271 2.323 6.75Q2.979 5.229 4.104 4.104Q5.229 2.979 6.75 2.323Q8.271 1.667 10 1.667Q11.729 1.667 13.25 2.323Q14.771 2.979 15.896 4.104Q17.021 5.229 17.677 6.75Q18.333 8.271 18.333 10Q18.333 11.729 17.677 13.25Q17.021 14.771 15.896 15.896Q14.771 17.021 13.25 17.677Q11.729 18.333 10 18.333Z"/></svg>';

  // simulator/img/icons/bordercolor.icon.svg
  var bordercolor_icon_default = '<svg viewBox="0 0 20 20"><path d="M3.417 20q-.729 0-1.24-.51-.51-.511-.51-1.24t.51-1.24q.511-.51 1.24-.51h13.166q.729 0 1.24.51.51.511.51 1.24t-.51 1.24q-.511.51-1.24.51Zm1.125-5.021q-.354 0-.615-.26-.26-.261-.26-.615v-2.042q0-.166.062-.322.063-.157.188-.282l7.021-7.02 3.27 3.27-7.02 7.021q-.126.125-.282.188-.156.062-.323.062Zm10.729-8.333L12 3.375l1.458-1.458q.25-.25.646-.25t.646.25L16.833 4q.229.229.177.594-.052.364-.281.594Z"/></svg>';

  // simulator/img/icons/check.icon.svg
  var check_icon_default = '<svg viewBox="0 0 20 20"><path d="M7.979 14.646Q7.812 14.646 7.656 14.583Q7.5 14.521 7.354 14.375L3.833 10.854Q3.583 10.604 3.594 10.219Q3.604 9.833 3.854 9.583Q4.104 9.333 4.479 9.333Q4.854 9.333 5.104 9.583L8.021 12.5L14.917 5.604Q15.167 5.354 15.531 5.354Q15.896 5.354 16.146 5.604Q16.396 5.854 16.396 6.219Q16.396 6.583 16.146 6.833L8.604 14.375Q8.458 14.521 8.302 14.583Q8.146 14.646 7.979 14.646Z"/></svg>';

  // simulator/img/icons/close.icon.svg
  var close_icon_default = '<svg viewBox="0 0 20 20"><path d="M10 11.229 5.979 15.25q-.25.25-.604.24-.354-.011-.604-.261t-.25-.614q0-.365.25-.615l4-4L4.75 5.979q-.25-.25-.24-.614.011-.365.261-.615t.614-.25q.365 0 .615.25l4 4.021 4.021-4.021q.25-.25.614-.25.365 0 .615.25t.25.615q0 .364-.25.614L11.229 10l4.021 4.021q.25.25.25.604t-.25.604q-.25.25-.615.25-.364 0-.614-.25Z"/></svg>';

  // simulator/img/icons/connect.icon.svg
  var connect_icon_default = '<svg viewBox="0 96 960 960"><path d="M744 912q-41 0-72-24t-42-60H396q-55 0-93.5-38.5T264 696q0-55 38.5-93.5T396 564h120q34.65 0 59.325-24.748Q600 514.504 600 479.752 600 445 575.325 420.5T516 396H330q-11 36-42 60t-72 24q-50 0-85-35t-35-85q0-50 35-85t85-35q41 0 72 24t42 60h186q65 0 110.5 45.5T672 480q0 65-45.5 110.5T516 636H396q-24.75 0-42.375 17.677T336 696.177Q336 721 353.625 738.5T396 756h234q11-36 42-60t72-24q50 0 85 35t35 85q0 50-35 85t-85 35ZM216 408q20.4 0 34.2-13.8Q264 380.4 264 360q0-20.4-13.8-34.2Q236.4 312 216 312q-20.4 0-34.2 13.8Q168 339.6 168 360q0 20.4 13.8 34.2Q195.6 408 216 408Z" transform="rotate(180 480 590)"/></svg>';

  // simulator/img/icons/dimensions.icon.svg
  var dimensions_icon_default = '<svg viewBox="0 0 20 20"><path d="M10 8.396q-.354 0-.615-.261-.26-.26-.26-.614V5.125l-.792.792q-.271.271-.635.26-.365-.01-.636-.281-.27-.271-.27-.646t.27-.646l2.313-2.312q.146-.146.302-.209.156-.062.323-.062t.323.062q.156.063.302.209l2.333 2.333q.271.271.261.635-.011.365-.281.636-.271.271-.646.271t-.646-.271l-.771-.771v2.396q0 .354-.26.614-.261.261-.615.261Zm0 9.583q-.167 0-.323-.062-.156-.063-.302-.209l-2.333-2.333q-.271-.271-.261-.635.011-.365.281-.636.271-.271.646-.271t.646.271l.771.771v-2.396q0-.354.26-.614.261-.261.615-.261t.615.261q.26.26.26.614v2.396l.792-.792q.271-.271.635-.26.365.01.636.281.27.271.27.646t-.27.646l-2.313 2.312q-.146.146-.302.209-.156.062-.323.062Zm4.104-5.041q-.271-.271-.271-.646t.271-.646l.771-.771h-2.396q-.354 0-.614-.26-.261-.261-.261-.615t.261-.615q.26-.26.614-.26h2.396l-.792-.792q-.271-.271-.26-.635.01-.365.281-.636.271-.27.646-.27t.646.27l2.312 2.313q.146.146.209.302.062.156.062.323t-.062.323q-.063.156-.209.302l-2.333 2.333q-.271.271-.635.261-.365-.011-.636-.281Zm-9.5 0-2.312-2.313q-.146-.146-.209-.302-.062-.156-.062-.323t.062-.323q.063-.156.209-.302l2.333-2.333q.271-.271.635-.261.365.011.636.281.271.271.271.646t-.271.646l-.771.771h2.396q.354 0 .614.26.261.261.261.615t-.261.615q-.26.26-.614.26H5.125l.792.792q.271.271.26.635-.01.365-.281.636-.271.27-.646.27t-.646-.27Z"/></svg>\n';

  // simulator/img/icons/direction.icon.svg
  var direction_icon_default = '<svg viewBox="0 0 20 20"><path d="M10.625 12.771 12.771 10.625Q13.042 10.354 13.042 10Q13.042 9.646 12.771 9.375L10.604 7.208Q10.354 6.958 10 6.958Q9.646 6.958 9.396 7.208Q9.125 7.479 9.125 7.833Q9.125 8.188 9.396 8.438L10.062 9.125H7.479Q7.125 9.125 6.875 9.385Q6.625 9.646 6.625 10Q6.625 10.354 6.885 10.615Q7.146 10.875 7.5 10.875H10.062L9.375 11.562Q9.125 11.812 9.125 12.167Q9.125 12.521 9.396 12.771Q9.646 13.042 10 13.042Q10.354 13.042 10.625 12.771ZM10 18.333Q8.271 18.333 6.75 17.677Q5.229 17.021 4.104 15.896Q2.979 14.771 2.323 13.25Q1.667 11.729 1.667 10Q1.667 8.271 2.323 6.75Q2.979 5.229 4.104 4.104Q5.229 2.979 6.75 2.323Q8.271 1.667 10 1.667Q11.729 1.667 13.25 2.323Q14.771 2.979 15.896 4.104Q17.021 5.229 17.677 6.75Q18.333 8.271 18.333 10Q18.333 11.729 17.677 13.25Q17.021 14.771 15.896 15.896Q14.771 17.021 13.25 17.677Q11.729 18.333 10 18.333Z"/></svg>';

  // simulator/img/icons/download.icon.svg
  var download_icon_default = '<svg viewBox="0 0 20 20"><path d="M10 12.917q-.167 0-.323-.063-.156-.062-.302-.208L6.333 9.604q-.271-.271-.271-.625t.271-.625q.271-.271.625-.271t.625.271l1.542 1.542V4.208q0-.354.26-.614.261-.261.615-.261t.615.261q.26.26.26.614v5.688l1.542-1.542q.271-.271.625-.271t.625.271q.271.271.271.625t-.271.625l-3.042 3.042q-.146.146-.302.208-.156.063-.323.063Zm-4.917 3.75q-.729 0-1.239-.511-.511-.51-.511-1.239v-1.542q0-.354.261-.615.26-.26.614-.26t.615.26q.26.261.26.615v1.542h9.834v-1.542q0-.354.26-.615.261-.26.615-.26t.614.26q.261.261.261.615v1.542q0 .729-.511 1.239-.51.511-1.239.511Z"/></svg>';

  // simulator/img/icons/edit.icon.svg
  var edit_icon_default = '<svg viewBox="0 0 20 20"><path d="m16.188 7.542-3.73-3.73 1.021-1.02q.521-.521 1.24-.521t1.239.521l1.25 1.25q.5.5.5 1.239 0 .74-.5 1.24ZM3.375 17.5q-.354 0-.615-.26-.26-.261-.26-.615v-2.5q0-.167.062-.323.063-.156.188-.281l8.479-8.479 3.729 3.729-8.479 8.479q-.125.125-.281.188-.156.062-.323.062Z"/></svg>';

  // simulator/img/icons/eye.icon.svg
  var eye_icon_default = '<svg viewBox="0 0 20 20"><path d="M10.021 13.375Q11.604 13.375 12.708 12.25Q13.812 11.125 13.812 9.542Q13.812 7.958 12.708 6.854Q11.604 5.75 10.021 5.75Q8.438 5.75 7.312 6.854Q6.188 7.958 6.188 9.542Q6.188 11.146 7.302 12.26Q8.417 13.375 10.021 13.375ZM10.021 11.812Q9.083 11.812 8.417 11.146Q7.75 10.479 7.75 9.542Q7.75 8.604 8.417 7.958Q9.083 7.312 10.021 7.312Q10.958 7.312 11.604 7.958Q12.25 8.604 12.25 9.542Q12.25 10.479 11.604 11.146Q10.958 11.812 10.021 11.812ZM10 15.833Q7.083 15.833 4.688 14.292Q2.292 12.75 1.083 10.146Q1.042 10.042 1.01 9.885Q0.979 9.729 0.979 9.562Q0.979 9.396 1.01 9.24Q1.042 9.083 1.083 8.979Q2.292 6.375 4.698 4.844Q7.104 3.312 10 3.312Q12.896 3.312 15.302 4.844Q17.708 6.375 18.917 8.979Q18.958 9.083 18.99 9.24Q19.021 9.396 19.021 9.562Q19.021 9.729 18.99 9.885Q18.958 10.042 18.917 10.146Q17.708 12.75 15.312 14.292Q12.917 15.833 10 15.833Z"/></svg>';

  // simulator/img/icons/font.icon.svg
  var font_icon_default = '<svg viewBox="0 0 20 20"><path d="M7.083 16.667q-.541 0-.916-.375t-.375-.917V5.917H2.958q-.541 0-.916-.375t-.375-.917q0-.542.375-.917t.916-.375h8.25q.542 0 .917.375t.375.917q0 .542-.375.917t-.917.375H8.375v9.458q0 .542-.375.917t-.917.375Zm7.5 0q-.541 0-.916-.375t-.375-.917v-5.292h-1.167q-.542 0-.917-.375t-.375-.916q0-.542.375-.917t.917-.375h4.917q.541 0 .916.375t.375.917q0 .541-.375.916t-.916.375h-1.167v5.292q0 .542-.375.917t-.917.375Z"/></svg>';

  // simulator/img/icons/force.icon.svg
  var force_icon_default = '<svg viewBox="0 0 20 20"><path d="M10 17.5Q9.292 17.5 8.792 17Q8.292 16.5 8.292 15.792Q8.292 15.083 8.792 14.583Q9.292 14.083 10 14.083Q10.708 14.083 11.208 14.583Q11.708 15.083 11.708 15.792Q11.708 16.5 11.208 17Q10.708 17.5 10 17.5ZM10 12.5Q9.292 12.5 8.792 12Q8.292 11.5 8.292 10.792V4.208Q8.292 3.5 8.792 3Q9.292 2.5 10 2.5Q10.708 2.5 11.208 3Q11.708 3.5 11.708 4.208V10.792Q11.708 11.5 11.208 12Q10.708 12.5 10 12.5Z"/></svg>';

  // simulator/img/icons/inputs.icon.svg
  var inputs_icon_default = '<svg viewBox="0 0 20 20"><path d="M3,7.6c0.3,0.3,0.6,0.5,0.9,0.6c0.4,0.2,0.7,0.2,1.1,0.2s0.8-0.1,1.1-0.2c0.4-0.2,0.7-0.4,0.9-0.6C7.4,7.3,7.6,7,7.8,6.7\n		c0,0,0-0.1,0-0.1h9.8v-2H7.8c0,0,0-0.1,0-0.1C7.6,4,7.4,3.7,7.1,3.5C6.9,3.2,6.6,3,6.2,2.8c-0.7-0.3-1.6-0.3-2.3,0\n		C3.6,3,3.3,3.2,3,3.5C2.8,3.7,2.5,4,2.4,4.4C2.2,4.7,2.2,5.1,2.2,5.5c0,0.4,0.1,0.8,0.2,1.1C2.5,7,2.8,7.3,3,7.6z M3.5,4.9\n		c0.1-0.2,0.2-0.4,0.4-0.5C4,4.2,4.2,4,4.4,3.9c0.2-0.1,0.4-0.1,0.7-0.1s0.5,0,0.7,0.1C6,4,6.1,4.2,6.3,4.3c0.2,0.2,0.3,0.3,0.4,0.5\n		c0.1,0.2,0.1,0.4,0.1,0.7c0,0.2,0,0.5-0.1,0.7C6.6,6.4,6.5,6.6,6.3,6.7C6.1,6.9,6,7,5.7,7.1c-0.4,0.2-0.9,0.2-1.3,0\n		C4.2,7,4,6.9,3.9,6.7C3.7,6.6,3.6,6.4,3.5,6.2C3.4,6,3.4,5.8,3.4,5.5C3.4,5.3,3.4,5.1,3.5,4.9z"/><path d="M17.6,13.5H7.8c0,0,0-0.1,0-0.1c-0.2-0.4-0.4-0.7-0.6-0.9s-0.6-0.5-0.9-0.6c-0.7-0.3-1.6-0.3-2.3,0\n		c-0.3,0.2-0.7,0.4-0.9,0.6c-0.3,0.3-0.5,0.6-0.6,0.9c-0.2,0.4-0.2,0.7-0.2,1.1c0,0.4,0.1,0.8,0.2,1.1C2.5,16,2.8,16.3,3,16.5\n		c0.3,0.3,0.6,0.5,0.9,0.6c0.4,0.2,0.7,0.2,1.1,0.2s0.8-0.1,1.1-0.2c0.3-0.2,0.7-0.4,0.9-0.6c0.3-0.3,0.5-0.6,0.6-0.9\n		c0,0,0-0.1,0-0.1h9.8V13.5z M6.7,15.1c-0.1,0.2-0.2,0.4-0.4,0.5C6.1,15.8,6,16,5.7,16c-0.4,0.2-0.9,0.2-1.3,0\n		C4.2,16,4,15.8,3.9,15.7c-0.2-0.2-0.3-0.3-0.4-0.5c-0.1-0.2-0.1-0.4-0.1-0.7c0-0.2,0-0.5,0.1-0.7c0.1-0.2,0.2-0.4,0.4-0.5\n		C4,13.1,4.2,13,4.4,12.9c0.2-0.1,0.4-0.1,0.7-0.1s0.5,0,0.7,0.1C6,13,6.1,13.1,6.3,13.2c0.2,0.2,0.3,0.3,0.4,0.5\n		c0.1,0.2,0.1,0.4,0.1,0.7C6.8,14.7,6.8,14.9,6.7,15.1z"/></svg>';

  // simulator/img/icons/link.icon.svg
  var link_icon_default = '<svg viewBox="0 0 20 20"><path d="M5.833 14.167q-1.729 0-2.948-1.219Q1.667 11.729 1.667 10q0-1.729 1.218-2.948 1.219-1.219 2.948-1.219H8.25q.354 0 .615.261.26.26.26.614t-.26.615q-.261.26-.615.26H5.833q-1.041 0-1.729.688-.687.687-.687 1.729t.687 1.729q.688.688 1.729.688H8.25q.354 0 .615.26.26.261.26.615t-.26.614q-.261.261-.615.261Zm1.709-3.292q-.354 0-.615-.26-.26-.261-.26-.615t.26-.615q.261-.26.615-.26h4.916q.354 0 .615.26.26.261.26.615t-.26.615q-.261.26-.615.26Zm4.208 3.292q-.354 0-.615-.261-.26-.26-.26-.614t.26-.615q.261-.26.615-.26h2.417q1.041 0 1.729-.688.687-.687.687-1.729t-.687-1.729q-.688-.688-1.729-.688H11.75q-.354 0-.615-.26-.26-.261-.26-.615t.26-.614q.261-.261.615-.261h2.417q1.729 0 2.948 1.219Q18.333 8.271 18.333 10q0 1.729-1.218 2.948-1.219 1.219-2.948 1.219Z"/></svg>';

  // simulator/img/icons/memcontent.icon.svg
  var memcontent_icon_default = '<svg viewBox="0 0 20 20"><path d="M2.1,8.2H0.6V6.8h0.1c0.5,0,0.9-0.1,1.1-0.4c0.3-0.3,0.5-0.7,0.5-1.3h1.1v10.4H2.1V8.2z"/><path d="M5.3,8.6c0-0.7,0.1-1.3,0.3-1.8c0.1-0.5,0.4-0.9,0.7-1.2c0.3-0.3,0.7-0.5,1.2-0.5c0.4,0,0.8,0.1,1.1,0.3\n		C8.8,5.6,9,5.9,9.2,6.3c0.2,0.4,0.3,0.9,0.4,1.6c0.1,0.6,0.1,1.4,0.1,2.3c0,0.7,0,1.4,0,2.1c0,0.7-0.1,1.3-0.3,1.8\n		c-0.1,0.5-0.4,0.9-0.7,1.2c-0.3,0.3-0.7,0.4-1.2,0.4c-0.4,0-0.8-0.1-1.1-0.2c-0.3-0.2-0.5-0.4-0.7-0.8c-0.2-0.4-0.3-0.9-0.4-1.6\n		c-0.1-0.6-0.1-1.4-0.1-2.3C5.2,10,5.2,9.3,5.3,8.6z M6.7,12.7c0,0.4,0.1,0.7,0.1,1C6.9,14,6.9,14.1,7,14.2c0.1,0.1,0.2,0.1,0.4,0.1\n		c0.2,0,0.3-0.1,0.4-0.2C7.9,14.1,8,13.9,8,13.6c0.1-0.3,0.1-0.6,0.1-1.1c0-0.4,0-1,0-1.7V9.7c0-0.7,0-1.2,0-1.6\n		c0-0.4-0.1-0.7-0.1-1C8,6.9,7.9,6.8,7.8,6.7C7.7,6.6,7.6,6.5,7.4,6.5C7.3,6.5,7.1,6.6,7,6.7C6.9,6.8,6.9,7,6.8,7.3\n		C6.7,7.5,6.7,7.9,6.7,8.3c0,0.4,0,1,0,1.7v1.1C6.6,11.8,6.7,12.3,6.7,12.7z"/><path d="M11.6,8.2h-1.4V6.8h0.1c0.5,0,0.9-0.1,1.1-0.4c0.3-0.3,0.5-0.7,0.5-1.3h1.1v10.4h-1.4V8.2z"/><path d="M14.8,8.6c0-0.7,0.1-1.3,0.3-1.8s0.4-0.9,0.7-1.2c0.3-0.3,0.7-0.5,1.2-0.5c0.4,0,0.8,0.1,1.1,0.3c0.3,0.2,0.5,0.5,0.7,0.9\n		c0.2,0.4,0.3,0.9,0.4,1.6c0.1,0.6,0.1,1.4,0.1,2.3c0,0.7,0,1.4,0,2.1c0,0.7-0.1,1.3-0.3,1.8c-0.1,0.5-0.4,0.9-0.7,1.2\n		c-0.3,0.3-0.7,0.4-1.2,0.4c-0.4,0-0.8-0.1-1.1-0.2c-0.3-0.2-0.5-0.4-0.7-0.8c-0.2-0.4-0.3-0.9-0.4-1.6c-0.1-0.6-0.1-1.4-0.1-2.3\n		C14.8,10,14.8,9.3,14.8,8.6z M16.3,12.7c0,0.4,0.1,0.7,0.1,1c0.1,0.2,0.1,0.4,0.2,0.5c0.1,0.1,0.2,0.1,0.4,0.1\n		c0.2,0,0.3-0.1,0.4-0.2c0.1-0.1,0.2-0.3,0.2-0.6c0.1-0.3,0.1-0.6,0.1-1.1c0-0.4,0-1,0-1.7V9.7c0-0.7,0-1.2,0-1.6\n		c0-0.4-0.1-0.7-0.1-1c-0.1-0.2-0.1-0.4-0.2-0.5c-0.1-0.1-0.2-0.1-0.4-0.1c-0.2,0-0.3,0.1-0.4,0.2c-0.1,0.1-0.2,0.3-0.2,0.6\n		c-0.1,0.3-0.1,0.6-0.1,1.1c0,0.4,0,1,0,1.7v1.1C16.2,11.8,16.2,12.3,16.3,12.7z"/></svg>';

  // simulator/img/icons/memlines.icon.svg
  var memlines_icon_default = '<svg viewBox="0 0 20 20"><path d="M6.4,6h11.8c0.2,0,0.4-0.1,0.5-0.3C18.9,5.5,19,5.3,19,5.1s-0.1-0.4-0.3-0.6c-0.2-0.2-0.4-0.3-0.5-0.3H6.4\n		C6.2,4.2,6,4.3,5.9,4.5C5.7,4.7,5.6,4.8,5.6,5.1s0.1,0.5,0.3,0.6C6,5.9,6.1,6,6.4,6z"/><path d="M18.2,7.7H6.4C6.2,7.7,6,7.8,5.9,8C5.7,8.2,5.6,8.3,5.6,8.6c0,0.3,0.1,0.5,0.3,0.6C6,9.4,6.1,9.5,6.4,9.5h11.8\n		c0.2,0,0.4-0.1,0.5-0.3S19,8.8,19,8.6c0-0.2-0.1-0.4-0.3-0.6S18.4,7.7,18.2,7.7z"/><path d="M18.2,11.2H6.4c-0.2,0-0.4,0.1-0.5,0.3c-0.2,0.2-0.3,0.3-0.3,0.6c0,0.3,0.1,0.5,0.3,0.6C6,12.9,6.1,13,6.4,13h11.8\n		c0.2,0,0.4-0.1,0.5-0.3s0.3-0.4,0.3-0.6c0-0.2-0.1-0.4-0.3-0.6S18.4,11.2,18.2,11.2z"/><path d="M18.2,14.7H6.4c-0.2,0-0.4,0.1-0.5,0.3c-0.2,0.2-0.3,0.3-0.3,0.6s0.1,0.5,0.3,0.6c0.1,0.2,0.3,0.3,0.5,0.3h11.8\n		c0.2,0,0.4-0.1,0.5-0.3c0.2-0.2,0.3-0.4,0.3-0.6s-0.1-0.4-0.3-0.6C18.6,14.8,18.4,14.7,18.2,14.7z"/><path d="M0.3,7.2L5.3,5L0.2,2.7C1.6,4.4,1.6,5.7,0.3,7.2z"/></svg>';

  // simulator/img/icons/mouse.icon.svg
  var mouse_icon_default = '<svg viewBox="0 0 20 20"><polygon points="5.1,14.7 5.1,1 15,11.1 10.5,11.1 13.3,17.6 11,18.6 8.1,11.8 " fill="currentColor"/></svg>';

  // simulator/img/icons/move.icon.svg
  var move_icon_default = '<svg viewBox="0 0 20 20"><path d="M10 8.396q-.354 0-.615-.261-.26-.26-.26-.614V5.125l-.792.792q-.271.271-.635.26-.365-.01-.636-.281-.27-.271-.27-.646t.27-.646l2.313-2.312q.146-.146.302-.209.156-.062.323-.062t.323.062q.156.063.302.209l2.333 2.333q.271.271.261.635-.011.365-.281.636-.271.271-.646.271t-.646-.271l-.771-.771v2.396q0 .354-.26.614-.261.261-.615.261Zm0 9.583q-.167 0-.323-.062-.156-.063-.302-.209l-2.333-2.333q-.271-.271-.261-.635.011-.365.281-.636.271-.271.646-.271t.646.271l.771.771v-2.396q0-.354.26-.614.261-.261.615-.261t.615.261q.26.26.26.614v2.396l.792-.792q.271-.271.635-.26.365.01.636.281.27.271.27.646t-.27.646l-2.313 2.312q-.146.146-.302.209-.156.062-.323.062Zm4.104-5.041q-.271-.271-.271-.646t.271-.646l.771-.771h-2.396q-.354 0-.614-.26-.261-.261-.261-.615t.261-.615q.26-.26.614-.26h2.396l-.792-.792q-.271-.271-.26-.635.01-.365.281-.636.271-.27.646-.27t.646.27l2.312 2.313q.146.146.209.302.062.156.062.323t-.062.323q-.063.156-.209.302l-2.333 2.333q-.271.271-.635.261-.365-.011-.636-.281Zm-9.5 0-2.312-2.313q-.146-.146-.209-.302-.062-.156-.062-.323t.062-.323q.063-.156.209-.302l2.333-2.333q.271-.271.635-.261.365.011.636.281.271.271.271.646t-.271.646l-.771.771h2.396q.354 0 .614.26.261.261.261.615t-.261.615q-.26.26-.614.26H5.125l.792.792q.271.271.26.635-.01.365-.281.636-.271.27-.646.27t-.646-.27Z"/></svg>';

  // simulator/img/icons/newcomponent.icon.svg
  var newcomponent_icon_default = '<svg viewBox="0 0 20 20"><path d="M3.2,1.8v16.5H17V1.8H3.2z M15.2,16.4H5V3.6h10.2V16.4z"/><polygon fill="currentColor" points="9.3,13 10.9,13 10.9,10.7 13.1,10.7 13.1,9.2 10.9,9.2 10.9,6.9 9.3,6.9 9.3,9.2 7.1,9.2 7.1,10.7 9.3,10.7"/></svg>';

  // simulator/img/icons/none.icon.svg
  var none_icon_default = '<svg viewBox="0 0 20 20"></svg>\n';

  // simulator/img/icons/open.icon.svg
  var open_icon_default = '<svg viewBox="0 0 20 20"><path d="m17.667 18.083-1.792-1.791v.916q0 .354-.26.615-.261.26-.615.26t-.615-.26q-.26-.261-.26-.615v-3.041q0-.355.26-.615.261-.26.615-.26h3.042q.354 0 .614.26.261.26.261.615 0 .354-.261.614-.26.261-.614.261h-.938l1.813 1.812q.25.25.25.604t-.25.625q-.25.271-.615.271-.364 0-.635-.271ZM11.708 7.5h3.209l-4.084-4.083v3.208q0 .354.261.615.26.26.614.26ZM5.083 18.333q-.687 0-1.218-.531-.532-.531-.532-1.219V3.417q0-.688.532-1.219.531-.531 1.218-.531h5.855q.354 0 .677.135.323.136.573.386l3.958 3.958q.25.25.385.573.136.323.136.677v4.146h-2.542q-.729 0-1.24.51-.51.51-.51 1.24v5.041Z"/></svg>';

  // simulator/img/icons/outputs.icon.svg
  var outputs_icon_default = '<svg viewBox="0 0 20 20"><path d="M12.6,6.6c0.2,0.4,0.4,0.7,0.7,1c0.2,0.2,0.6,0.4,0.9,0.6c0.3,0.1,0.7,0.2,1.1,0.2c0.4,0,0.8-0.1,1-0.3\n		c0.3-0.1,0.6-0.3,0.9-0.6c0.2-0.2,0.4-0.6,0.6-0.9C17.9,6.3,18,5.9,18,5.5s0-0.8-0.2-1.1c-0.1-0.3-0.4-0.7-0.6-0.9\n		s-0.6-0.4-0.9-0.6c-0.3-0.1-0.7-0.2-1.1-0.2c-0.4,0-0.8,0-1.1,0.2c-0.3,0.1-0.7,0.4-0.9,0.6s-0.4,0.6-0.6,0.9c0,0,0,0.1,0,0.1H2.8\n		v2L12.6,6.6C12.6,6.5,12.6,6.6,12.6,6.6z"/><path d="M17.9,13.4c-0.1-0.3-0.4-0.7-0.6-0.9s-0.6-0.4-0.9-0.6c-0.3-0.1-0.7-0.2-1.1-0.2c-0.4,0-0.8,0.1-1.1,0.2\n		c-0.3,0.1-0.7,0.4-0.9,0.6s-0.5,0.6-0.6,0.9c0,0,0,0.1,0,0.1H2.8v2h9.9c0,0,0,0.1,0,0.1c0.1,0.3,0.4,0.7,0.6,0.9s0.6,0.4,0.9,0.6\n		c0.3,0.1,0.7,0.2,1.1,0.2c0.4,0,0.8-0.1,1.1-0.2c0.3-0.1,0.7-0.4,0.9-0.6s0.4-0.6,0.6-0.9c0.1-0.3,0.2-0.7,0.2-1.1\n		S18.1,13.7,17.9,13.4z"/></svg>';

  // simulator/img/icons/palette.icon.svg
  var palette_icon_default = '<svg viewBox="0 0 20 20"><path d="M9.958 18.333Q8.25 18.333 6.74 17.677Q5.229 17.021 4.104 15.885Q2.979 14.75 2.323 13.229Q1.667 11.708 1.667 10Q1.667 8.271 2.333 6.75Q3 5.229 4.156 4.104Q5.312 2.979 6.854 2.323Q8.396 1.667 10.125 1.667Q11.771 1.667 13.26 2.25Q14.75 2.833 15.875 3.854Q17 4.875 17.667 6.26Q18.333 7.646 18.333 9.25Q18.333 11.688 16.792 12.948Q15.25 14.208 13.188 14.208H11.75Q11.625 14.208 11.562 14.281Q11.5 14.354 11.5 14.458Q11.5 14.688 11.812 15.219Q12.125 15.75 12.125 16.458Q12.125 17.458 11.51 17.896Q10.896 18.333 9.958 18.333ZM5.458 10.875Q6 10.875 6.375 10.5Q6.75 10.125 6.75 9.583Q6.75 9.042 6.375 8.667Q6 8.292 5.458 8.292Q4.917 8.292 4.542 8.667Q4.167 9.042 4.167 9.583Q4.167 10.125 4.542 10.5Q4.917 10.875 5.458 10.875ZM7.917 7.583Q8.458 7.583 8.833 7.208Q9.208 6.833 9.208 6.292Q9.208 5.75 8.833 5.375Q8.458 5 7.917 5Q7.375 5 7 5.375Q6.625 5.75 6.625 6.292Q6.625 6.833 7 7.208Q7.375 7.583 7.917 7.583ZM12.021 7.583Q12.562 7.583 12.938 7.208Q13.312 6.833 13.312 6.292Q13.312 5.75 12.938 5.375Q12.562 5 12.021 5Q11.479 5 11.104 5.375Q10.729 5.75 10.729 6.292Q10.729 6.833 11.104 7.208Q11.479 7.583 12.021 7.583ZM14.479 10.875Q15.021 10.875 15.396 10.5Q15.771 10.125 15.771 9.583Q15.771 9.042 15.396 8.667Q15.021 8.292 14.479 8.292Q13.938 8.292 13.562 8.667Q13.188 9.042 13.188 9.583Q13.188 10.125 13.562 10.5Q13.938 10.875 14.479 10.875Z"/></svg>';

  // simulator/img/icons/pause.icon.svg
  var pause_icon_default = '<svg viewBox="0 0 20 20"><path d="M12.5 15.833q-.729 0-1.24-.51-.51-.511-.51-1.24V5.917q0-.729.51-1.24.511-.51 1.24-.51h1.583q.729 0 1.24.51.51.511.51 1.24v8.166q0 .729-.51 1.24-.511.51-1.24.51Zm-6.583 0q-.729 0-1.24-.51-.51-.511-.51-1.24V5.917q0-.729.51-1.24.511-.51 1.24-.51H7.5q.729 0 1.24.51.51.511.51 1.24v8.166q0 .729-.51 1.24-.511.51-1.24.51Z"/></svg>';

  // simulator/img/icons/pen.icon.svg
  var pen_icon_default = '<svg viewBox="0 0 20 20"><path d="M16.188 7.542 12.458 3.812 13.479 2.792Q14 2.271 14.719 2.271Q15.438 2.271 15.958 2.792L17.208 4.042Q17.708 4.542 17.708 5.281Q17.708 6.021 17.208 6.521ZM3.375 17.5Q3.021 17.5 2.76 17.24Q2.5 16.979 2.5 16.625V14.125Q2.5 13.958 2.562 13.802Q2.625 13.646 2.75 13.521L11.229 5.042L14.958 8.771L6.479 17.25Q6.354 17.375 6.198 17.438Q6.042 17.5 5.875 17.5Z"/></svg>';

  // simulator/img/icons/placement.icon.svg
  var placement_icon_default = '<svg viewBox="0 0 20 20"><path d="M16.8,1.7H3.2c-0.8,0-1.5,0.7-1.5,1.5v13.6c0,0.8,0.7,1.5,1.5,1.5h13.6c0.8,0,1.5-0.7,1.5-1.5V3.2\n		C18.3,2.4,17.6,1.7,16.8,1.7z M17.3,11v4.5h-1.9v1.8H11v-1.8H9v1.8H4.6v-1.8H2.7V11h1.9V9.1H2.7V4.6h1.9V2.7H9v1.9H11V2.7h4.4v1.9\n		h1.9v4.5h-1.9V11H17.3z"/><rect x="9" y="9.1" width="1.9" height="1.9"/></svg>';

  // simulator/img/icons/play.icon.svg
  var play_icon_default = '<svg viewBox="0 0 20 20"><path d="M8.042 14.958q-.438.292-.896.042-.458-.25-.458-.792V5.75q0-.542.458-.792T8.042 5l6.646 4.25q.416.25.416.729t-.416.729Z"/></svg>';

  // simulator/img/icons/question.icon.svg
  var question_icon_default = '<svg viewBox="0 0 20 20"><path d="M10.021 13.333q-.521 0-.886-.323-.364-.322-.302-.906.105-1.021.459-1.656.354-.636 1.125-1.323.854-.75 1.239-1.26.386-.511.386-1.219 0-.854-.511-1.333-.51-.48-1.531-.48-.625 0-1.052.25-.427.25-.719.605-.354.458-.802.604-.448.146-.865-.021-.541-.229-.666-.771t.229-1.021q.604-.875 1.583-1.427Q8.688 2.5 10 2.5q2.188 0 3.365 1.219t1.177 2.927q0 1.042-.448 1.781-.448.74-1.406 1.677-.688.667-.98 1.073-.291.406-.375.927-.104.542-.458.886-.354.343-.854.343Zm-.021 5q-.708 0-1.208-.5t-.5-1.208q0-.708.5-1.208t1.208-.5q.708 0 1.208.5t.5 1.208q0 .708-.5 1.208t-1.208.5Z"/></svg>';

  // simulator/img/icons/questioncircled.icon.svg
  var questioncircled_icon_default = '<svg viewBox="0 0 20 20"><path d="M9.958 15.021Q10.417 15.021 10.729 14.708Q11.042 14.396 11.042 13.938Q11.042 13.479 10.729 13.167Q10.417 12.854 9.958 12.854Q9.5 12.854 9.188 13.167Q8.875 13.479 8.875 13.938Q8.875 14.396 9.188 14.708Q9.5 15.021 9.958 15.021ZM10.062 6.458Q10.646 6.458 11.01 6.771Q11.375 7.083 11.375 7.562Q11.375 7.896 11.146 8.271Q10.917 8.646 10.5 9Q9.833 9.583 9.531 10.073Q9.229 10.562 9.229 11.042Q9.229 11.354 9.438 11.562Q9.646 11.771 9.979 11.771Q10.292 11.771 10.531 11.562Q10.771 11.354 10.833 11Q10.896 10.667 11.115 10.365Q11.333 10.062 11.833 9.583Q12.5 8.958 12.74 8.469Q12.979 7.979 12.979 7.396Q12.979 6.312 12.188 5.646Q11.396 4.979 10.104 4.979Q9.229 4.979 8.573 5.323Q7.917 5.667 7.438 6.354Q7.271 6.583 7.344 6.854Q7.417 7.125 7.646 7.312Q7.917 7.521 8.26 7.448Q8.604 7.375 8.833 7.062Q9.062 6.771 9.365 6.615Q9.667 6.458 10.062 6.458ZM10 18.333Q8.292 18.333 6.771 17.677Q5.25 17.021 4.115 15.896Q2.979 14.771 2.323 13.25Q1.667 11.729 1.667 10Q1.667 8.271 2.323 6.75Q2.979 5.229 4.115 4.104Q5.25 2.979 6.771 2.323Q8.292 1.667 10 1.667Q11.75 1.667 13.271 2.323Q14.792 2.979 15.917 4.104Q17.042 5.229 17.688 6.75Q18.333 8.271 18.333 10Q18.333 11.729 17.688 13.25Q17.042 14.771 15.917 15.896Q14.792 17.021 13.271 17.677Q11.75 18.333 10 18.333Z"/></svg>';

  // simulator/img/icons/redo.icon.svg
  var redo_icon_default = '<svg viewBox="0 96 960 960"><path d="M398 856q-97 0-167.5-63T160 636q0-94 70.5-156.5T398 417h242l-73-73q-12-12-11.5-29t12.5-29q12-12 29.5-12t29.5 12l143 143q7 7 10 14.5t3 15.5q0 8-3 15.5T770 489L626 633q-12 12-29 11.5T568 632q-12-12-12-29.5t12-29.5l72-72H398q-62 0-108 38t-46 97q0 60 46 98t108 38h239q17 0 29.5 12.5T679 814q0 17-12.5 29.5T637 856H398Z"/></svg>';

  // simulator/img/icons/ref.icon.svg
  var ref_icon_default = '<svg viewBox="0 0 20 20"><path d="M10 19.125Q9.646 19.125 9.385 18.865Q9.125 18.604 9.125 18.25V17.438Q6.583 17.146 4.719 15.281Q2.854 13.417 2.562 10.875H1.75Q1.396 10.875 1.135 10.615Q0.875 10.354 0.875 10Q0.875 9.646 1.135 9.385Q1.396 9.125 1.75 9.125H2.562Q2.854 6.583 4.719 4.719Q6.583 2.854 9.125 2.562V1.75Q9.125 1.396 9.385 1.135Q9.646 0.875 10 0.875Q10.354 0.875 10.615 1.135Q10.875 1.396 10.875 1.75V2.562Q13.417 2.854 15.281 4.719Q17.146 6.583 17.438 9.125H18.25Q18.604 9.125 18.865 9.385Q19.125 9.646 19.125 10Q19.125 10.354 18.865 10.615Q18.604 10.875 18.25 10.875H17.438Q17.146 13.417 15.281 15.281Q13.417 17.146 10.875 17.438V18.25Q10.875 18.604 10.615 18.865Q10.354 19.125 10 19.125ZM10 15.729Q12.396 15.729 14.062 14.062Q15.729 12.396 15.729 10Q15.729 7.604 14.062 5.938Q12.396 4.271 10 4.271Q7.604 4.271 5.938 5.938Q4.271 7.604 4.271 10Q4.271 12.396 5.938 14.062Q7.604 15.729 10 15.729Z"/></svg>';

  // simulator/img/icons/replace.icon.svg
  var replace_icon_default = '<svg viewBox="0 0 20 20"><path d="M13.188 11.104 15.354 8.938Q15.625 8.667 15.625 8.312Q15.625 7.958 15.354 7.688L13.208 5.542Q12.958 5.292 12.604 5.292Q12.25 5.292 11.979 5.562Q11.708 5.833 11.708 6.188Q11.708 6.542 11.979 6.812L12.625 7.479H10.042Q9.688 7.479 9.438 7.729Q9.188 7.979 9.188 8.354Q9.188 8.708 9.448 8.969Q9.708 9.229 10.062 9.229H12.583L11.938 9.875Q11.688 10.125 11.688 10.479Q11.688 10.833 11.958 11.104Q12.208 11.354 12.562 11.365Q12.917 11.375 13.188 11.104ZM6.792 14.438Q7.062 14.708 7.417 14.708Q7.771 14.708 8.062 14.417Q8.312 14.167 8.312 13.802Q8.312 13.438 8.042 13.167L7.396 12.521H9.979Q10.333 12.521 10.583 12.271Q10.833 12.021 10.833 11.646Q10.833 11.292 10.573 11.031Q10.312 10.771 9.958 10.771H7.438L8.104 10.104Q8.354 9.854 8.354 9.5Q8.354 9.146 8.083 8.896Q7.833 8.625 7.469 8.625Q7.104 8.625 6.833 8.896L4.667 11.062Q4.396 11.333 4.396 11.688Q4.396 12.042 4.667 12.312ZM10 18.333Q8.271 18.333 6.75 17.677Q5.229 17.021 4.104 15.896Q2.979 14.771 2.323 13.25Q1.667 11.729 1.667 10Q1.667 8.271 2.323 6.75Q2.979 5.229 4.104 4.104Q5.229 2.979 6.75 2.323Q8.271 1.667 10 1.667Q11.729 1.667 13.25 2.323Q14.771 2.979 15.896 4.104Q17.021 5.229 17.677 6.75Q18.333 8.271 18.333 10Q18.333 11.729 17.677 13.25Q17.021 14.771 15.896 15.896Q14.771 17.021 13.25 17.677Q11.729 18.333 10 18.333Z"/></svg>';

  // simulator/img/icons/reset.icon.svg
  var reset_icon_default = '<svg viewBox="0 0 20 20"><path d="M14.8,6.1c-1.3-1.3-2.8-1.9-4.7-1.9h0l0.2-0.2c0.2-0.2,0.2-0.4,0.2-0.6c0-0.2-0.1-0.4-0.2-0.6c-0.2-0.2-0.4-0.2-0.6-0.2\n				S9.2,2.5,9,2.7L7.3,4.4C7.2,4.5,7.1,4.6,7.1,4.7C7.1,4.8,7,4.9,7,5c0,0.1,0,0.2,0.1,0.3c0,0.1,0.1,0.2,0.2,0.3L9,7.4\n				c0.2,0.2,0.4,0.3,0.6,0.3s0.4-0.1,0.6-0.3c0.2-0.2,0.2-0.4,0.2-0.6s-0.1-0.4-0.2-0.6L10,5.9h0c1.4,0,2.5,0.5,3.5,1.4\n				s1.4,2.1,1.4,3.5c0,1.1-0.3,2.1-0.9,2.9c-0.3,0.4-0.6,0.7-1,1c-0.4,0.3-0.9,0.5-1.4,0.8c-1,0.3-1.9,0.4-2.9,0.1\n				c-0.5-0.2-1-0.4-1.4-0.7c-0.1-0.1-0.2-0.1-0.3-0.2c-0.3-0.3-0.7-0.6-0.9-1c-0.6-0.9-0.9-1.8-0.9-2.9c0-0.5,0.1-1,0.2-1.5\n				C5.5,8.8,5.7,8.4,6,7.9c0.1-0.2,0.2-0.4,0.2-0.6S6.1,6.9,6,6.8C5.8,6.6,5.5,6.5,5.3,6.5C5,6.5,4.8,6.6,4.7,6.8\n				C4.2,7.4,3.9,8,3.7,8.7c-0.2,0.7-0.3,1.4-0.3,2.1c0,1.5,0.4,2.9,1.3,4c0.8,1.1,1.9,1.9,3.2,2.3c0.1,0,0.2,0.1,0.2,0.1\n				c1.5,0.4,2.9,0.4,4.3-0.1c0.4-0.2,0.7-0.4,1-0.6c0.7-0.4,1.3-1,1.9-1.7c0.9-1.2,1.3-2.5,1.3-4C16.7,9,16,7.4,14.8,6.1z"/></svg>';

  // simulator/img/icons/screenshot.icon.svg
  var screenshot_icon_default = '<svg viewBox="0 0 20 20"><path d="M10 14.583q1.604 0 2.698-1.093 1.094-1.094 1.094-2.678 0-1.583-1.094-2.677Q11.604 7.042 10 7.042q-1.583 0-2.667 1.093Q6.25 9.229 6.25 10.812q0 1.584 1.083 2.678Q8.417 14.583 10 14.583ZM3.417 17.5q-.729 0-1.24-.51-.51-.511-.51-1.24V5.896q0-.729.51-1.24.511-.51 1.24-.51h2.541l1-1.084q.25-.27.584-.416.333-.146.708-.146h3.521q.354 0 .687.146.334.146.584.416l1.02 1.084h2.521q.729 0 1.24.51.51.511.51 1.24v9.854q0 .729-.51 1.24-.511.51-1.24.51Z"/></svg>';

  // simulator/img/icons/setinput.icon.svg
  var setinput_icon_default = '<svg viewBox="0 0 20 20"><path class="st0" d="M6.4,6.3"/><path d="M2.5,6.2l4.8,4.3,1.2-6.8-2.1.9C4.7,1.7,1.3,0,.2-.5L-.3.4l-.4.9c1.9.9,4,2.3,5.3,4.1l-2,.8Z"/><path d="M6.1,16.2c.3.3.6.5.9.6.4.2.7.2,1.1.2s.8-.1,1.1-.2c.4-.2.7-.4.9-.6.4-.3.6-.6.8-.9h0c0,0,9.8,0,9.8,0v-2h-9.8c-.2-.6-.4-.9-.7-1.1-.2-.3-.5-.5-.9-.7-.7-.3-1.6-.3-2.3,0-.3.2-.6.4-.9.7s-.5.5-.6.9c-.2.3-.2.7-.2,1.1s0,.8.2,1.1c0,.4.4.7.6,1ZM6.6,13.5c0-.2.2-.4.4-.5,0-.2.3-.4.5-.5.2,0,.4,0,.7,0s.5,0,.7,0c.2,0,.3.3.5.4.2.2.3.3.4.5s0,.4,0,.7,0,.5,0,.7c-.1.2-.2.4-.4.5-.2.2-.3.3-.6.4-.4.2-.9.2-1.3,0-.2,0-.4-.2-.5-.4-.2,0-.3-.3-.4-.5,0-.2,0-.4,0-.7s0-.4,0-.6Z"/></svg>';

  // simulator/img/icons/settings.icon.svg
  var settings_icon_default = '<svg viewBox="0 0 20 20"><path d="M11.583 18.333H8.417q-.334 0-.573-.218-.24-.219-.282-.553l-.229-1.854q-.208-.125-.458-.27-.25-.146-.458-.271l-1.729.729q-.313.125-.626.021-.312-.105-.479-.396l-1.562-2.729q-.167-.292-.094-.604.073-.313.323-.521l1.458-1.125V9.458L2.25 8.333q-.25-.208-.323-.521-.073-.312.094-.604l1.562-2.729q.167-.291.479-.396.313-.104.626.021l1.729.729q.208-.125.458-.27.25-.146.458-.271l.229-1.854q.042-.334.282-.553.239-.218.573-.218h3.166q.334 0 .573.218.24.219.282.553l.229 1.854q.208.125.458.271.25.145.458.27l1.729-.729q.313-.125.626-.021.312.105.479.396L18 7.208q.167.292.104.604-.062.313-.333.521l-1.459 1.125v1.084l1.459 1.125q.271.208.333.521.063.312-.104.604l-1.583 2.729q-.167.291-.479.396-.313.104-.626-.021l-1.729-.729q-.208.125-.458.271-.25.145-.458.27l-.229 1.854q-.042.334-.282.553-.239.218-.573.218ZM10 12.979q1.229 0 2.104-.875T12.979 10q0-1.229-.875-2.104T10 7.021q-1.229 0-2.104.875T7.021 10q0 1.229.875 2.104t2.104.875Z"/></svg>';

  // simulator/img/icons/slanted.icon.svg
  var slanted_icon_default = '<svg viewBox="0 0 20 20"><path style="stroke:#000000;stroke-width:2;stroke-miterlimit:10;" d="M6.4,6.3"/><g><path d="M18.9,3.4c-0.4-0.4-1-0.4-1.4,0L4.2,16.8c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3L18.9,4.8\n		C19.3,4.5,19.3,3.8,18.9,3.4z"/><path d="M6.1,6.5l6.2,1.9l-1.8-6.7L9,3.4c-2.8-1.9-6.6-2-7.9-2v1v1c2.1,0,4.6,0.4,6.5,1.5L6.1,6.5z"/></g></svg>';

  // simulator/img/icons/step.icon.svg
  var step_icon_default = '<svg viewBox="0 0 20 20"><path d="M14.542 15q-.354 0-.615-.26-.26-.261-.26-.615V5.896q0-.354.26-.615.261-.26.615-.26t.614.26q.261.261.261.615v8.229q0 .354-.261.615-.26.26-.614.26Zm-8.604-.896q-.438.292-.896.042-.459-.25-.459-.771V6.646q0-.521.459-.771.458-.25.896.042l5.083 3.354q.396.271.396.729 0 .458-.396.729Z"/></svg>';

  // simulator/img/icons/strokewidth.icon.svg
  var strokewidth_icon_default = '<svg viewBox="0 0 20 20"><path d="M4.4,14.5c-0.5,0-1-0.2-1.4-0.6c-0.4-0.4-0.6-0.8-0.6-1.4c0-0.5,0.2-1,0.6-1.4c0.4-0.4,0.8-0.6,1.4-0.6h11.1\n	c0.5,0,1,0.2,1.4,0.6c0.4,0.4,0.6,0.8,0.6,1.4c0,0.5-0.2,1-0.6,1.4c-0.4,0.4-0.8,0.6-1.4,0.6H4.4z"/><path d="M3.4,8.1C3.1,8.1,2.9,8,2.8,7.8C2.6,7.7,2.5,7.5,2.5,7.2s0.1-0.4,0.3-0.6c0.2-0.2,0.4-0.3,0.6-0.3h13.2\n	c0.2,0,0.4,0.1,0.6,0.3c0.2,0.2,0.3,0.4,0.3,0.6s-0.1,0.4-0.3,0.6c-0.2,0.2-0.4,0.3-0.6,0.3H3.4z"/></svg>\n';

  // simulator/img/icons/testcase.icon.svg
  var testcase_icon_default = '<svg viewBox="0 0 20 20"><path d="M15,18H2V5c0-.3,0-.4-.3-.7s-.4-.3-.7-.3-.4,0-.7.3-.3.4-.3.7v13c0,.5.2,1,.6,1.4.4.4.8.6,1.4.6h13c.3,0,.4,0,.7-.3s.3-.4.3-.7,0-.4-.3-.7-.4-.3-.7-.3Z"/>\n  <path d="M19.4.6C19,.2,18.6,0,18,0H6C5.5,0,5,.2,4.6.6s-.6.8-.6,1.4v12c0,.5.2,1,.6,1.4s.8.6,1.4.6h12c.5,0,1-.2,1.4-.6s.6-.8.6-1.4V2c0-.5-.2-1-.6-1.4ZM10.1,13.8l-3.9-6.4,1.7-1.1,2.4,3.9L16.5,1.7l1.6,1.1s-8,11-8,11Z"/></svg>';

  // simulator/img/icons/timer.icon.svg
  var timer_icon_default = '<svg viewBox="0 0 20 20"><path d="M8.375 2.583Q8.021 2.583 7.76 2.323Q7.5 2.062 7.5 1.708Q7.5 1.354 7.76 1.094Q8.021 0.833 8.375 0.833H11.625Q11.979 0.833 12.24 1.094Q12.5 1.354 12.5 1.708Q12.5 2.062 12.24 2.323Q11.979 2.583 11.625 2.583ZM10 11.583Q10.354 11.583 10.615 11.323Q10.875 11.062 10.875 10.708V7.562Q10.875 7.208 10.615 6.948Q10.354 6.688 10 6.688Q9.646 6.688 9.385 6.948Q9.125 7.208 9.125 7.562V10.708Q9.125 11.062 9.385 11.323Q9.646 11.583 10 11.583ZM10 18.333Q8.458 18.333 7.094 17.74Q5.729 17.146 4.708 16.125Q3.688 15.104 3.094 13.74Q2.5 12.375 2.5 10.833Q2.5 9.292 3.094 7.927Q3.688 6.562 4.708 5.542Q5.729 4.521 7.094 3.927Q8.458 3.333 10 3.333Q11.271 3.333 12.458 3.75Q13.646 4.167 14.667 4.958L15.25 4.375Q15.5 4.125 15.854 4.125Q16.208 4.125 16.479 4.375Q16.729 4.646 16.729 5Q16.729 5.354 16.479 5.604L15.875 6.208Q16.667 7.271 17.083 8.417Q17.5 9.562 17.5 10.833Q17.5 12.375 16.906 13.74Q16.312 15.104 15.292 16.125Q14.271 17.146 12.906 17.74Q11.542 18.333 10 18.333Z"/></svg>';

  // simulator/img/icons/trash.icon.svg
  var trash_icon_default = '<svg viewBox="0 0 20 20"><path d="M5.896 17.5q-.729 0-1.24-.51-.51-.511-.51-1.24V5.125q-.354 0-.615-.26-.26-.261-.26-.615t.26-.615q.261-.26.615-.26h3.375q0-.354.26-.615.261-.26.615-.26h3.187q.355 0 .615.26.26.261.26.615h3.375q.355 0 .615.26.26.261.26.615t-.26.615q-.26.26-.615.26V15.75q0 .729-.51 1.24-.511.51-1.24.51Zm1.542-4.375q0 .354.26.615.26.26.614.26.355 0 .615-.26.261-.261.261-.615V7.75q0-.354-.261-.615-.26-.26-.615-.26-.354 0-.614.26-.26.261-.26.615Zm3.333 0q0 .354.26.615.261.26.615.26t.614-.26q.261-.261.261-.615V7.75q0-.354-.261-.615-.26-.26-.614-.26t-.615.26q-.26.261-.26.615Z"/></svg>';

  // simulator/img/icons/undo.icon.svg
  var undo_icon_default = '<svg viewBox="0 96 960 960"><path d="M323 856q-17 0-29.5-12.5T281 814q0-17 12.5-29.5T323 772h239q62 0 108-38t46-97q0-59-46-97.5T562 501H320l73 73q12 12 11.5 29T392 632q-12 12-29.5 12T333 632L190 489q-7-7-10-14.5t-3-15.5q0-8 3-15.5t10-14.5l144-144q12-12 29.5-12t29.5 12q12 12 12 29.5T393 344l-73 73h242q97 0 167.5 62.5T800 636q0 94-70.5 157T562 856H323Z"/></svg>';

  // simulator/img/icons/wirestyle.icon.svg
  var wirestyle_icon_default = '<svg viewBox="0 0 20 20"><path d="M5,8.1C4.8,8.1,4.6,8,4.4,7.9C4.3,7.7,4.2,7.5,4.2,7.2s0.1-0.4,0.3-0.6C4.6,6.5,4.8,6.4,5,6.4H15c0.2,0,0.4,0.1,0.6,0.3c0.2,0.2,0.3,0.4,0.3,0.6s-0.1,0.4-0.3,0.6C15.4,8,15.2,8.1,15,8.1H5z" /><path d="M5.1,14.2c-0.3,0-0.5-0.1-0.7-0.3c-0.3-0.4-0.3-1,0.1-1.3c2.3-1.9,3.7-2.1,5.9-1c1.8,0.9,2.7,0.7,3.8-0.7c0.3-0.4,0.9-0.4,1.3-0.1c0.4,0.3,0.4,0.9,0.1,1.3c-1.7,2.1-3.4,2.4-6,1.2c-1.4-0.7-2-0.8-4,0.8C5.5,14.2,5.3,14.2,5.1,14.2z" /></svg>\n';

  // simulator/img/ALU.svg
  var ALU_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n<path d="M78.5,40v-2H66.9V20.1L30.4,0.5V9h-9.5v2h9.5v5h-9.5v2h9.5v5h-9.5v2h9.5v5h-9.5v2h9.5v8.7L41.5,50l-11.2,9.3V68h-9.5v2h9.5\n	v5h-9.5v2h9.5v5h-9.5v2h9.5v5h-9.5v2h9.5v8.5l36.5-20.2V61h11.6v-2H66.9v-5h11.6v-2H66.9v-5h11.6v-2H66.9v-5H78.5z M63.9,77.6\n	L33.4,94.5V60.7L46.2,50L33.4,39.3V5.5l30.5,16.4V77.6z"/>\n</svg>\n';

  // simulator/img/Adder.svg
  var Adder_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n	<polygon points="45,67.9 52,67.9 52,52.4 67.3,52.4 67.3,45.4 52,45.4 52,30.4 45,30.4 45,45.4 29.8,45.4 29.8,52.4 45,52.4" />\n	<path d="M103.5,48.7H90V20H71.5V5.5h-2V20H30.2V5.5h-2V20H10v28.7H-3.5v2H10V80h37.9v15.5h2V80H90V50.7h13.5V48.7z M87,77H13V23h74\n		V77z" />\n</svg>';

  // simulator/img/AdderArray.svg
  var AdderArray_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n	<path d="M88.4,34.2v-2H73.2V1.1H28.4V5H13.2v2h15.2v8.1H13.2v2h15.2v9.2H13.2v2h15.2v9.1H13.2v2h15.2v19.8H13.2v2h15.2v8.1H13.2v2\n		h15.2v9.1H13.2v2h15.2v9.2H13.2v2h15.2v4h44.8v-31h15.2v-2H73.2v-9.2h15.2v-2H73.2v-9.2h15.2v-2H73.2v-8H88.4z M70.2,94.6H31.4V4.1\n		h38.8V94.6z" />\n	<polygon points="47.6,64 53.6,64 53.6,53.3 65.1,53.3 65.1,47.3 53.6,47.3 53.6,36.5 47.6,36.5 47.6,47.3 37.5,47.3 37.5,53.3 \n		47.6,53.3 	" />\n</svg>';

  // simulator/img/Clock.svg
  var Clock_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 50 25" style="enable-background:new 0 0 50 25;" fill="currentColor">\n<path d="M30.3,16.8c-0.6,0.6-1.5,0.9-2.5,0.9c-1.2,0-2.2-0.4-2.9-1.2c-0.7-0.8-1.1-1.9-1.1-3.3c0-1.5,0.4-2.7,1.2-3.5\n	c0.7-0.7,1.6-1.1,2.7-1.1c1.4,0,2.5,0.5,3.2,1.4c0.4,0.5,0.6,1.1,0.6,1.6h-1.8c-0.1-0.4-0.3-0.7-0.4-0.9c-0.3-0.4-0.8-0.6-1.4-0.6\n	c-0.7,0-1.2,0.3-1.5,0.8c-0.4,0.5-0.6,1.3-0.6,2.2s0.2,1.7,0.6,2.2s0.9,0.7,1.5,0.7s1.1-0.2,1.4-0.6c0.2-0.2,0.3-0.6,0.5-1h1.8\n	C31.3,15.4,30.9,16.2,30.3,16.8z"/>\n<path d="M32.8,8.8h1.8v7h4.2v1.5h-6V8.8z"/>\n<path d="M47.7,17.4h-2.3l-2.6-3.7l-0.9,0.9v2.9h-1.8V8.8h1.8v3.5l3.3-3.5h2.3L44,12.4L47.7,17.4z"/>\n<polygon points="0,22.2 0,20.2 19.1,20.2 19.1,2.8 50,2.8 50,4.8 21.1,4.8 21.1,22.2 "/>\n</svg>\n';

  // simulator/img/Comparator.svg
  var Comparator_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n	<path d="M39.3,55.3c-1.1,1.2-2.5,1.8-4.2,1.8c-2.1,0-3.8-0.8-5-2.4c-1.2-1.6-1.8-3.8-1.8-6.5c0-3,0.7-5.3,2.1-6.9\n		c1.2-1.4,2.7-2.1,4.6-2.1c2.5,0,4.3,0.9,5.4,2.8c0.6,1.1,1,2.1,1,3.2h-3.1c-0.2-0.8-0.5-1.4-0.8-1.9c-0.6-0.7-1.4-1.1-2.5-1.1\n		c-1.1,0-2,0.5-2.7,1.6c-0.6,1-1,2.5-1,4.5s0.3,3.4,1,4.3c0.7,1,1.6,1.4,2.6,1.4c1.1,0,1.9-0.4,2.5-1.2c0.3-0.4,0.6-1.1,0.8-2h3.1\n		C41.1,52.6,40.4,54.1,39.3,55.3z" />\n	<path d="M46.5,56.6h-2.9V39.5h4.5l2.7,13.5l2.7-13.5h4.4v17.1H55V45c0-0.3,0-0.8,0-1.4c0-0.6,0-1.1,0-1.4l-2.8,14.4h-3l-2.8-14.4\n		c0,0.3,0,0.8,0,1.4c0,0.6,0,1.1,0,1.4V56.6z" />\n	<path d="M67,50.4h-3.1v6.2h-3.1V39.5h6.4c1.5,0,2.7,0.4,3.5,1.3c0.9,0.9,1.3,2.3,1.3,4.1c0,2-0.4,3.4-1.3,4.3\n		C69.9,50,68.6,50.4,67,50.4z M68.4,46.9c0.4-0.4,0.6-1.1,0.6-2c0-0.9-0.2-1.5-0.6-1.9c-0.4-0.4-1-0.6-1.7-0.6h-2.9v5h2.9\n		C67.5,47.5,68,47.3,68.4,46.9z" />\n	<path d="M95.5,50.1H80V10H50.7V-3.5h-2V10H20v18.5H5.5v2H20v39.3H5.5v2H20V90h28.7v13.5h2V90H80V52.1h15.5V50.1z M77,87H23V13h54V87\n	z" />\n</svg>';

  // simulator/img/ControlledInverter.svg
  var ControlledInverter_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n<path d="M88.4,26.1v-2H73.2V11.9H51.8V4.6h-2v7.3H28.4v12.2H13.2v2h15.2v14.2H13.2v2h15.2v14.2H13.2v2h15.2v14.2H13.2v2h15.2v12.1\n	h44.8V74.7h15.2v-2H73.2V58.5h15.2v-2H73.2V42.3h15.2v-2H73.2V26.1H88.4z M70.2,83.8H31.4V14.9h18.4v28.5l-13-6.9v27.7l23.4-13.4\n	c0.4,1.5,1.7,2.6,3.3,2.6c1.8,0,3.4-1.6,3.4-3.4c0-1.8-1.4-3.3-3.4-3.4c-1.5,0-2.8,1-3.2,2.4l-8.5-4.5V14.9h18.4V83.8z M57.7,49.9\n	L38.8,60.8V39.9L57.7,49.9z M62.1,50c0-0.7,0.7-1.4,1.3-1.4c0.9,0.1,1.5,0.6,1.5,1.4c0,0.7-0.7,1.4-1.4,1.4S62.1,50.7,62.1,50z"/>\n</svg>\n';

  // simulator/img/Counter.svg
  var Counter_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n	<path d="M68.7,73.8h-34v-50h34V73.8z M36.1,72.3h31v-47h-31V72.3z" />\n	<path d="M95.5,26.6v-2h-15v-20h-60V85h-15v2h15v8.6h60V75.5h15v-2h-15V59.2h15v-2h-15v-15h15v-2h-15V26.6H95.5z M23.5,83l7.1,3.1\n	l-7.1,3.1V83z M77.5,92.6h-54v-1.2l12.1-5.3l-12.1-5.3V7.6h54V92.6z" />\n	<defs>\n		<rect id="SVGID_1_" x="35.4" y="24.6" width="32.5" height="48.5" />\n	</defs>\n	<clipPath id="frame">\n		<use xlink:href="#SVGID_1_" style="overflow:visible;" />\n	</clipPath>\n	<g style="clip-path:url(#frame);">\n		<path d="M45,22.6c0-2.5,0.3-4.4,0.8-5.9c0.5-1.5,1.3-2.7,2.3-3.5c1-0.8,2.2-1.2,3.8-1.2c1.1,0,2.1,0.2,2.9,0.7\n				c0.8,0.4,1.5,1.1,2.1,1.9c0.5,0.8,1,1.9,1.3,3.1s0.5,2.8,0.5,4.9c0,2.4-0.2,4.4-0.8,5.9c-0.5,1.5-1.2,2.7-2.2,3.5\n				s-2.3,1.2-3.8,1.2c-2,0-3.6-0.7-4.7-2.2C45.6,29.3,45,26.5,45,22.6z M47.6,22.6c0,3.4,0.4,5.7,1.2,6.8c0.8,1.1,1.8,1.7,3,1.7\n				c1.2,0,2.2-0.6,3-1.7s1.2-3.4,1.2-6.8c0-3.4-0.4-5.7-1.2-6.8s-1.8-1.7-3-1.7c-1.2,0-2.1,0.5-2.8,1.5C48,16.9,47.6,19.2,47.6,22.6\n				z" />\n		<path d="M54.6,56.9H52V40.6c-0.6,0.6-1.4,1.2-2.4,1.8c-1,0.6-1.9,1-2.7,1.3v-2.5c1.4-0.7,2.7-1.5,3.7-2.4s1.8-1.9,2.3-2.8h1.6\n				V56.9z" />\n		<path d="M58.4,78.4v2.4H44.6c0-0.6,0.1-1.2,0.3-1.8c0.3-0.9,0.9-1.9,1.7-2.8c0.8-0.9,1.9-2,3.3-3.1c2.3-1.9,3.8-3.3,4.6-4.4\n				s1.2-2.1,1.2-3.1c0-1-0.4-1.9-1.1-2.6c-0.7-0.7-1.7-1-2.8-1c-1.2,0-2.2,0.4-2.9,1.1s-1.1,1.8-1.1,3.1L45.1,66\n				c0.2-2,0.9-3.4,2-4.5s2.7-1.5,4.7-1.5c2,0,3.6,0.6,4.7,1.7c1.2,1.1,1.7,2.5,1.7,4.1c0,0.8-0.2,1.6-0.5,2.4s-0.9,1.6-1.7,2.5\n				c-0.8,0.9-2.1,2.1-3.9,3.7c-1.5,1.3-2.5,2.2-2.9,2.6s-0.8,0.9-1.1,1.4H58.4z" />\n	</g>\n</svg>';

  // simulator/img/Decoder.svg
  var Decoder_default = '<!-- Generator: Adobe Illustrator 26.5.3, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n<path d="M71.1,90.1H26.8V10h44.3V90.1z M29.8,87.1h38.3V13H29.8V87.1z"/>\n<rect x="12.8" y="37" width="16.3" height="2"/>\n<rect x="12.8" y="56.4" width="16.3" height="2"/>\n<rect x="70.8" y="41" width="16.3" height="2"/>\n<rect x="70.8" y="54.7" width="16.3" height="2"/>\n<rect x="70.8" y="68.3" width="16.3" height="2"/>\n<rect x="70.8" y="27.6" width="16.3" height="2"/>\n<g>\n	<path d="M38.7,55.5h-5.6V40.2h5.6c0.8,0,1.5,0.1,2,0.3c0.9,0.4,1.6,1,2.2,1.9c0.5,0.8,0.8,1.6,0.9,2.5s0.2,1.7,0.2,2.5\n		c0,2-0.3,3.8-1,5.2C42.1,54.5,40.7,55.5,38.7,55.5z M40.7,44.1c-0.4-0.8-1.2-1.2-2.5-1.2h-2.5v10h2.5c1.3,0,2.2-0.7,2.7-2.2\n		c0.3-0.8,0.4-1.8,0.4-2.9C41.3,46.1,41.1,44.9,40.7,44.1z"/>\n	<path d="M54.1,52.2c-0.1,0.7-0.4,1.4-0.9,2c-0.8,1.1-2,1.7-3.4,1.7c-1.2,0-2.3-0.5-3.2-1.4c-0.9-0.9-1.4-2.4-1.4-4.5\n		c0-2,0.4-3.5,1.3-4.5s1.9-1.6,3.3-1.6c0.8,0,1.5,0.2,2.2,0.5c0.6,0.4,1.2,0.9,1.6,1.7c0.4,0.7,0.6,1.5,0.7,2.3\n		c0.1,0.5,0.1,1.3,0.1,2.2h-6.6c0,1.1,0.3,1.9,0.9,2.4c0.3,0.3,0.8,0.4,1.2,0.4c0.5,0,0.9-0.2,1.3-0.5c0.2-0.2,0.3-0.4,0.5-0.8H54.1\n		z M51.6,48.7c0-0.8-0.2-1.4-0.6-1.8c-0.4-0.4-0.8-0.6-1.3-0.6c-0.6,0-1,0.2-1.3,0.6s-0.5,1-0.6,1.7H51.6z"/>\n	<path d="M64.2,48.2h-2.6c0-0.4-0.2-0.8-0.4-1.1c-0.3-0.5-0.7-0.7-1.3-0.7c-0.8,0-1.4,0.5-1.7,1.5C58.1,48.4,58,49.1,58,50\n		c0,0.8,0.1,1.5,0.2,2c0.3,0.9,0.9,1.4,1.7,1.4c0.6,0,1-0.2,1.2-0.6s0.4-0.9,0.4-1.5h2.6c-0.1,0.9-0.3,1.8-0.8,2.6\n		c-0.8,1.3-1.9,1.9-3.5,1.9s-2.7-0.5-3.4-1.6c-0.7-1.1-1.1-2.5-1.1-4.2c0-1.9,0.4-3.5,1.2-4.5s1.9-1.6,3.3-1.6c1.2,0,2.2,0.3,2.9,1\n		C63.6,45.5,64.1,46.6,64.2,48.2z"/>\n</g>\n</svg>\n';

  // simulator/img/Decoder16Seg.svg
  var Decoder16Seg_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n	<path d="M87.6,16v-2H73.3v-4H26.8v13H12.3v2h14.5v6.8H12.3v2h14.5v6.8H12.3v2h14.5v6.8H12.3v2h14.5v6.8H12.3v2h14.5V67H12.3v2h14.5\n	v6.7H12.3v2h14.5V90h46.5v-3.3h14.3v-2H73.3V82h14.3v-2H73.3v-2.7h14.3v-2H73.3v-2.7h14.3v-2H73.3v-2.7h14.3v-2H73.3v-2.8h14.3v-2\n	H73.3v-2.7h14.3v-2H73.3v-2.7h14.3v-2H73.3V49h14.3v-2H73.3v-2.7h14.3v-2H73.3v-2.7h14.3v-2H73.3v-2.8h14.3v-2H73.3v-2.7h14.3v-2\n	H73.3v-2.7h14.3v-2H73.3v-2.7h14.3v-2H73.3V16H87.6z M70.3,87H29.8V13h40.5V87z" />\n	<path d="M39.3,55.8h-1.8V44.6c-0.4,0.4-1,0.8-1.7,1.2s-1.3,0.7-1.9,0.9V45c1-0.5,1.8-1,2.6-1.7s1.3-1.3,1.6-1.9h1.1V55.8z" />\n	<path d="M56,52.4l1.7-0.3c0.1,0.7,0.4,1.2,0.8,1.6c0.4,0.4,1.1,0.6,1.9,0.6c0.8,0,1.4-0.2,1.8-0.5s0.6-0.7,0.6-1.2\n		c0-0.4-0.2-0.7-0.5-0.9c-0.2-0.2-0.8-0.4-1.8-0.6c-1.3-0.3-2.2-0.6-2.7-0.8s-0.9-0.6-1.1-1c-0.3-0.4-0.4-0.9-0.4-1.4\n		c0-0.5,0.1-0.9,0.3-1.3c0.2-0.4,0.5-0.7,0.9-1c0.3-0.2,0.6-0.4,1.1-0.5c0.5-0.1,1-0.2,1.5-0.2c0.8,0,1.5,0.1,2.1,0.4s1.1,0.6,1.4,1\n		s0.5,0.9,0.6,1.6L62.5,48c-0.1-0.5-0.3-1-0.7-1.2c-0.4-0.3-0.9-0.4-1.6-0.4c-0.8,0-1.4,0.1-1.7,0.4C58.2,47,58,47.3,58,47.7\n		c0,0.2,0.1,0.4,0.2,0.6c0.1,0.2,0.4,0.3,0.7,0.5c0.2,0.1,0.7,0.2,1.6,0.4c1.2,0.3,2.1,0.6,2.6,0.8c0.5,0.2,0.9,0.5,1.2,0.9\n		c0.3,0.4,0.4,0.9,0.4,1.5c0,0.6-0.2,1.1-0.5,1.7s-0.8,0.9-1.5,1.2s-1.4,0.4-2.2,0.4c-1.3,0-2.4-0.3-3.1-0.8\n		C56.7,54.3,56.2,53.5,56,52.4z" />\n	<path d="M65.9,55.8v-2h2v2H65.9z" />\n	<path d="M50.3,45l-1.7,0.1c-0.2-0.7-0.4-1.2-0.7-1.5c-0.5-0.5-1.1-0.8-1.8-0.8c-0.6,0-1.1,0.2-1.5,0.5c-0.6,0.4-1,1-1.3,1.8\n		s-0.5,1.9-0.5,3.3c0.4-0.6,0.9-1.1,1.6-1.4s1.3-0.5,1.9-0.5c1.2,0,2.2,0.4,3,1.3s1.2,2,1.2,3.3c0,0.9-0.2,1.7-0.6,2.5\n		S49,55,48.4,55.4s-1.4,0.6-2.3,0.6c-1.5,0-2.7-0.5-3.6-1.6c-0.9-1.1-1.4-2.9-1.4-5.3c0-2.8,0.5-4.8,1.5-6c0.9-1.1,2.1-1.6,3.6-1.6\n		c1.1,0,2,0.3,2.8,0.9S50.1,43.9,50.3,45z M43.1,51.2c0,0.6,0.1,1.2,0.4,1.7c0.3,0.6,0.6,1,1.1,1.3c0.5,0.3,0.9,0.4,1.5,0.4\n		c0.7,0,1.4-0.3,1.9-0.9c0.5-0.6,0.8-1.4,0.8-2.4c0-1-0.3-1.8-0.8-2.3s-1.2-0.9-2-0.9c-0.8,0-1.5,0.3-2,0.9S43.1,50.3,43.1,51.2z" />\n</svg>';

  // simulator/img/Decoder7Seg.svg
  var Decoder7Seg_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n	<path d="M87.7,25v-2H73.3V10H26.8v13H11.1v2h15.7v15.6H11.1v2h15.7v15.6H11.1v2h15.7v15.5H11.1v2h15.7V90h46.5V77.7h14.4v-2H73.3V69\n	h14.4v-2H73.3v-6.8h14.4v-2H73.3v-6.8h14.4v-2H73.3v-6.8h14.4v-2H73.3v-6.8h14.4v-2H73.3V25H87.7z M70.3,87H29.8V13h40.5V87z" />\n	<path d="M35.1,42.3V40h13v1.9c-1.3,1.4-2.5,3.2-3.8,5.4c-1.3,2.3-2.2,4.6-2.9,6.9c-0.5,1.7-0.8,3.5-0.9,5.5h-2.5\n		c0-1.6,0.3-3.5,0.9-5.7c0.6-2.2,1.4-4.4,2.5-6.5s2.3-3.8,3.5-5.2H35.1z" />\n	<path d="M51.1,55.1l2.4-0.4c0.1,1,0.5,1.7,1.1,2.2c0.6,0.5,1.5,0.8,2.6,0.8c1.1,0,2-0.2,2.5-0.7s0.8-1,0.8-1.6c0-0.6-0.2-1-0.7-1.3\n		c-0.3-0.2-1.2-0.5-2.5-0.8c-1.8-0.5-3.1-0.8-3.8-1.2s-1.2-0.8-1.6-1.4c-0.4-0.6-0.5-1.2-0.5-1.9c0-0.6,0.1-1.2,0.4-1.8\n		c0.3-0.6,0.7-1,1.2-1.4c0.4-0.3,0.9-0.5,1.6-0.7c0.7-0.2,1.4-0.3,2.1-0.3c1.1,0,2.1,0.2,3,0.5s1.5,0.8,1.9,1.3s0.7,1.3,0.8,2.2\n		L60.2,49c-0.1-0.7-0.4-1.3-1-1.8c-0.5-0.4-1.3-0.6-2.2-0.6c-1.1,0-1.9,0.2-2.4,0.6s-0.7,0.8-0.7,1.3c0,0.3,0.1,0.6,0.3,0.9\n		c0.2,0.3,0.5,0.5,0.9,0.7c0.2,0.1,1,0.3,2.2,0.6c1.7,0.5,3,0.8,3.6,1.1c0.7,0.3,1.2,0.7,1.6,1.3s0.6,1.3,0.6,2.1\n		c0,0.8-0.2,1.6-0.7,2.3s-1.2,1.3-2.1,1.7s-1.9,0.6-3.1,0.6c-1.9,0-3.3-0.4-4.3-1.2C52,57.8,51.4,56.6,51.1,55.1z" />\n	<path d="M64.5,59.7v-2.8h2.8v2.8H64.5z" />\n</svg>';

  // simulator/img/DecoderBCD4.svg
  var DecoderBCD4_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n	<path d="M92,17.4v-2H77.6V10h-55v14.7H8.1v2h14.5v14.2H8.1v2h14.5v14.2H8.1v2h14.5v14.2H8.1v2h14.5V90h55v-5.2H92v-2H77.6V66H92v-2\n	H77.6V49.8H92v-2H77.6V33.6H92v-2H77.6V17.4H92z M74.6,87h-49V13h49V87z" />\n	<path d="M29.7,60.5V41.4h5.6c1.1,0,2.1,0.2,2.8,0.6c0.7,0.4,1.2,1,1.6,1.8c0.4,0.8,0.6,1.6,0.6,2.5c0,0.8-0.2,1.6-0.5,2.3\n		c-0.3,0.7-0.9,1.3-1.6,1.7c0.9,0.3,1.6,0.9,2.1,1.7c0.5,0.8,0.7,1.8,0.7,2.9c0,0.9-0.1,1.7-0.4,2.5c-0.3,0.8-0.7,1.4-1.1,1.8\n		c-0.4,0.4-1,0.7-1.6,0.9c-0.7,0.2-1.5,0.3-2.4,0.3H29.7z M31.6,49.4h3.2c0.9,0,1.5-0.1,1.9-0.2c0.5-0.2,0.9-0.5,1.1-1\n		c0.3-0.4,0.4-1,0.4-1.7c0-0.6-0.1-1.2-0.4-1.7c-0.2-0.5-0.6-0.8-1-1c-0.4-0.2-1.2-0.3-2.3-0.3h-3V49.4z M31.6,58.3h3.7\n		c0.6,0,1.1,0,1.3-0.1c0.5-0.1,0.8-0.3,1.1-0.5c0.3-0.2,0.6-0.6,0.8-1.1c0.2-0.5,0.3-1,0.3-1.6c0-0.7-0.1-1.3-0.4-1.9\n		c-0.3-0.5-0.7-0.9-1.2-1.1c-0.5-0.2-1.2-0.3-2.2-0.3h-3.5V58.3z" />\n	<path d="M54.4,53.8l2,0.6c-0.4,2.1-1.2,3.7-2.2,4.8c-1.1,1.1-2.4,1.6-4,1.6c-1.6,0-2.9-0.4-3.9-1.3c-1-0.8-1.8-2.1-2.3-3.6\n		c-0.5-1.6-0.8-3.3-0.8-5.1c0-2,0.3-3.7,0.9-5.2c0.6-1.5,1.4-2.6,2.5-3.4c1.1-0.8,2.3-1.2,3.6-1.2c1.5,0,2.8,0.5,3.8,1.5\n		s1.7,2.3,2.1,4.1l-2,0.6c-0.3-1.4-0.9-2.4-1.5-3c-0.7-0.6-1.5-1-2.5-1c-1.2,0-2.1,0.4-2.9,1.1c-0.8,0.7-1.3,1.7-1.6,2.8\n		c-0.3,1.2-0.5,2.4-0.5,3.7c0,1.6,0.2,3,0.6,4.3c0.4,1.2,0.9,2.1,1.7,2.7c0.8,0.6,1.6,0.9,2.5,0.9c1.1,0,2-0.4,2.8-1.2\n		C53.6,56.6,54.1,55.4,54.4,53.8z" />\n	<path d="M58.8,60.5V41.4H64c1.2,0,2.1,0.1,2.7,0.3c0.9,0.3,1.6,0.7,2.2,1.4c0.8,0.9,1.4,1.9,1.8,3.3c0.4,1.3,0.6,2.8,0.6,4.5\n		c0,1.5-0.1,2.7-0.4,3.9s-0.6,2-1,2.8c-0.4,0.7-0.9,1.3-1.4,1.7c-0.5,0.4-1.1,0.7-1.8,1c-0.7,0.2-1.5,0.3-2.4,0.3H58.8z M60.8,58.3\n		H64c1,0,1.8-0.1,2.3-0.4s1-0.6,1.3-1c0.5-0.6,0.8-1.4,1.1-2.4c0.3-1,0.4-2.2,0.4-3.7c0-2-0.3-3.5-0.8-4.6c-0.5-1.1-1.1-1.8-1.9-2.2\n		c-0.5-0.3-1.4-0.4-2.6-0.4h-3.1V58.3z" />\n</svg>';

  // simulator/img/Demux.svg
  var Demux_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n<path d="M80,25v-2H65V4.4l-17,9.9V1h-2v14.4l-15,8.7V43H16v2h15v9H16v2h15v19.9l34,18.6V78h15v-2H65v-9h15v-2H65V36h15v-2H65v-9H80z\n	 M62,9.6v13.5c-7.3,0.8-11.3,5.7-15.2,10.5c-3.6,4.4-7,8.6-12.8,9.2v-17L62,9.6z M62,25.1v9c-6.4,0.7-9.8,5.3-13.2,9.7\n	c-3.8,5-7.3,9.7-14.8,10.2v-9.1c6.7-0.5,10.6-5.3,14.3-9.9C52.1,30.3,55.7,25.9,62,25.1z M34,74.1V56c8.5-0.5,12.7-6,16.4-10.9\n	c3.2-4.2,6.2-8.2,11.6-8.9v53.3L34,74.1z"/>\n</svg>\n';

  // simulator/img/Display16Seg.svg
  var Display16Seg_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 1792 1792" style="enable-background:new 0 0 1792 1792;" fill="currentColor">\n<path d="M370.3,38.4v117.4H0.6v46.1h369.7v49.7H0.6v46.1h369.7v49.6H0.6v46.1h369.7v49.7H0.6v46.1h369.7v50.7H1.6V584h368.7v51.6\n	H1.6v44.1h368.7v51.7H1.6v44.1h368.7v51.7H1.6v44.1h368.7v51.6H1.6V967h368.7v51.7H1.6v44.1h368.7v51.7H1.6v44.1h368.7v51.7H1.6\n	v44.1h368.7v51.6H1.6v44.1h368.7v51.7H1.6v44.1h368.7v51.7H1.6v44.1h368.7v51.6H1.6v44.1h368.7v119.4h1289.9V38.4H370.3z\n	 M1540.2,1636.8H490.3V158.4h1049.9V1636.8z"/>\n<g fill="#00ff00" fill-opacity="0.65" stroke="#000000" stroke-width="7">\n	<polygon points="650,313.2 694.8,268.5 954.5,268.5 1001.1,315 958.2,357.9 693.7,357.9 	"/>\n	<polygon points="1034.4,313.2 1079.2,268.5 1339,268.5 1385.5,315 1342.6,357.9 1078.2,357.9 	"/>\n	<polygon points="1404.5,873.1 1359.7,828.4 1359.7,380.6 1406.3,334.1 1449.2,376.9 1449.2,829.4 	"/>\n	<polygon points="627.8,873.1 583.1,828.4 583.1,380.6 629.6,334.1 672.5,376.9 672.5,829.4 	"/>\n	<polygon points="1404.5,1455.3 1359.7,1410.5 1359.7,962.8 1406.3,916.3 1449.2,959.1 1449.2,1411.6 	"/>\n	<polygon points="627.8,1455.3 583.1,1410.5 583.1,962.8 629.6,916.3 672.5,959.1 672.5,1411.6 	"/>\n	<polygon points="1015.3,873.1 970.5,828.4 970.5,380.6 1017.1,334.1 1060,376.9 1060,829.4 	"/>\n	<polygon points="948.2,826 891.4,826 697,457.4 697,384.2 752.5,384.2 948.2,757.1 	"/>\n	<polygon points="1084.2,757.1 1279.9,384.2 1335.5,384.2 1335.5,457.4 1141,826 1084.2,826 	"/>\n	<polygon points="695.9,1337.8 891.6,964.9 947.1,964.9 947.1,1038 752.7,1406.6 695.9,1406.6 	"/>\n	<polygon points="1335.6,1406.6 1278.8,1406.6 1084.3,1038 1084.3,964.9 1139.9,964.9 1335.6,1337.8 	"/>\n	<polygon points="1015.3,1455.3 970.5,1410.5 970.5,962.8 1017.1,916.3 1060,959.1 1060,1411.6 	"/>\n	<polygon points="650,893.6 694.8,848.9 954.5,848.9 1001.1,895.4 958.2,938.3 693.7,938.3 	"/>\n	<polygon points="1034.4,893.6 1079.2,848.9 1339,848.9 1385.5,895.4 1342.6,938.3 1078.2,938.3 	"/>\n	<polygon points="650,1474 694.8,1429.3 954.5,1429.3 1001.1,1475.8 958.2,1518.7 693.7,1518.7 	"/>\n	<polygon points="1034.4,1474 1079.2,1429.3 1339,1429.3 1385.5,1475.8 1342.6,1518.7 1078.2,1518.7 	"/>\n</g>\n</svg>\n';

  // simulator/img/Display4.svg
  var Display4_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 1792 1792" style="enable-background:new 0 0 1792 1792;" fill="currentColor">\n<path fill="#8888ff" fill-opacity="1" d="M1041.4,1259.6c-83.2,0-141.6-29.1-175-87.5c-33.5-58.3-50.2-141.3-50.2-249.1s16.7-191,50.2-249.5\n	c33.5-58.5,91.9-87.9,175-87.9s141.6,29.3,175.2,87.9c33.3,58.5,50,141.7,50,249.5c0,107.8-16.7,190.8-50.2,249.1\n	C1182.8,1230.4,1124.6,1259.6,1041.4,1259.6z M1116.6,1095.2c11.8-39.6,17.6-97,17.6-172c0-78.7-6-137-17.8-174.8\n	c-11.9-37.8-36.8-56.7-75-56.7c-38.2,0-63.4,19-75.7,56.7c-12.3,37.8-18.4,96-18.4,174.8c0,75.1,6.1,132.6,18.4,172.3\n	c12.3,39.9,37.5,59.6,75.7,59.6C1079.5,1155.2,1104.5,1135.1,1116.6,1095.2z"/>\n<path d="M414.2,118v167.5H0v120h414.2v253.9H0v120h414.2v243.2H0v120h414.2v251.7H0v120h414.2V1697H1649V118H414.2z M1469,1517\n	H594.2V298H1469V1517z"/>\n</svg>\n';

  // simulator/img/Display7Seg.svg
  var Display7Seg_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 1792 1792" style="enable-background:new 0 0 1792 1792;" fill="currentColor">\n<path d="M370.3,38.4v248.2H2.5v95h367.8v96.6H-0.6v95h370.9v85.9H2.5v95h367.8v92H2.1v95h368.2v93.1H2.5v95h367.8v92.8H2.5v95h367.8\n	v99.5H0.5v95h369.8v245.3h1289.9V38.4H370.3z M1540.2,1636.8H490.3V158.4h1049.9V1636.8z"/>\n	<g fill="#00ff00" fill-opacity="0.65" stroke="#000000" stroke-width="10">\n<polygon points="760.4,334.1 826,268.5 1206.9,268.5 1275.1,336.7 1212.3,399.6 824.5,399.6 "/>\n<polygon points="760.4,893.6 826,828.1 1206.9,828.1 1275.1,896.3 1212.3,959.1 824.5,959.1 "/>\n<polygon points="760.4,1446 826,1380.4 1206.9,1380.4 1275.1,1448.6 1212.3,1511.5 824.5,1511.5 "/>\n<polygon points="735.6,1416.4 670,1350.8 670,993.8 738.2,925.6 801.1,988.5 801.1,1352.3 "/>\n<polygon points="735.6,864.3 670,798.8 670,441.8 738.2,373.6 801.1,436.5 801.1,800.2 "/>\n<polygon points="1294.7,1416.4 1229.1,1350.8 1229.1,993.8 1297.3,925.6 1360.2,988.5 1360.2,1352.3 "/>\n<polygon points="1294.7,864.3 1229.1,798.8 1229.1,441.8 1297.3,373.6 1360.2,436.5 1360.2,800.2 "/>\n	</g>\n</svg>\n';

  // simulator/img/Display8.svg
  var Display8_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 1792 1792" style="enable-background:new 0 0 1792 1792;" fill="currentColor">\n	<path fill="#8888ff" fill-opacity="1" d="M1041.4,1366.5c-109.6,0-186.4-38.4-230.5-115.1c-44.1-76.7-66.2-186.1-66.2-328.1c0-142,22-251.6,66.2-328.7\n		c44.1-77.1,120.9-115.7,230.5-115.7c109.6,0,186.5,38.6,230.8,115.7c43.9,77.1,65.9,186.7,65.9,328.7c0,142-22.1,251.4-66.2,328.1\n		C1227.8,1328.2,1150.9,1366.5,1041.4,1366.5z M1140.4,1149.9c15.4-52.2,23.1-127.8,23.1-226.7c0-103.6-7.8-180.4-23.4-230.2\n		c-15.6-49.8-48.6-74.8-98.8-74.8c-50.2,0-83.5,24.9-99.7,74.8c-16.2,49.8-24.3,126.6-24.3,230.2c0,98.9,8.1,174.5,24.3,227\n		c16.2,52.4,49.4,78.6,99.7,78.6C1091.6,1228.9,1124.6,1202.6,1140.4,1149.9z" />\n	<path d="M346,57.9v62.3H-2.7v120H346v90.3H-2.7v120H346v90.4H-2.7v120H346v90.3H-2.7v120H346v90.4H-2.7v120H346v90.2H-2.7v120H346\n	v90.4H-5.2v120H346v90.3H-2.7v120H346v44.5h1371.2V57.9H346z M1587.2,1627.1H476V187.9h1111.2V1627.1z" />\n</svg>';

  // simulator/img/DisplayAscii.svg
  var DisplayAscii_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 1792 1792" style="enable-background:new 0 0 1792 1792;" fill="currentColor">\n	<g fill="#8888ff" fill-opacity="1">\n		<path d="M714.4,845.3H611v-76.8c0-37.1,8.8-66.1,26.4-86.9c17.6-20.8,42.8-34.4,75.6-41v37.9\n		c-25,7.3-41.6,20.9-49.9,40.8c-4.6,10.7-6.4,20.8-5.5,30.2h56.8V845.3z" />\n		<path d="M1256.7,1182.5h-136.2l-102-182.8l-107.8,182.8H780.3L952.9,909L788.7,645.7h134l95.8,174.5l98.3-174.5h129.7\n		l-164.3,259L1256.7,1182.5z" />\n		<path d="M1417.7,724.3c0,36.7-8.9,65.6-26.8,86.7c-17.8,21.1-42.9,34.8-75.2,41.2v-38.2c23.8-7.5,40.2-20.3,49.2-38.2\n		c4.9-10.7,6.9-21.5,6.2-32.4h-57.2v-95.8h103.8V724.3z" />\n	</g>\n	<path d="M372.2,49.4v234.7H0v100h372.2v91.6H-3.1v100h375.3v80.9H0v100h372.2v87H-0.4v100h372.6v88.1H0v100h372.2v87.8H0v100h372.2\n	v94.5H-2v100h374.2v231.7h1286.1V49.4H372.2z M1478.3,1565.7H552.2V229.4h926.1V1565.7z" />\n	<rect x="2151.4" y="1368.3" style="fill:none;" width="0" height="4.1" />\n</svg>';

  // simulator/img/DisplayBar.svg
  var DisplayBar_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 1792 1792" style="enable-background:new 0 0 1792 1792;" fill="currentColor">\n	<path d="M3.3,848.3h429.1v173.3H3.3V848.3z" />\n	<path d="M435.7,1024.9H0V845h435.8V1024.9z M6.6,1018.3h422.4V851.6H6.6V1018.3z" />\n	<path fill="#00ff00" fill-opacity="0.65" d="M498.1,1721.2V89.2h738.8v1632H498.1z" />\n	<path d="M1301.9,1786.2H433.1V24.2h868.8V1786.2z M563.1,1656.2h608.8v-1502H563.1V1656.2z" />\n</svg>';

  // simulator/img/FlipflopD.svg
  var FlipflopD_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n	<path d="M95,31v-2H80V10H20v19H5v2h15v38H5v2h15v19h60V71h15v-2H80V31H95z M23,66.9l7.1,3.1L23,73.1V66.9z M77,87H23V75.3L35.1,70\n	L23,64.7V13h54V87z" />\n	<rect x="62.4" y="60" width="11.9" height="1.5" />\n	<path d="M27.3,36.3V23.4h4.4c1,0,1.8,0.1,2.3,0.2c0.7,0.2,1.4,0.5,1.9,0.9c0.7,0.6,1.2,1.3,1.5,2.2c0.3,0.9,0.5,1.9,0.5,3.1\n		c0,1-0.1,1.8-0.3,2.6s-0.5,1.4-0.9,1.9c-0.4,0.5-0.7,0.9-1.2,1.2s-0.9,0.5-1.5,0.6s-1.3,0.2-2.1,0.2H27.3z M29,34.8h2.8\n		c0.8,0,1.5-0.1,2-0.2s0.9-0.4,1.2-0.7c0.4-0.4,0.7-0.9,0.9-1.6c0.2-0.7,0.3-1.5,0.3-2.5c0-1.3-0.2-2.4-0.7-3.1\n		c-0.4-0.7-1-1.2-1.6-1.5c-0.5-0.2-1.2-0.3-2.2-0.3H29V34.8z" />\n	<path d="M72.6,35.1c0.8,0.5,1.5,0.9,2.2,1.2l-0.5,1.2c-0.9-0.3-1.8-0.9-2.8-1.6c-1,0.5-2,0.8-3.2,0.8c-1.2,0-2.2-0.3-3.2-0.8\n		s-1.7-1.4-2.2-2.4s-0.8-2.2-0.8-3.4c0-1.3,0.3-2.4,0.8-3.5s1.2-1.8,2.2-2.4s2-0.8,3.2-0.8c1.2,0,2.3,0.3,3.2,0.8\n		c1,0.6,1.7,1.4,2.2,2.4c0.5,1,0.8,2.2,0.8,3.4c0,1.1-0.2,2-0.5,2.9S73.2,34.5,72.6,35.1z M68.8,33c1,0.3,1.8,0.7,2.4,1.2\n		c1-0.9,1.5-2.3,1.5-4.1c0-1-0.2-2-0.5-2.7s-0.9-1.4-1.6-1.8c-0.7-0.4-1.4-0.6-2.3-0.6c-1.3,0-2.3,0.4-3.2,1.3\n		c-0.8,0.9-1.3,2.2-1.3,3.9c0,1.7,0.4,3,1.2,3.9s1.9,1.3,3.2,1.3c0.6,0,1.2-0.1,1.7-0.3c-0.5-0.3-1.1-0.6-1.7-0.7L68.8,33z" />\n	<path d="M72.5,75.1c0.8,0.5,1.5,0.9,2.2,1.2l-0.5,1.2c-0.9-0.3-1.8-0.9-2.8-1.6c-1,0.5-2,0.8-3.2,0.8c-1.2,0-2.2-0.3-3.2-0.8\n		s-1.7-1.4-2.2-2.4s-0.8-2.2-0.8-3.4c0-1.3,0.3-2.4,0.8-3.5s1.2-1.8,2.2-2.4s2-0.8,3.2-0.8c1.2,0,2.3,0.3,3.2,0.8\n		c1,0.6,1.7,1.4,2.2,2.4c0.5,1,0.8,2.2,0.8,3.4c0,1.1-0.2,2-0.5,2.9S73.1,74.5,72.5,75.1z M68.7,73c1,0.3,1.8,0.7,2.4,1.2\n		c1-0.9,1.5-2.3,1.5-4.1c0-1-0.2-2-0.5-2.7s-0.9-1.4-1.6-1.8c-0.7-0.4-1.4-0.6-2.3-0.6c-1.3,0-2.3,0.4-3.2,1.3\n		c-0.8,0.9-1.3,2.2-1.3,3.9c0,1.7,0.4,3,1.2,3.9s1.9,1.3,3.2,1.3c0.6,0,1.2-0.1,1.7-0.3c-0.5-0.3-1.1-0.6-1.7-0.7L68.7,73z" />\n</svg>';

  // simulator/img/FlipflopJK.svg
  var FlipflopJK_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n	<path d="M95,31v-2H80V10H20v19H5v2h15v18H5v2h15v18H5v2h15v19h60V71h15v-2H80V31H95z M23,46.9l7.1,3.1L23,53.1V46.9z M77,87H23V55.3\n	L35.1,50L23,44.7V13h54V87z" />\n	<rect x="62.4" y="60.2" width="11.9" height="1.5" />\n	<path d="M26.5,32.8l1.5-0.2c0,1,0.2,1.7,0.6,2s0.8,0.5,1.4,0.5c0.4,0,0.8-0.1,1.1-0.3c0.3-0.2,0.5-0.5,0.6-0.8s0.2-0.9,0.2-1.6\n		v-8.9h1.7v8.8c0,1.1-0.1,1.9-0.4,2.5s-0.7,1-1.2,1.4s-1.2,0.5-2,0.5c-1.1,0-2-0.3-2.6-1S26.4,34.1,26.5,32.8z" />\n	<path d="M27,76.7V63.8h1.7v6.4l6.4-6.4h2.3L32,69l5.6,7.7h-2.2l-4.6-6.5l-2.1,2.1v4.5H27z" />\n	<path d="M72.6,35.3c0.8,0.5,1.5,0.9,2.2,1.2l-0.5,1.2c-0.9-0.3-1.8-0.9-2.8-1.6c-1,0.5-2,0.8-3.2,0.8c-1.2,0-2.2-0.3-3.2-0.8\n		s-1.7-1.4-2.2-2.4s-0.8-2.2-0.8-3.4c0-1.3,0.3-2.4,0.8-3.5s1.2-1.8,2.2-2.4s2-0.8,3.2-0.8c1.2,0,2.3,0.3,3.2,0.8\n		c1,0.6,1.7,1.4,2.2,2.4c0.5,1,0.8,2.2,0.8,3.4c0,1.1-0.2,2-0.5,2.9S73.2,34.7,72.6,35.3z M68.8,33.1c1,0.3,1.8,0.7,2.4,1.2\n		c1-0.9,1.5-2.3,1.5-4.1c0-1-0.2-2-0.5-2.7s-0.9-1.4-1.6-1.8c-0.7-0.4-1.4-0.6-2.3-0.6c-1.3,0-2.3,0.4-3.2,1.3\n		c-0.8,0.9-1.3,2.2-1.3,3.9c0,1.7,0.4,3,1.2,3.9s1.9,1.3,3.2,1.3c0.6,0,1.2-0.1,1.7-0.3c-0.5-0.3-1.1-0.6-1.7-0.7L68.8,33.1z" />\n	<path d="M72.5,75.3c0.8,0.5,1.5,0.9,2.2,1.2l-0.5,1.2c-0.9-0.3-1.8-0.9-2.8-1.6c-1,0.5-2,0.8-3.2,0.8c-1.2,0-2.2-0.3-3.2-0.8\n		s-1.7-1.4-2.2-2.4s-0.8-2.2-0.8-3.4c0-1.3,0.3-2.4,0.8-3.5s1.2-1.8,2.2-2.4s2-0.8,3.2-0.8c1.2,0,2.3,0.3,3.2,0.8\n		c1,0.6,1.7,1.4,2.2,2.4c0.5,1,0.8,2.2,0.8,3.4c0,1.1-0.2,2-0.5,2.9S73.1,74.7,72.5,75.3z M68.7,73.1c1,0.3,1.8,0.7,2.4,1.2\n		c1-0.9,1.5-2.3,1.5-4.1c0-1-0.2-2-0.5-2.7s-0.9-1.4-1.6-1.8c-0.7-0.4-1.4-0.6-2.3-0.6c-1.3,0-2.3,0.4-3.2,1.3\n		c-0.8,0.9-1.3,2.2-1.3,3.9c0,1.7,0.4,3,1.2,3.9s1.9,1.3,3.2,1.3c0.6,0,1.2-0.1,1.7-0.3c-0.5-0.3-1.1-0.6-1.7-0.7L68.7,73.1z" />\n</svg>';

  // simulator/img/FlipflopT.svg
  var FlipflopT_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n	<path d="M95,31v-2H80V10H20v19H5v2h15v38H5v2h15v19h60V71h15v-2H80V31H95z M23,66.9l7.1,3.1L23,73.1V66.9z M77,87H23V75.3L35.1,70\n		L23,64.7V13h54V87z" />\n	<rect x="61.9" y="60.2" width="11.9" height="1.5" />\n	<path d="M30.1,36.4V25h-4.2v-1.5h10.2V25h-4.3v11.4H30.1z" />\n	<path d="M72,35.3c0.8,0.5,1.5,0.9,2.2,1.2l-0.5,1.2c-0.9-0.3-1.8-0.9-2.8-1.6c-1,0.5-2,0.8-3.2,0.8c-1.2,0-2.2-0.3-3.2-0.8\n		s-1.7-1.4-2.2-2.4s-0.8-2.2-0.8-3.4c0-1.3,0.3-2.4,0.8-3.5s1.2-1.8,2.2-2.4s2-0.8,3.2-0.8c1.2,0,2.3,0.3,3.2,0.8\n		c1,0.6,1.7,1.4,2.2,2.4c0.5,1,0.8,2.2,0.8,3.4c0,1.1-0.2,2-0.5,2.9S72.7,34.6,72,35.3z M68.3,33.1c1,0.3,1.8,0.7,2.4,1.2\n		c1-0.9,1.5-2.3,1.5-4.1c0-1-0.2-2-0.5-2.7s-0.9-1.4-1.6-1.8c-0.7-0.4-1.4-0.6-2.3-0.6c-1.3,0-2.3,0.4-3.2,1.3\n		c-0.8,0.9-1.3,2.2-1.3,3.9c0,1.7,0.4,3,1.2,3.9s1.9,1.3,3.2,1.3c0.6,0,1.2-0.1,1.7-0.3c-0.5-0.3-1.1-0.6-1.7-0.7L68.3,33.1z" />\n	<path d="M72,75.3c0.8,0.5,1.5,0.9,2.2,1.2l-0.5,1.2c-0.9-0.3-1.8-0.9-2.8-1.6c-1,0.5-2,0.8-3.2,0.8c-1.2,0-2.2-0.3-3.2-0.8\n		s-1.7-1.4-2.2-2.4s-0.8-2.2-0.8-3.4c0-1.3,0.3-2.4,0.8-3.5s1.2-1.8,2.2-2.4s2-0.8,3.2-0.8c1.2,0,2.3,0.3,3.2,0.8\n		c1,0.6,1.7,1.4,2.2,2.4c0.5,1,0.8,2.2,0.8,3.4c0,1.1-0.2,2-0.5,2.9S72.6,74.6,72,75.3z M68.2,73.1c1,0.3,1.8,0.7,2.4,1.2\n		c1-0.9,1.5-2.3,1.5-4.1c0-1-0.2-2-0.5-2.7s-0.9-1.4-1.6-1.8c-0.7-0.4-1.4-0.6-2.3-0.6c-1.3,0-2.3,0.4-3.2,1.3\n		c-0.8,0.9-1.3,2.2-1.3,3.9c0,1.7,0.4,3,1.2,3.9s1.9,1.3,3.2,1.3c0.6,0,1.2-0.1,1.7-0.3c-0.5-0.3-1.1-0.6-1.7-0.7L68.2,73.1z" />\n</svg>';

  // simulator/img/GateArray.svg
  var GateArray_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n	<path d="M88.4,34.2v-2H73.2V1.1H28.4V5H13.2v2h15.2v8.1H13.2v2h15.2v9.2H13.2v2h15.2v9.1H13.2v2h15.2v19.8H13.2v2h15.2v8.1H13.2v2\n	h15.2v9.1H13.2v2h15.2v9.2H13.2v2h15.2v4h44.8v-31h15.2v-2H73.2v-9.2h15.2v-2H73.2v-9.2h15.2v-2H73.2v-8H88.4z M70.2,94.6H31.4V4.1\n	h38.8V94.6z" />\n	<path d="M38.7,35.5v25.8h13.2c7.3,0,12.9-5.8,12.9-12.9s-5.6-12.9-12.9-12.9H38.7z M40.5,37.4h11.4c6.3,0,10.8,4.9,10.8,11.1\n	s-4.8,11.1-11.1,11.1H40.5C40.5,59.5,40.5,37.4,40.5,37.4z" />\n</svg>';

  // simulator/img/HalfAdder.svg
  var HalfAdder_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n    <polygon points="46,65.9 51,65.9 51,54.3 62.2,54.3 62.2,49.3 51,49.3 51,38.2 46,38.2 46,49.3 34.9,49.3 34.9,54.3 46,54.3 	" />\n    <path d="M87.2,32.4v-2H72.7V16.7H25.1v13.7H10.6v2h14.5v35.2H10.6v2h14.5v17.8h47.6V69.6h14.5v-2H72.7V32.4H87.2z M69.7,84.4H28.1\n		V19.7h41.6V84.4z" />\n</svg>';

  // simulator/img/Input1.svg
  var Input1_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 32 24" style="enable-background:new 0 0 32 24;" fill="currentColor">\n<path d="M32,10.5h-3.6c-0.8-0.8-1.9-2-2.8-2.9c-0.7-0.8-1.1-1.2-1.3-1.4C21.4,2.5,16,1,11.7,3.6c-6.4,3.5-6.4,13.2,0,16.8\n	c4.1,2.5,9.4,1.2,12.3-2.2c0.1-0.1,0.2-0.1,0.3-0.2c0,0,0,0,1.6-1.6c0.9-0.9,1.9-1.9,2.6-2.6H32V10.5z M14,17.9\n	C8.8,15.7,8.8,8.2,14,6c4.1-1.8,9,1.4,9,5.9C23,16.5,18.1,19.8,14,17.9z"/>\n</svg>\n';

  // simulator/img/Input4.svg
  var Input4_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 1792 1792" style="enable-background:new 0 0 1792 1792;" fill="currentColor">\n<path d="M1790.2,405.5v-120h-423.9V99H423v1579h943.3v-163.7h423.9v-120h-423.9v-251.7h423.9v-120h-423.9V779.4h423.9v-120h-423.9\n	V405.5H1790.2z M603,1163.4V913h583.3v250.4H603z M603,843.9V592.6h583.3v251.3H603z M1186.3,279v239.5H603V279H1186.3z M603,1498\n	v-257.3h583.3V1498H603z"/>\n</svg>\n';

  // simulator/img/Input8.svg
  var Input8_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 1792 1792" style="enable-background:new 0 0 1792 1792;" fill="currentColor">\n	<path d="M1661.1,260v-50h-324.8V37.4H453v1702.2h883.3V1582h324.2v-50h-324.2v-138.9h324.2v-50h-324.2v-138.8h324.2v-50h-324.2\n	v-138.9h324.2v-50h-324.2V826.6h324.2v-50h-324.2V637.7h324.2v-50h-324.2V448.9h324.2v-50h-324.2V260H1661.1z M573,1618.9v-138.8\n	h643.3v138.8H573z M573,1430.1v-138.8h643.3v138.8H573z M573,1241.3v-138.9h643.3v138.9H573z M573,1052.4V913.6h643.3v138.8H573z\n	 M573,863.6V724.7h643.3v138.9H573z M573,674.7V535.9h643.3v138.8H573z M573,485.9V347h643.3v138.9H573z M573,297V158.2h643.3V297\n	H573z" />\n</svg>';

  // simulator/img/Label.svg
  var Label_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 60" style="enable-background:new 0 0 100 60;" fill="currentColor">\n	<path d="M7.6,44.1l14.4-15.2L13.4,14h4.4l3.9,6.8c1,1.8,1.6,2.8,1.8,3.1c0.4,0.7,0.7,1.5,1.2,2.4c1-1.4,2.6-3.2,4.7-5.4l6.6-7h5.2\n		L26.7,29.5l8.2,14.5h-4.4l-4.9-8.8c-0.5-0.9-1-2-1.7-3.3c-0.7,1-1.6,2.1-2.7,3.2l-8.4,8.9H7.6z"/>\n	<path d="M48.6,44.1l2.4-11.6L41.8,14h4.3l4.4,8.8c1,1.9,1.9,4,2.8,6.2c1-1.9,2.4-3.9,4.1-6.1l7.1-8.8h4.8L55,32.7l-2.4,11.3H48.6z"\n		/>\n	<path d="M65.9,44.1l0.4-3l15.1-18l3.1-3.8c0.6-0.8,1.2-1.5,1.8-2.1c-1.3,0.2-2.2,0.2-2.7,0.2l-1,0l-1.2,0l-1.2,0H70.2l0.7-3.4h20.7\n		l-0.3,3.1L75.2,36.3c-2,2.4-3.2,3.8-3.8,4.5c0.6-0.1,1-0.1,1.2-0.1H89l-0.7,3.4H65.9z"/>\n</svg>\n';

  // simulator/img/LatchSR.svg
  var LatchSR_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n	<path d="M95,31v-2H80V10H20v19H5v2h15v38H5v2h15v19h60V71h15v-2H80V31H95z M77,87H23V13h54V87z" />\n	<rect x="62" y="59.5" width="11.9" height="1.5" />\n	<path d="M26.4,31.6l1.6-0.1c0.1,0.6,0.3,1.2,0.5,1.6c0.3,0.4,0.7,0.7,1.3,1c0.6,0.3,1.2,0.4,2,0.4c0.7,0,1.2-0.1,1.7-0.3\n		s0.9-0.5,1.1-0.8s0.4-0.7,0.4-1.1c0-0.4-0.1-0.8-0.4-1.1s-0.6-0.6-1.2-0.8c-0.3-0.1-1.1-0.3-2.3-0.6s-2-0.6-2.5-0.8\n		c-0.6-0.3-1.1-0.7-1.4-1.2s-0.5-1-0.5-1.6c0-0.7,0.2-1.3,0.6-1.8s0.9-1,1.6-1.3s1.5-0.4,2.4-0.4c1,0,1.8,0.2,2.5,0.5\n		c0.7,0.3,1.3,0.8,1.7,1.4s0.6,1.3,0.6,2l-1.6,0.1c-0.1-0.8-0.4-1.4-0.9-1.8s-1.3-0.6-2.2-0.6c-1,0-1.8,0.2-2.3,0.6\n		c-0.5,0.4-0.7,0.8-0.7,1.4c0,0.5,0.2,0.8,0.5,1.1c0.3,0.3,1.2,0.6,2.6,0.9c1.4,0.3,2.3,0.6,2.9,0.8c0.8,0.3,1.3,0.8,1.7,1.3\n		s0.5,1.1,0.5,1.8c0,0.7-0.2,1.3-0.6,1.9c-0.4,0.6-1,1.1-1.7,1.4c-0.7,0.3-1.6,0.5-2.5,0.5c-1.2,0-2.1-0.2-2.9-0.5s-1.4-0.9-1.9-1.5\n		C26.6,33.3,26.4,32.5,26.4,31.6z" />\n	<path d="M26.7,76V63.1h5.7c1.1,0,2,0.1,2.6,0.3s1.1,0.6,1.4,1.2s0.5,1.2,0.5,1.9c0,0.9-0.3,1.7-0.9,2.3s-1.5,1-2.7,1.2\n		c0.5,0.2,0.8,0.4,1,0.6c0.5,0.5,1,1,1.4,1.7L38,76h-2.1l-1.7-2.7c-0.5-0.8-0.9-1.4-1.2-1.8s-0.6-0.7-0.9-0.9s-0.5-0.3-0.8-0.3\n		c-0.2,0-0.5-0.1-0.9-0.1h-2V76H26.7z M28.4,68.8H32c0.8,0,1.4-0.1,1.8-0.2s0.8-0.4,1-0.8s0.3-0.7,0.3-1.2c0-0.6-0.2-1.1-0.7-1.5\n		s-1.1-0.6-2.1-0.6h-4.1V68.8z" />\n	<path d="M72.2,34.6c0.8,0.5,1.5,0.9,2.2,1.2L73.9,37c-0.9-0.3-1.8-0.9-2.8-1.6c-1,0.5-2,0.8-3.2,0.8c-1.2,0-2.2-0.3-3.2-0.8\n		S63.1,34,62.6,33s-0.8-2.2-0.8-3.4c0-1.3,0.3-2.4,0.8-3.5s1.2-1.8,2.2-2.4s2-0.8,3.2-0.8c1.2,0,2.3,0.3,3.2,0.8\n		c1,0.6,1.7,1.4,2.2,2.4c0.5,1,0.8,2.2,0.8,3.4c0,1.1-0.2,2-0.5,2.9S72.8,34,72.2,34.6z M68.4,32.4c1,0.3,1.8,0.7,2.4,1.2\n		c1-0.9,1.5-2.3,1.5-4.1c0-1-0.2-2-0.5-2.7S71,25.4,70.3,25c-0.7-0.4-1.4-0.6-2.3-0.6c-1.3,0-2.3,0.4-3.2,1.3\n		c-0.8,0.9-1.3,2.2-1.3,3.9c0,1.7,0.4,3,1.2,3.9s1.9,1.3,3.2,1.3c0.6,0,1.2-0.1,1.7-0.3c-0.5-0.3-1.1-0.6-1.7-0.7L68.4,32.4z" />\n	<path d="M72.1,74.6c0.8,0.5,1.5,0.9,2.2,1.2L73.8,77c-0.9-0.3-1.8-0.9-2.8-1.6c-1,0.5-2,0.8-3.2,0.8c-1.2,0-2.2-0.3-3.2-0.8\n		S63,74,62.5,73s-0.8-2.2-0.8-3.4c0-1.3,0.3-2.4,0.8-3.5s1.2-1.8,2.2-2.4s2-0.8,3.2-0.8c1.2,0,2.3,0.3,3.2,0.8\n		c1,0.6,1.7,1.4,2.2,2.4c0.5,1,0.8,2.2,0.8,3.4c0,1.1-0.2,2-0.5,2.9S72.7,74,72.1,74.6z M68.3,72.4c1,0.3,1.8,0.7,2.4,1.2\n		c1-0.9,1.5-2.3,1.5-4.1c0-1-0.2-2-0.5-2.7s-0.9-1.4-1.6-1.8c-0.7-0.4-1.4-0.6-2.3-0.6c-1.3,0-2.3,0.4-3.2,1.3\n		c-0.8,0.9-1.3,2.2-1.3,3.9c0,1.7,0.4,3,1.2,3.9s1.9,1.3,3.2,1.3c0.6,0,1.2-0.1,1.7-0.3c-0.5-0.3-1.1-0.6-1.7-0.7L68.3,72.4z" />\n</svg>';

  // simulator/img/Mux.svg
  var Mux_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n<path d="M83,44.9v-2H68V24.1l-15-8.7V1h-2v13.3L34,4.4V23H19v2h15v9H19v2h15v29H19v2h15v9H19v2h15v16.5l34-18.6V56h15v-2H68v-9.1H83\n	z M37,25.1c6.5,0.7,10.1,5.1,13.9,9.8c3.7,4.6,7.5,9.3,14.1,9.9v9.1c-7.4-0.6-10.9-5.2-14.6-10.1c-3.4-4.5-6.9-9.1-13.4-9.7V25.1z\n	 M65,25.9v16.9c-5.6-0.6-9-4.8-12.6-9.2c-3.9-4.9-8-9.9-15.4-10.6V9.6L65,25.9z M37,89.5V36.1c5.5,0.6,8.6,4.7,11.8,8.9\n	c3.7,4.9,7.8,10.4,16.2,10.9v18.2L37,89.5z"/>\n</svg>\n';

  // simulator/img/Output1.svg
  var Output1_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 32 24" style="enable-background:new 0 0 32 24;" fill="currentColor">\n<path d="M24.1,7.2c-0.9-1.5-2-2.7-3.5-3.5c-1.5-0.9-3.1-1.3-4.9-1.3s-3.4,0.4-4.9,1.3c-1.5,0.9-2.7,2-3.5,3.5c-0.6,0.9-0.9,2-1.1,3\n	L4.5,7c-0.2-0.4-0.6-0.5-1-0.4l0,0C3.1,6.7,2.9,7,2.9,7.4v0c0,0,0,0,0,0v2.8H0v3.2h2.8V16c0,0.4,0.3,0.7,0.6,0.8c0.1,0,0.2,0,0.2,0\n	c0.3,0,0.6-0.2,0.7-0.4l0,0c0,0,0,0,0,0l1.7-2.9c0.2,1.2,0.6,2.3,1.2,3.4c0.9,1.5,2,2.7,3.5,3.5c1.5,0.9,3.1,1.3,4.9,1.3\n	s3.4-0.4,4.9-1.3c1.5-0.9,2.7-2,3.5-3.5c0.9-1.5,1.3-3.1,1.3-4.9C25.4,10.3,25,8.7,24.1,7.2z M21.7,14.6c-0.3,0.8-0.8,1.5-1.4,2.1\n	c-0.6,0.6-1.3,1-2.1,1.4c-0.8,0.3-1.6,0.5-2.5,0.5S14,18.3,13.3,18c-0.8-0.3-1.5-0.8-2.1-1.4c-0.6-0.6-1-1.3-1.4-2.1\n	c-0.3-0.8-0.5-1.6-0.5-2.5c0-0.9,0.2-1.7,0.5-2.5c0.3-0.8,0.8-1.5,1.4-2.1c0.6-0.6,1.3-1,2.1-1.4c0.8-0.3,1.6-0.5,2.5-0.5\n	s1.7,0.2,2.5,0.5c0.8,0.3,1.5,0.8,2.1,1.4c0.6,0.6,1,1.3,1.4,2.1c0.3,0.8,0.5,1.6,0.5,2.5C22.2,12.9,22,13.8,21.7,14.6z"/>\n</svg>\n';

  // simulator/img/Output4.svg
  var Output4_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 1792 1792" style="enable-background:new 0 0 1792 1792;" fill="currentColor">\n<path d="M419.9,115.9v163.7H-4v120h423.9v251.7H-4v120h423.9v243.2H-4v120h423.9v253.9H-4v120h423.9v186.5h943.3v-1579H419.9z\n	 M599.9,1201.3V950h583.3v251.3H599.9z M1183.2,630.5v250.4H599.9V630.5H1183.2z M1183.2,295.9v257.3H599.9V295.9H1183.2z\n	 M599.9,1514.9v-239.5h583.3v239.5H599.9z"/>\n</svg>\n';

  // simulator/img/Output8.svg
  var Output8_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 1792 1792" style="enable-background:new 0 0 1792 1792;" fill="currentColor">\n<path d="M323.8,47.3v157.6H-0.4v50h324.2v138.9H-0.4v50h324.2v138.8H-0.4v50h324.2v138.9H-0.4v50h324.2v138.8H-0.4v50h324.2v138.9\n	H-0.4v50h324.2V1338H-0.4v50h324.2v138.9H-1v50h324.8v172.6h883.3V47.3H323.8z M443.8,1628.7v-138.8h643.3v138.8H443.8z\n	 M443.8,1439.9V1301h643.3v138.9H443.8z M443.8,1251v-138.8h643.3V1251H443.8z M443.8,1062.2V923.3h643.3v138.9H443.8z M443.8,873.3\n	V734.5h643.3v138.8H443.8z M443.8,684.5V545.6h643.3v138.9H443.8z M443.8,495.6V356.8h643.3v138.8H443.8z M443.8,306.8V168h643.3\n	v138.8H443.8z"/>\n</svg>\n';

  // simulator/img/Passthrough1.svg
  var Passthrough1_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n<rect x="45.8" y="5.9" fill="#9E9E9E" width="8" height="36.6"/>\n<rect x="19.6" y="21.7" width="60" height="6"/>\n</svg>\n';

  // simulator/img/PassthroughN.svg
  var PassthroughN_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n<rect x="45.8" y="3.6" fill="#9E9E9E" width="8" height="91.2"/>\n<rect x="19.6" y="11.6" width="60" height="5.4"/>\n<rect x="19.6" y="34.3" width="60" height="5.4"/>\n<rect x="19.6" y="56.9" width="60" height="5.4"/>\n<rect x="19.6" y="79.6" width="60" height="5.4"/>\n</svg>\n';

  // simulator/img/RAM.svg
  var RAM_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n	<path d="M36.5,18.8v67h27.1v-67H36.5z M38.5,37.5h4.4V44h-4.4V37.5z M44.1,52.5v-7.2h4.6v7.2H44.1z M48.7,53.8v6.5h-4.6v-6.5H48.7z\n	 M38.5,45.3h4.4v7.2h-4.4V45.3z M44.1,44v-6.5h4.6V44H44.1z M38.5,53.8h4.4v6.5h-4.4V53.8z M38.5,61.6h4.4v6.8h-4.4V61.6z\n	 M44.1,61.6h4.6v6.8h-4.6V61.6z M50,61.6h5.1v6.8H50V61.6z M50,60.3v-6.5h5.1v6.5H50z M50,52.5v-7.2h5.1v7.2H50z M50,44v-6.5h5.1V44\n	H50z M50,36.2v-7h5.1v7H50z M50,27.9v-7h5.1v7H50z M48.7,27.9h-4.6v-7h4.6V27.9z M48.7,29.2v7h-4.6v-7H48.7z M42.8,36.2h-4.4v-7h4.4\n	V36.2z M38.5,69.7h4.4v6.5h-4.4V69.7z M44.1,69.7h4.6v6.5h-4.6V69.7z M48.7,77.5v6.3h-4.6v-6.3H48.7z M50,77.5h5.1v6.3H50V77.5z\n	 M50,76.2v-6.5h5.1v6.5H50z M56.4,69.7h5.1v6.5h-5.1V69.7z M56.4,68.4v-6.8h5.1v6.8H56.4z M61.6,60.3h-5.1v-6.5h5.1V60.3z\n	 M56.4,52.5v-7.2h5.1v7.2H56.4z M61.6,44h-5.1v-6.5h5.1V44z M56.4,36.2v-7h5.1v7H56.4z M61.6,27.9h-5.1v-7h5.1V27.9z M42.8,20.8v7\n	h-4.4v-7H42.8z M38.5,77.5h4.4v6.3h-4.4V77.5z M56.4,83.8v-6.3h5.1v6.3H56.4z" />\n	<path d="M24.9,55.7V44.3h3.9c0.9,0,1.6,0.1,2,0.2c0.7,0.2,1.2,0.4,1.7,0.8c0.6,0.5,1.1,1.2,1.4,2c0.3,0.8,0.4,1.7,0.4,2.7\n		c0,0.9-0.1,1.6-0.3,2.3s-0.5,1.2-0.8,1.7c-0.3,0.4-0.7,0.8-1,1c-0.4,0.3-0.8,0.4-1.4,0.6c-0.5,0.1-1.1,0.2-1.8,0.2H24.9z\n		 M26.4,54.4h2.4c0.8,0,1.3-0.1,1.8-0.2s0.8-0.3,1-0.6c0.4-0.4,0.6-0.8,0.8-1.4c0.2-0.6,0.3-1.3,0.3-2.2c0-1.2-0.2-2.1-0.6-2.8\n		c-0.4-0.6-0.9-1.1-1.4-1.3c-0.4-0.2-1.1-0.2-2-0.2h-2.4V54.4z" />\n	<path d="M74.5,54.5c0.7,0.5,1.4,0.8,1.9,1.1L76,56.6c-0.8-0.3-1.6-0.8-2.5-1.4c-0.8,0.5-1.8,0.7-2.8,0.7c-1,0-2-0.2-2.8-0.8\n		s-1.5-1.2-1.9-2.1c-0.5-0.9-0.7-1.9-0.7-3.1c0-1.1,0.2-2.2,0.7-3.1c0.5-0.9,1.1-1.6,2-2.1c0.8-0.5,1.8-0.7,2.8-0.7\n		c1.1,0,2,0.3,2.9,0.8c0.8,0.5,1.5,1.2,1.9,2.1s0.7,1.9,0.7,3.1c0,0.9-0.1,1.8-0.4,2.5C75.5,53.3,75.1,53.9,74.5,54.5z M71.1,52.6\n		c0.9,0.2,1.6,0.6,2.2,1.1c0.9-0.8,1.3-2,1.3-3.7c0-0.9-0.2-1.7-0.5-2.4c-0.3-0.7-0.8-1.2-1.4-1.6c-0.6-0.4-1.3-0.6-2-0.6\n		c-1.1,0-2.1,0.4-2.8,1.2c-0.7,0.8-1.1,1.9-1.1,3.5c0,1.5,0.4,2.6,1.1,3.4c0.7,0.8,1.7,1.2,2.8,1.2c0.5,0,1.1-0.1,1.5-0.3\n		c-0.5-0.3-1-0.5-1.5-0.7L71.1,52.6z" />\n	<path d="M94.9,24.8v-2h-15V6.5H73V0h-1.3v6.5h-12V0h-1.3v6.5H45.2V0h-1.3v6.5H31.3V0H30v6.5H19.9v16.3H5v2h14.9v13.6H5v2h14.9v15H5\n	v2h14.9v14.3H5v2h14.9v15.6h-15v2h15v8.4h60v-26h15v-2h-15V57.4h15v-2h-15v-15h15v-2h-15V24.8H94.9z M22.9,87.3l7.1,3.1l-7.1,3.1\n	V87.3z M76.9,96.7h-54v-1.1L35,90.4l-12.1-5.3V9.5h54V96.7z" />\n</svg>';

  // simulator/img/ROM.svg
  var ROM_default = '<!-- Generator: Adobe Illustrator 26.5.3, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n	<path d="M63.6,18.8H36.5v67h27.1V18.8z M56.4,29.2h5.1v7h-5.1V29.2z M56.4,45.3h5.1v7.2h-5.1V45.3z M38.4,20.8h4.4v7h-4.4V20.8z\n		 M38.4,29.2h4.4v7h-4.4V29.2z M42.9,83.8h-4.4v-6.3h4.4V83.8z M42.9,76.2h-4.4v-6.5h4.4V76.2z M42.9,68.4h-4.4v-6.8h4.4V68.4z\n		 M42.9,60.3h-4.4v-6.5h4.4V60.3z M42.9,52.5h-4.4v-7.2h4.4V52.5z M42.9,44h-4.4v-6.5h4.4V44z M48.7,83.8h-4.6v-6.3h4.6V83.8z\n		 M48.7,76.2h-4.6v-6.5h4.6V76.2z M48.7,68.4h-4.6v-6.8h4.6V68.4z M48.7,60.3h-4.6v-6.5h4.6V60.3z M48.7,52.5h-4.6v-7.2h4.6V52.5z\n		 M48.7,44h-4.6v-6.5h4.6V44z M48.7,36.2h-4.6v-7h4.6V36.2z M48.7,27.9h-4.6v-7h4.6V27.9z M55.1,83.8H50v-6.3h5.1V83.8z M55.1,76.2\n		H50v-6.5h5.1V76.2z M55.1,68.4H50v-6.8h5.1V68.4z M55.1,60.3H50v-6.5h5.1V60.3z M55.1,52.5H50v-7.2h5.1V52.5z M55.1,44H50v-6.5h5.1\n		V44z M55.1,36.2H50v-7h5.1V36.2z M55.1,27.9H50v-7h5.1V27.9z M61.5,83.8h-5.1v-6.3h5.1V83.8z M61.5,76.2h-5.1v-6.5h5.1V76.2z\n		 M61.5,68.4h-5.1v-6.8h5.1V68.4z M61.6,60.3h-5.1v-6.5h5.1V60.3z M61.6,44h-5.1v-6.5h5.1V44z M61.6,27.9h-5.1v-7h5.1V27.9z" />\n	<path d="M94.9,24.8v-2h-15V6.5H73V0h-1.3v6.5h-12V0h-1.3v6.5H45.2V0h-1.3v6.5H31.3V0H30v6.5H19.9v16.3v2v13.6v2v15v2v14.3v2v15.6v2\n		v8.4h60v-26h15v-2h-15V57.4h15v-2h-15v-15h15v-2h-15V24.8H94.9z M76.9,96.7h-54v-1.1V85.1V9.5h54V96.7z" />\n</svg>';

  // simulator/img/Random.svg
  var Random_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n<g transform="translate(0.000000,1280.000000) scale(0.100000,-0.100000)">\n	<path d="M475.9,12730c-2.1-0.8-339.2-191.5-340.3-192.6c-0.4-0.4-0.3-0.9,0.3-1.5c0.5-0.5,51.6-25,113.5-54.4\n		c61.9-29.5,147.6-70.2,190.3-90.5c61.1-29.1,78.5-37.1,81.1-37.4c2.8-0.3,4-0.1,7.5,1.7c3.3,1.7,318.8,200.6,331.3,208.9\n		c3.9,2.6,4.7,3.6,3.9,4.9c-0.4,0.7-27,12-158.6,68c-10.5,4.5-63.2,26.8-116.9,49.7c-53.7,22.8-99.4,42.1-101.5,42.8\n		C482.3,12730.9,478.9,12731,475.9,12730z M482.4,12692c25.7-3.4,43.5-15.6,43.5-29.7c0-13-15.4-25.3-37.8-30.1\n		c-33.4-7.2-69.1,2-78.6,20.1c-2.4,4.5-2.4,11.2-0.3,15.7c4.2,8.4,14.4,15.8,28.5,20.3C451,12692.6,467.4,12694,482.4,12692z\n		 M537.5,12470.6c28.3-2.5,48.1-14.9,48.2-30c0.1-14-15.9-26-41.4-31c-8.9-1.8-27.3-2.1-35.6-0.7c-20.3,3.5-34,11.1-39.1,21.6\n		c-1.9,3.8-2.1,4.8-1.8,8.7c0.3,6,2.4,9.9,7.8,15C488.1,12466.1,513.5,12472.8,537.5,12470.6z"/>\n	<path d="M875.5,12541.5c-12.7-8-299.1-189-315.1-199.1c-10-6.4-19.6-12.8-21.3-14.4l-3.2-2.8v-4.9c0-2.7,0.7-54.9,1.7-115.9\n		s2.3-152.7,3-203.9c1.7-123.7,1.5-116.5,3.6-116.5c0.9,0,330.4,219.1,334.9,222.7c1.4,1.2,3,2.8,3.4,3.8\n		c0.7,1.3,0.7,43.6,0.4,217.8c-0.3,191.4-0.5,216.2-1.4,216.3C880.9,12544.6,878.2,12543.3,875.5,12541.5z M852.7,12462.6\n		c10.3-5,15.3-16.2,14.6-33c-1.5-32.6-26.4-67.1-52.4-72.6c-6-1.3-10.7-0.7-16,1.9c-6.5,3.1-11.3,9.9-13.5,19.1\n		c-1.2,5-1,18.3,0.3,24.4c6.6,29.7,27.4,55.7,49.7,61.7C841.7,12465.7,847.2,12465.3,852.7,12462.6z M754.6,12262.5\n		c6.4-3.3,11.5-10.5,13.6-19.1c0.5-2.2,0.9-7,0.9-11.9c-0.1-9.3-1.9-18.1-5.5-27.3c-7.9-20.1-22.2-36.9-37.3-44.1\n		c-7-3.3-11.3-4.3-17.3-3.9c-11.2,0.8-19.2,8.7-22,21.9c-1.5,6.8-0.9,19.3,1.3,27.7c7,26.7,26.3,50.6,46.3,57.3\n		C741.3,12265.3,749.7,12265.1,754.6,12262.5z M642.9,12056.5c7.4-2.2,13.2-8.1,16.1-16.4c2.1-5.8,2.6-19.9,1.1-27.7\n		c-5.8-29.1-27-56.2-49-62.5c-5.8-1.7-14.2-1.1-18.6,1.1c-5.7,2.9-9.6,7.9-12.4,15.7c-1.9,5.4-2.4,18.9-0.9,26.7\n		c2.3,11.8,8.3,26.2,15.5,36.3c4,5.7,13.4,15.3,18.4,18.9C623.4,12056.1,634.5,12059,642.9,12056.5z"/>\n	<path d="M118.7,12510.8c0-0.9,1.2-38.1,2.6-83c5.2-160.1,6.6-204.1,8.5-265.2c2.6-83.4,2.4-79.3,4.6-81.4\n		c1.9-1.9,376.6-198,378.4-198c0.6,0,1.3,0.4,1.5,0.9c0.4,1-5.4,406.4-6.1,428.7l-0.4,12.8l-2.1,2.2c-1.6,1.7-24.8,13-106.7,52\n		c-57.5,27.3-143.7,68.3-191.5,91c-47.7,22.7-87.3,41.3-87.9,41.3C119.1,12512.3,118.7,12511.7,118.7,12510.8z M299.3,12246.2\n		c8.1-2.8,14.8-7.2,22.8-15.2c22.6-22.5,32.6-57.2,22.6-78.5c-11.9-25.2-46.5-17.1-68.5,15.9c-19.1,28.7-20.1,63.5-2.3,75.6\n		c4.7,3.2,7.6,4,14,4C292.8,12248.1,294.8,12247.8,299.3,12246.2z"/>\n</g>\n</svg>\n';

  // simulator/img/Rectangle.svg
  var Rectangle_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n	<path fill="#888888" fill-opacity="0.3" d="M78.1,86.4H21.2c-4.4,0-8-3.6-8-8V21.6c0-4.4,3.6-8,8-8h56.9c4.4,0,8,3.6,8,8v56.9\n		C86.1,82.9,82.5,86.4,78.1,86.4z" />\n	<path d="M78.1,88.4H21.2c-5.5,0-10-4.5-10-10V21.6c0-5.5,4.5-10,10-10h56.9c5.5,0,10,4.5,10,10v56.9C88.1,84,83.6,88.4,78.1,88.4z\n		 M21.2,15.6c-3.3,0-6,2.7-6,6v56.8c0,3.3,2.7,6,6,6h56.9c3.3,0,6-2.6,6-5.9V21.6c0-3.3-2.7-6-6-6H21.2z" />\n</svg>';

  // simulator/img/Register.svg
  var Register_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n	<path d="M40.7,16.4v67h20.1v-67H40.7z M58.8,18.4v15.2H42.7V18.4H58.8z M42.7,50V35.1h16.1V50H42.7z M58.8,51.5v14.4H42.7V51.5H58.8\n	z M42.7,81.4V67.3h16.1v14.1H42.7z" />\n	<path d="M26.3,50.4V38.9h3.9c0.9,0,1.6,0.1,2,0.2c0.7,0.2,1.2,0.4,1.7,0.8c0.6,0.5,1.1,1.2,1.4,2c0.3,0.8,0.4,1.7,0.4,2.7\n		c0,0.9-0.1,1.6-0.3,2.3s-0.5,1.2-0.8,1.7c-0.3,0.4-0.7,0.8-1,1c-0.4,0.3-0.8,0.4-1.4,0.6c-0.5,0.1-1.1,0.2-1.8,0.2H26.3z M27.9,49\n		h2.4c0.8,0,1.3-0.1,1.8-0.2s0.8-0.3,1-0.6c0.4-0.4,0.6-0.8,0.8-1.4c0.2-0.6,0.3-1.3,0.3-2.2c0-1.2-0.2-2.1-0.6-2.8\n		c-0.4-0.6-0.9-1.1-1.4-1.3c-0.4-0.2-1.1-0.2-2-0.2h-2.4V49z" />\n	<path d="M72.8,49.2c0.7,0.5,1.4,0.8,1.9,1.1l-0.4,1.1c-0.8-0.3-1.6-0.8-2.5-1.4c-0.8,0.5-1.8,0.7-2.8,0.7c-1,0-2-0.2-2.8-0.8\n		s-1.5-1.2-1.9-2.1c-0.5-0.9-0.7-1.9-0.7-3.1c0-1.1,0.2-2.2,0.7-3.1c0.5-0.9,1.1-1.6,2-2.1c0.8-0.5,1.8-0.7,2.8-0.7\n		c1.1,0,2,0.3,2.9,0.8c0.8,0.5,1.5,1.2,1.9,2.1s0.7,1.9,0.7,3.1c0,0.9-0.1,1.8-0.4,2.5C73.8,47.9,73.4,48.6,72.8,49.2z M69.5,47.2\n		c0.9,0.2,1.6,0.6,2.2,1.1c0.9-0.8,1.3-2,1.3-3.7c0-0.9-0.2-1.7-0.5-2.4c-0.3-0.7-0.8-1.2-1.4-1.6c-0.6-0.4-1.3-0.6-2-0.6\n		c-1.1,0-2.1,0.4-2.8,1.2c-0.7,0.8-1.1,1.9-1.1,3.5c0,1.5,0.4,2.6,1.1,3.4c0.7,0.8,1.7,1.2,2.8,1.2c0.5,0,1.1-0.1,1.5-0.3\n		c-0.5-0.3-1-0.5-1.5-0.7L69.5,47.2z" />\n	<path d="M95,22.4v-2H80v-18H20v18H5.1v2H20V36H5.1v2H20v15H5.1v2H20v14.3H5.1v2H20v17.6H5v2h15v8.3h60V71.3h15v-2H80V55h15v-2H80V38\n	h15v-2H80V22.4H95z M23,86.9l7.1,3.1L23,93.1V86.9z M77,96.2H23v-0.9L35.1,90L23,84.7V5.4h54V96.2z" />\n</svg>';

  // simulator/img/ShiftDisplay.svg
  var ShiftDisplay_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 100 60.5" style="enable-background:new 0 0 100 60.5;" fill="currentColor">\n	<path d="M17.9,15.7h3.7c0.8,0,1.5,0.1,1.9,0.2c0.6,0.2,1.1,0.5,1.5,0.9s0.7,1,1,1.6c0.2,0.6,0.3,1.4,0.3,2.4c0,0.8-0.1,1.5-0.3,2.1\n		c-0.3,0.7-0.6,1.3-1.1,1.8c-0.4,0.3-0.8,0.6-1.4,0.8c-0.4,0.1-1,0.2-1.8,0.2h-3.8V15.7z M19.9,17.4V24h1.5c0.6,0,1,0,1.2-0.1\n		c0.3-0.1,0.6-0.2,0.8-0.4s0.4-0.5,0.5-1c0.1-0.4,0.2-1.1,0.2-1.8s-0.1-1.4-0.2-1.8s-0.3-0.7-0.6-1s-0.6-0.4-0.9-0.5\n		c-0.3-0.1-0.8-0.1-1.7-0.1H19.9z" />\n	<path d="M13,10v8.5H5v2h8V40H5v2h8v9.6h83.3V10H13z M16,36.5l8.7,3.8L16,44.1V36.5z M93.3,48.6H16V46l0.1,0.2l13.6-5.9l-13.6-5.9\n	L16,34.6V13h77.3V48.6z" />\n	<g fill="#8888ff" fill-opacity="1">\n		<path d="M43.4,38.9h-3.3V27.5h-3.9v-2.2c1,0,1.7-0.1,2.1-0.2c0.7-0.1,1.2-0.4,1.6-0.9c0.3-0.3,0.5-0.7,0.6-1.2\n		c0.1-0.3,0.1-0.5,0.1-0.7h2.7V38.9z" />\n		<path d="M53.9,39.3c-2.1,0-3.6-0.7-4.4-2.2c-0.8-1.5-1.3-3.6-1.3-6.3s0.4-4.8,1.3-6.3c0.8-1.5,2.3-2.2,4.4-2.2\n		c2.1,0,3.6,0.7,4.4,2.2c0.8,1.5,1.3,3.6,1.3,6.3s-0.4,4.8-1.3,6.3C57.5,38.5,56,39.3,53.9,39.3z M55.8,35.1c0.3-1,0.4-2.4,0.4-4.3\n		c0-2-0.1-3.5-0.4-4.4S54.9,25,53.9,25c-1,0-1.6,0.5-1.9,1.4s-0.5,2.4-0.5,4.4c0,1.9,0.2,3.3,0.5,4.3s0.9,1.5,1.9,1.5\n		C54.9,36.6,55.5,36.1,55.8,35.1z" />\n		<path d="M69.3,38.9H66V27.5h-3.9v-2.2c1,0,1.7-0.1,2.1-0.2c0.7-0.1,1.2-0.4,1.6-0.9c0.3-0.3,0.5-0.7,0.6-1.2\n		c0.1-0.3,0.1-0.5,0.1-0.7h2.7V38.9z" />\n		<path d="M79.8,39.3c-2.1,0-3.6-0.7-4.4-2.2s-1.3-3.6-1.3-6.3s0.4-4.8,1.3-6.3s2.3-2.2,4.4-2.2c2.1,0,3.6,0.7,4.4,2.2\n		c0.8,1.5,1.3,3.6,1.3,6.3s-0.4,4.8-1.3,6.3C83.4,38.5,81.9,39.3,79.8,39.3z M81.7,35.1c0.3-1,0.4-2.4,0.4-4.3c0-2-0.1-3.5-0.4-4.4\n		S80.8,25,79.8,25c-1,0-1.6,0.5-1.9,1.4s-0.5,2.4-0.5,4.4c0,1.9,0.2,3.3,0.5,4.3s0.9,1.5,1.9,1.5C80.8,36.6,81.4,36.1,81.7,35.1z" />\n	</g>\n</svg>';

  // simulator/img/ShiftRegister.svg
  var ShiftRegister_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n	<path d="M60.8,83.4H40.7v-67h20.1V83.4z M42.7,81.4h16.1v-63H42.7V81.4z" />\n	<path d="M26.3,42.2V30.8h3.9c0.9,0,1.6,0.1,2,0.2c0.7,0.2,1.2,0.4,1.7,0.8c0.6,0.5,1.1,1.2,1.4,2c0.3,0.8,0.4,1.7,0.4,2.7\n		c0,0.9-0.1,1.6-0.3,2.3S35,40,34.7,40.4c-0.3,0.4-0.7,0.8-1,1c-0.4,0.3-0.8,0.4-1.4,0.6c-0.5,0.1-1.1,0.2-1.8,0.2H26.3z M27.9,40.9\n		h2.4c0.8,0,1.3-0.1,1.8-0.2s0.8-0.3,1-0.6c0.4-0.4,0.6-0.8,0.8-1.4c0.2-0.6,0.3-1.3,0.3-2.2c0-1.2-0.2-2.1-0.6-2.8\n		c-0.4-0.6-0.9-1.1-1.4-1.3c-0.4-0.2-1.1-0.2-2-0.2h-2.4V40.9z" />\n	<path d="M26.3,79V67.6h1.5v10.1h3.6V79H26.3z" />\n	<path d="M32.3,79V67.6h2.1c1,0,1.3,0.1,1.9,0.3s1,0.6,1.3,1.1s0.5,1.1,0.5,1.7c0,0.8-0.3,1.5-0.8,2.1s-0.9,0.9-2,1.1\n	c0.4,0.2,0.7,0.4,0.9,0.6c0.4,0.4,0.5,0.8,0.8,1.5l1.2,3.1h-1.9l-0.7-2.4c-0.2-0.8-0.3-1.2-0.6-1.6s-0.5-0.6-0.8-0.8\n	S33.6,74,33.4,74c-0.2,0-0.5-0.1-0.8-0.1h1.2V79H32.3z M33.8,72.6H34c0.7,0,0.8-0.1,1.2-0.2s0.7-0.4,0.9-0.7s0.3-0.7,0.3-1\n	c0-0.5-0.2-1-0.6-1.3c-0.4-0.3-0.6-0.5-1.4-0.5h-0.6C33.8,68.9,33.8,72.6,33.8,72.6z" />\n	<path d="M72.8,49.2c0.7,0.5,1.4,0.8,1.9,1.1l-0.4,1.1c-0.8-0.3-1.6-0.8-2.5-1.4c-0.8,0.5-1.8,0.7-2.8,0.7c-1,0-2-0.2-2.8-0.8\n		s-1.5-1.2-1.9-2.1c-0.5-0.9-0.7-1.9-0.7-3.1c0-1.1,0.2-2.2,0.7-3.1c0.5-0.9,1.1-1.6,2-2.1c0.8-0.5,1.8-0.7,2.8-0.7\n		c1.1,0,2,0.3,2.9,0.8c0.8,0.5,1.5,1.2,1.9,2.1s0.7,1.9,0.7,3.1c0,0.9-0.1,1.8-0.4,2.5C73.8,47.9,73.4,48.6,72.8,49.2z M69.5,47.2\n		c0.9,0.2,1.6,0.6,2.2,1.1c0.9-0.8,1.3-2,1.3-3.7c0-0.9-0.2-1.7-0.5-2.4c-0.3-0.7-0.8-1.2-1.4-1.6c-0.6-0.4-1.3-0.6-2-0.6\n		c-1.1,0-2.1,0.4-2.8,1.2c-0.7,0.8-1.1,1.9-1.1,3.5c0,1.5,0.4,2.6,1.1,3.4c0.7,0.8,1.7,1.2,2.8,1.2c0.5,0,1.1-0.1,1.5-0.3\n		c-0.5-0.3-1-0.5-1.5-0.7L69.5,47.2z" />\n	<path d="M95,22.4v-2H80v-18H20V36H5.1v2H20v34.6H5.1v2H20v14.3H5v2h15v8.3h60V71.3h15v-2H80V55h15v-2H80V38.7h15v-2H80V22.4H95z\n	 M23,86.9l7.1,3.1L23,93.1V86.9z M77,96.2H23v-0.9L35.1,90L23,84.7V5.4h54V96.2z" />\n	<polygon points="56,52.3 54.6,53.3 54.6,39.2 52.6,39.2 52.6,54.7 50.9,56 49,54.7 49,39.2 47,39.2 47,53.3 45.5,52.3 44.3,53.9 \n	50.9,58.4 57.2,53.9 " />\n	<rect x="26.2" y="65.9" width="5.1" height="1" />\n</svg>';

  // simulator/img/TristateBufferArray.svg
  var TristateBufferArray_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" fill="currentColor">\n<path d="M88.4,26.1v-2H73.2V11.9H51.8V5.5h-2v6.4H28.4v12.2H13.2v2h15.2v14.2H13.2v2h15.2v14.2H13.2v2h15.2v14.2H13.2v2h15.2v12.1\n	h44.8V74.7h15.2v-2H73.2V58.5h15.2v-2H73.2V42.3h15.2v-2H73.2V26.1H88.4z M70.2,83.8H31.4V14.9h18.4v27l-10-5.3v27.7l25.1-14.4\n	l-13.1-7v-28h18.4V83.8z M60.7,49.9L41.8,60.8V39.9L60.7,49.9z"/>\n</svg>\n';

  // simulator/img/and.svg
  var and_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n<path d="M95,24H70.4c-0.5-10.5-9-19-20-19H30v9H5v2h25v18H5v2h25v9h20.5c10.9,0,19.4-8.5,20-19H95V24z M50,42.1H32.9V7.9h17.6\n	c9.8,0,16.7,7.6,16.7,17.1S59.8,42.1,50,42.1z"/>\n</svg>\n';

  // simulator/img/and3.svg
  var and3_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n<path d="M95,24H70.5c-0.5-10.5-9-19-20-19H30v9H5v2h25v7.9H5v2h25V34H5v2h25v9h20.5c11,0,19.4-8.5,20-19H95V24z M50,42.1H32.9V7.9\n	h17.6c9.8,0,16.7,7.6,16.7,17.1S59.8,42.1,50,42.1z"/>\n</svg>\n';

  // simulator/img/and4.svg
  var and4_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n<path d="M95,24H70.5c-0.5-10.5-9-19-20-19H30v4.1H5v2h25v7.7H5v2h25v8.3H5v2h25v7.7H5v2h25V45h20.5c11,0,19.4-8.5,20-19H95V24z\n	 M50,42.1H32.9V7.9h17.6c9.8,0,16.7,7.6,16.7,17.1S59.8,42.1,50,42.1z"/>\n</svg>\n';

  // simulator/img/buf.svg
  var buf_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n<path d="M95,24H72.9L31.1,3.7L29,2.6V24H5v2h24v21.4l2.2-1.1L72.5,26H95V24z M32,42.6V7.4L68.1,25L32,42.6z"/>\n</svg>\n';

  // simulator/img/imply.svg
  var imply_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n<path d="M95,24H72.4C62.1,5.2,46,5,41.2,5H24.1l2,2.4c0,0,0.8,1,1.8,2.7C27,9.7,26.1,9.4,25,9.4c-2.7,0-5,2-5.4,4.6H5v2h14.6\n	c0.5,2.5,2.7,4.4,5.4,4.4c2.6,0,4.8-1.9,5.4-4.3c0.8,2.5,1.4,5.6,1.4,9c0,3.4-0.6,6.4-1.4,9H5v2h24.7c-1.6,4.1-3.6,6.6-3.6,6.6\n	l-2,2.4h17.2c2.4,0,7.7,0,13.6-2.4c5.9-2.4,12.4-7.3,17.5-16.6H95V24z M25,17.4c-1.4,0-2.5-1.1-2.5-2.5s1.1-2.5,2.5-2.5\n	s2.5,1.1,2.5,2.5S26.4,17.4,25,17.4z M53.5,39.8C48.1,42,43.7,42,41.2,42H30c1.9-3.1,4.8-9,4.8-17c0-8-2.9-13.9-4.8-17h11.3\n	c4.7,0,18.3-0.1,28,17C64.5,33.4,58.7,37.7,53.5,39.8z"/>\n</svg>\n';

  // simulator/img/nand.svg
  var nand_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n<path d="M95,24H80.4c-0.5-2.6-2.7-4.5-5.4-4.5c-2,0-3.8,1.1-4.7,2.7C68.9,12.5,60.8,5,50.5,5H30v9H5v2h25v18H5v2h25v9h20.5\n	c10.3,0,18.5-7.5,19.8-17.2c1,1.6,2.7,2.7,4.7,2.7c2.7,0,4.9-1.9,5.4-4.5H95V24z M50,42.1H32.9V7.9h17.6c9.8,0,16.7,7.6,16.7,17.1\n	S59.8,42.1,50,42.1z M75,27.5c-1.4,0-2.5-1.1-2.5-2.5c0-1.4,1.1-2.5,2.5-2.5s2.5,1.1,2.5,2.5C77.5,26.4,76.4,27.5,75,27.5z"/>\n</svg>\n';

  // simulator/img/nand3.svg
  var nand3_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n<path d="M95,24H80.4c-0.5-2.6-2.7-4.5-5.4-4.5c-2,0-3.8,1.1-4.7,2.7C68.9,12.5,60.8,5,50.5,5H30v9H5v2h25v7.7H5v2h25V34H5v2h25v9\n	h20.5c10.3,0,18.4-7.5,19.8-17.2c1,1.6,2.7,2.7,4.7,2.7c2.7,0,4.9-1.9,5.4-4.5H95V24z M50,42.1H32.9V7.9h17.6\n	c9.8,0,16.7,7.6,16.7,17.1S59.8,42.1,50,42.1z M75,27.5c-1.4,0-2.5-1.1-2.5-2.5c0-1.4,1.1-2.5,2.5-2.5s2.5,1.1,2.5,2.5\n	C77.5,26.4,76.4,27.5,75,27.5z"/>\n</svg>\n';

  // simulator/img/nand4.svg
  var nand4_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n<path d="M95,24H80.4c-0.5-2.6-2.7-4.5-5.4-4.5c-2,0-3.8,1.1-4.7,2.7C68.9,12.5,60.8,5,50.5,5H30v3.8H5v2h25v8H5v2h25v8H5v2h25v8H5v2\n	h25V45h20.5c10.3,0,18.4-7.5,19.8-17.2c1,1.6,2.7,2.7,4.7,2.7c2.7,0,4.9-1.9,5.4-4.5H95V24z M50,42.1H32.9V7.9h17.6\n	c9.8,0,16.7,7.6,16.7,17.1S59.8,42.1,50,42.1z M75,27.5c-1.4,0-2.5-1.1-2.5-2.5c0-1.4,1.1-2.5,2.5-2.5s2.5,1.1,2.5,2.5\n	C77.5,26.4,76.4,27.5,75,27.5z"/>\n</svg>\n';

  // simulator/img/nimply.svg
  var nimply_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n<path d="M95,24H70.4c-0.5-10.5-9-19-20-19H30v9H5v2h25v15.9c-1-1.4-2.6-2.3-4.5-2.3c-2.7,0-4.9,1.9-5.4,4.5H5v2h15.1\n	c0.5,2.6,2.7,4.5,5.4,4.5c1.9,0,3.5-0.9,4.5-2.3V45h20.5c10.9,0,19.4-8.5,20-19H95V24z M25.5,37.5c-1.4,0-2.5-1.1-2.5-2.5\n	s1.1-2.5,2.5-2.5S28,33.6,28,35S26.9,37.5,25.5,37.5z M50,42.1H32.9V7.9h17.6c9.8,0,16.7,7.6,16.7,17.1S59.8,42.1,50,42.1z"/>\n</svg>\n';

  // simulator/img/nor.svg
  var nor_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n<path d="M95,24H80.4c-0.5-2.6-2.7-4.5-5.4-4.5c-1.7,0-3.1,0.7-4.1,1.9C60.5,5.2,45.8,5,41.2,5H24.1l2,2.4c0,0,1.9,2.4,3.6,6.6H5v2\n	h25.4c0.8,2.6,1.4,5.6,1.4,9c0,3.4-0.6,6.4-1.4,9H5v2h24.7c-1.6,4.1-3.6,6.6-3.6,6.6l-2,2.4h17.2c2.4,0,7.7,0,13.6-2.4\n	c5.3-2.2,11.1-6.3,16-14c1,1.2,2.5,1.9,4.1,1.9c2.7,0,4.9-1.9,5.4-4.5H95V24z M53.5,39.8C48.1,42,43.7,42,41.2,42H30\n	c1.9-3.1,4.8-9,4.8-17c0-8-2.9-13.9-4.8-17h11.3c4.7,0,18.3-0.1,28,17C64.5,33.4,58.7,37.7,53.5,39.8z M75,27.5\n	c-1.4,0-2.5-1.1-2.5-2.5c0-1.4,1.1-2.5,2.5-2.5s2.5,1.1,2.5,2.5C77.5,26.4,76.4,27.5,75,27.5z"/>\n</svg>\n';

  // simulator/img/nor3.svg
  var nor3_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n<path d="M95,24H80.4c-0.5-2.6-2.7-4.5-5.4-4.5c-1.7,0-3.2,0.8-4.2,1.9C60.6,5.2,45.7,5,41.2,5H24.1l2,2.4c0,0,2,2.4,3.6,6.6H5v2\n	h25.4c0.7,2.3,1.2,4.9,1.4,7.9H5v2h26.8c-0.1,3-0.6,5.8-1.4,8.1H5v2h24.7c-1.6,4.2-3.6,6.6-3.6,6.6l-2,2.4h17.2\n	c2.4,0,7.7,0,13.6-2.4c5.3-2.1,11.1-6.3,16-14c1,1.1,2.5,1.9,4.1,1.9c2.7,0,4.9-1.9,5.4-4.5H95V24z M53.6,39.8\n	C48.1,42,43.7,42,41.2,42H30c1.9-3.1,4.8-9,4.8-17s-3-13.9-4.8-17h11.3c4.7,0,18.3-0.1,28,17C64.5,33.4,58.8,37.7,53.6,39.8z\n	 M75,27.5c-1.4,0-2.5-1.1-2.5-2.5c0-1.4,1.1-2.5,2.5-2.5s2.5,1.1,2.5,2.5C77.5,26.4,76.4,27.5,75,27.5z"/>\n</svg>\n';

  // simulator/img/nor4.svg
  var nor4_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n<path d="M29.5,41H5v-2h24.5V41z M32,30.9H5v-2h27V30.9z M95,26H79v-2h16V26z M32.8,21H5v-2h27.8V21z M29.4,10.9H5v-2h24.4V10.9z"/>\n<path d="M24.1,5l2,2.4c0,0,5.7,7,5.7,17.6s-5.7,17.6-5.7,17.6l-2,2.4h17.2c2.4,0,7.7,0,13.6-2.4s12.5-7.3,17.7-16.9L71.2,25l1.3-0.7\n	C62.3,5.2,46,5,41.2,5H24.1z M30,8h11.3c4.7,0,18.3-0.1,28,17c-4.8,8.4-10.5,12.7-15.7,14.8C48.1,42,43.7,42,41.2,42H30\n	c1.9-3.1,4.8-9,4.8-17S31.8,11.1,30,8z"/>\n<path d="M75,30.5c-3,0-5.5-2.5-5.5-5.5c0-3,2.5-5.5,5.5-5.5s5.5,2.5,5.5,5.5C80.5,28,78,30.5,75,30.5z M75,22.5\n	c-1.4,0-2.5,1.1-2.5,2.5c0,1.4,1.1,2.5,2.5,2.5s2.5-1.1,2.5-2.5C77.5,23.6,76.4,22.5,75,22.5z"/>\n</svg>\n';

  // simulator/img/not.svg
  var not_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n<path d="M95,24H80.4c-0.5-2.6-2.7-4.5-5.4-4.5c-2.2,0-4.1,1.3-5,3.1l-38.9-19L29,2.6V24H5v2H29v21.4l2.2-1.1l38.9-19\n	c0.9,1.8,2.8,3.1,5,3.1c2.7,0,4.9-1.9,5.4-4.5H95V24z M32,42.6V7.4L68.1,25L32,42.6z M75,27.5c-1.4,0-2.5-1.1-2.5-2.5\n	c0-1.4,1.1-2.5,2.5-2.5s2.5,1.1,2.5,2.5C77.5,26.4,76.4,27.5,75,27.5z"/>\n</svg>\n';

  // simulator/img/or.svg
  var or_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n<path d="M95,24H72.4C62.1,5.2,46,5,41.2,5H24.1l2,2.4c0,0,1.9,2.4,3.6,6.6H5v2h25.4c0.8,2.6,1.4,5.6,1.4,9\n	c0,3.4-0.6,6.4-1.4,9H5v2h24.7c-1.6,4.1-3.6,6.6-3.6,6.6l-2,2.4h17.2c2.4,0,7.7,0,13.6-2.4c5.9-2.4,12.4-7.3,17.5-16.6H95V24z\n	 M53.5,39.8C48.1,42,43.7,42,41.2,42H30c1.9-3.1,4.8-9,4.8-17c0-8-2.9-13.9-4.8-17h11.3c4.7,0,18.3-0.1,28,17\n	C64.5,33.4,58.7,37.7,53.5,39.8z"/>\n</svg>\n';

  // simulator/img/or3.svg
  var or3_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n<path d="M95,24H72.3C62.1,5.2,46,5,41.2,5H24.1l2,2.4c0,0,2,2.4,3.6,6.6H5v2h25.4c0.7,2.3,1.3,5,1.4,8H5v2h26.8\n	c-0.1,3-0.6,5.7-1.4,8H5v2h24.7c-1.6,4.2-3.6,6.6-3.6,6.6l-2,2.4h17.2c2.4,0,7.7,0,13.6-2.4c5.8-2.4,12.4-7.2,17.5-16.6H95V24z\n	 M53.6,39.8C48.1,42,43.7,42,41.2,42H30c1.9-3.1,4.8-9,4.8-17s-3-13.9-4.8-17h11.3c4.7,0,18.3-0.1,28,17\n	C64.5,33.4,58.8,37.7,53.6,39.8z"/>\n</svg>\n';

  // simulator/img/or4.svg
  var or4_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n<path d="M95,24H72.3C62.1,5.2,46,5,41.2,5H24.1l2,2.4c0,0,0.4,0.5,1,1.5H5v2h23.3c1,2,2.2,4.7,2.9,8H5v2h26.5\n	c0.2,1.3,0.3,2.7,0.3,4.1c0,1.4-0.1,2.7-0.3,3.9H5v2h26.2c-0.7,3.3-1.8,6-2.8,8H5v2h22.3c-0.7,1.1-1.2,1.7-1.2,1.7l-2,2.4h17.2\n	c2.4,0,7.7,0,13.6-2.4c5.8-2.4,12.4-7.2,17.5-16.6H95V24z M53.6,39.8C48.1,42,43.7,42,41.2,42H30c1.9-3.1,4.8-9,4.8-17\n	s-3-13.9-4.8-17h11.3c4.7,0,18.3-0.1,28,17C64.5,33.4,58.8,37.7,53.6,39.8z"/>\n</svg>\n';

  // simulator/img/tri.svg
  var tri_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n<path d="M95,24H72.9L51,13.4v-23.5h-2v22.5L31.1,3.7L29,2.6V24H5v2h24v21.4l2.2-1.1L72.5,26H95V24z M32,42.6V7.4L68.1,25L32,42.6z"\n	/>\n</svg>\n';

  // simulator/img/txa.svg
  var txa_default = '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n	 viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n<path d="M95,24H70.5L29.9,4.3V14H5v2h24.9v18H5v2h24.9v10.4L70.8,26H95V24z M63.6,24H32.9V9.2L63.6,24z M32.9,41.5V26H64L32.9,41.5z\n	"/>\n</svg>\n';

  // simulator/img/xnor.svg
  var xnor_default = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n  <rect x="5" y="14" width="20.7" height="2"/>\n  <rect x="5" y="34.1" width="20.7" height="2"/>\n  <rect x="80" y="24" width="15" height="2"/>\n  <path d="M21.7,44.8l-2.4-1.7c5.1-7.1,7-11.9,7-17.9s-2.3-12.2-6.9-17.9l2.3-1.9c5.1,6.3,7.6,12.7,7.6,19.8s-2.1,12.1-7.5,19.7h-.1Z"/>\n  <path d="M24.9,44.9l1.6-2.3c2.1-3.1,5.5-9.5,5.3-18-.1-7.6-3-13.3-5.3-16.8l-1.6-2.3h20c15.2,0,23.4,13,26.5,17.9.3.4.5.8.6,1l.6.8-.6.8c-.2.2-.4.6-.6,1-2.8,4.5-11.5,18.1-27.1,18.1M68.7,24.8c-2.8-4.5-10.3-16.5-23.9-16.5h-14.5c2.2,3.9,4.3,9.3,4.4,16.1,0,7.6-2.3,13.6-4.4,17.4h0c0,.1,14,.1,14,.1,13.9,0,21.6-12.2,24.5-16.7"/>\n  <path d="M76,30.6c-3.1,0-5.6-2.5-5.6-5.6s2.5-5.6,5.6-5.6,5.6,2.5,5.6,5.6-2.5,5.6-5.6,5.6ZM76,22.4c-1.4,0-2.6,1.2-2.6,2.6s1.2,2.6,2.6,2.6,2.6-1.2,2.6-2.6-1.2-2.6-2.6-2.6Z"/>\n</svg>';

  // simulator/img/xnor3.svg
  var xnor3_default = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n  <rect x="5" y="14" width="20.7" height="2"/>\n  <rect x="5" y="24" width="23" height="2"/>\n  <rect x="5" y="34.1" width="20.7" height="2"/>\n  <rect x="80" y="24" width="15" height="2"/>\n  <path d="M21.7,44.8l-2.4-1.7c5.1-7.1,7-11.9,7-17.9s-2.3-12.2-6.9-17.9l2.3-1.9c5.1,6.3,7.6,12.7,7.6,19.8s-2.1,12.1-7.5,19.7h-.1Z"/>\n  <path d="M24.9,44.9l1.6-2.3c2.1-3.1,5.5-9.5,5.3-18-.1-7.6-3-13.3-5.3-16.8l-1.6-2.3h20c15.2,0,23.4,13,26.5,17.9.3.4.5.8.6,1l.6.8-.6.8c-.2.2-.4.6-.6,1-2.8,4.5-11.5,18.1-27.1,18.1M68.7,24.8c-2.8-4.5-10.3-16.5-23.9-16.5h-14.5c2.2,3.9,4.3,9.3,4.4,16.1,0,7.6-2.3,13.6-4.4,17.4h0c0,.1,14,.1,14,.1,13.9,0,21.6-12.2,24.5-16.7"/>\n  <path d="M76,30.6c-3.1,0-5.6-2.5-5.6-5.6s2.5-5.6,5.6-5.6,5.6,2.5,5.6,5.6-2.5,5.6-5.6,5.6ZM76,22.4c-1.4,0-2.6,1.2-2.6,2.6s1.2,2.6,2.6,2.6,2.6-1.2,2.6-2.6-1.2-2.6-2.6-2.6Z"/>\n</svg>';

  // simulator/img/xnor4.svg
  var xnor4_default = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n  <rect x="5" y="9.2" width="18" height="2"/>\n  <rect x="5" y="19.2" width="22.2" height="2"/>\n  <rect x="5" y="29.3" width="22.2" height="2"/>\n  <rect x="5" y="39.4" width="18" height="2"/>\n  <rect x="80" y="24" width="15" height="2"/>\n  <path d="M21.7,44.8l-2.4-1.7c5.1-7.1,7-11.9,7-17.9s-2.3-12.2-6.9-17.9l2.3-1.9c5.1,6.3,7.6,12.7,7.6,19.8s-2.1,12.1-7.5,19.7h-.1Z"/>\n  <path d="M24.9,44.9l1.6-2.3c2.1-3.1,5.5-9.5,5.3-18-.1-7.6-3-13.3-5.3-16.8l-1.6-2.3h20c15.2,0,23.4,13,26.5,17.9.3.4.5.8.6,1l.6.8-.6.8c-.2.2-.4.6-.6,1-2.8,4.5-11.5,18.1-27.1,18.1M68.7,24.8c-2.8-4.5-10.3-16.5-23.9-16.5h-14.5c2.2,3.9,4.3,9.3,4.4,16.1,0,7.6-2.3,13.6-4.4,17.4h0c0,.1,14,.1,14,.1,13.9,0,21.6-12.2,24.5-16.7"/>\n  <path d="M76,30.6c-3.1,0-5.6-2.5-5.6-5.6s2.5-5.6,5.6-5.6,5.6,2.5,5.6,5.6-2.5,5.6-5.6,5.6ZM76,22.4c-1.4,0-2.6,1.2-2.6,2.6s1.2,2.6,2.6,2.6,2.6-1.2,2.6-2.6-1.2-2.6-2.6-2.6Z"/>\n</svg>';

  // simulator/img/xor.svg
  var xor_default = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n  <rect x="5" y="14" width="20.7" height="2"/>\n  <rect x="5" y="34.1" width="20.7" height="2"/>\n  <rect x="71.2" y="24" width="23.8" height="2"/>\n  <path d="M21.7,44.8l-2.4-1.7c5.1-7.1,7-11.9,7-17.9s-2.3-12.2-6.9-17.9l2.3-1.9c5.1,6.3,7.6,12.7,7.6,19.8s-2.1,12.1-7.5,19.7h-.1Z"/>\n  <path d="M24.9,44.9l1.6-2.3c2.1-3.1,5.5-9.5,5.3-18-.1-7.6-3-13.3-5.3-16.8l-1.6-2.3h20c15.2,0,23.4,13,26.5,17.9.3.4.5.8.6,1l.6.8-.6.8c-.2.2-.4.6-.6,1-2.8,4.5-11.5,18.1-27.1,18.1M68.7,24.8c-2.8-4.5-10.3-16.5-23.9-16.5h-14.5c2.2,3.9,4.3,9.3,4.4,16.1,0,7.6-2.3,13.6-4.4,17.4h0c0,.1,14,.1,14,.1,13.9,0,21.6-12.2,24.5-16.7"/>\n</svg>';

  // simulator/img/xor3.svg
  var xor3_default = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n  <rect x="5" y="14" width="20.7" height="2"/>\n  <rect x="5" y="24" width="23" height="2"/>\n  <rect x="5" y="34.1" width="20.7" height="2"/>\n  <rect x="71.2" y="24" width="23.8" height="2"/>\n  <path d="M21.7,44.8l-2.4-1.7c5.1-7.1,7-11.9,7-17.9s-2.3-12.2-6.9-17.9l2.3-1.9c5.1,6.3,7.6,12.7,7.6,19.8s-2.1,12.1-7.5,19.7h-.1Z"/>\n  <path d="M24.9,44.9l1.6-2.3c2.1-3.1,5.5-9.5,5.3-18-.1-7.6-3-13.3-5.3-16.8l-1.6-2.3h20c15.2,0,23.4,13,26.5,17.9.3.4.5.8.6,1l.6.8-.6.8c-.2.2-.4.6-.6,1-2.8,4.5-11.5,18.1-27.1,18.1M68.7,24.8c-2.8-4.5-10.3-16.5-23.9-16.5h-14.5c2.2,3.9,4.3,9.3,4.4,16.1,0,7.6-2.3,13.6-4.4,17.4h0c0,.1,14,.1,14,.1,13.9,0,21.6-12.2,24.5-16.7"/>\n</svg>';

  // simulator/img/xor4.svg
  var xor4_default = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="0 0 100 50" style="enable-background:new 0 0 100 50;" fill="currentColor">\n  <rect x="5" y="9.2" width="18" height="2"/>\n  <rect x="5" y="19.2" width="22.2" height="2"/>\n  <rect x="5" y="29.3" width="22.2" height="2"/>\n  <rect x="5" y="39.4" width="18" height="2"/>\n  <rect x="71.2" y="24" width="23.8" height="2"/>\n  <path d="M21.7,44.8l-2.4-1.7c5.1-7.1,7-11.9,7-17.9s-2.3-12.2-6.9-17.9l2.3-1.9c5.1,6.3,7.6,12.7,7.6,19.8s-2.1,12.1-7.5,19.7h-.1Z"/>\n  <path d="M24.9,44.9l1.6-2.3c2.1-3.1,5.5-9.5,5.3-18-.1-7.6-3-13.3-5.3-16.8l-1.6-2.3h20c15.2,0,23.4,13,26.5,17.9.3.4.5.8.6,1l.6.8-.6.8c-.2.2-.4.6-.6,1-2.8,4.5-11.5,18.1-27.1,18.1M68.7,24.8c-2.8-4.5-10.3-16.5-23.9-16.5h-14.5c2.2,3.9,4.3,9.3,4.4,16.1,0,7.6-2.3,13.6-4.4,17.4h0c0,.1,14,.1,14,.1,13.9,0,21.6-12.2,24.5-16.7"/>\n</svg>';

  // simulator/src/images.ts
  var icons = {
    add: add_icon_default,
    bordercolor: bordercolor_icon_default,
    check: check_icon_default,
    close: close_icon_default,
    connect: connect_icon_default,
    dimensions: dimensions_icon_default,
    direction: direction_icon_default,
    download: download_icon_default,
    edit: edit_icon_default,
    eye: eye_icon_default,
    font: font_icon_default,
    force: force_icon_default,
    inputs: inputs_icon_default,
    link: link_icon_default,
    memcontent: memcontent_icon_default,
    memlines: memlines_icon_default,
    mouse: mouse_icon_default,
    move: move_icon_default,
    newcomponent: newcomponent_icon_default,
    none: none_icon_default,
    open: open_icon_default,
    outputs: outputs_icon_default,
    palette: palette_icon_default,
    pause: pause_icon_default,
    pen: pen_icon_default,
    placement: placement_icon_default,
    play: play_icon_default,
    question: question_icon_default,
    questioncircled: questioncircled_icon_default,
    redo: redo_icon_default,
    ref: ref_icon_default,
    regroup: ref_icon_default,
    replace: replace_icon_default,
    reset: reset_icon_default,
    screenshot: screenshot_icon_default,
    setinput: setinput_icon_default,
    settings: settings_icon_default,
    slanted: slanted_icon_default,
    step: step_icon_default,
    strokewidth: strokewidth_icon_default,
    testcase: testcase_icon_default,
    timer: timer_icon_default,
    trash: trash_icon_default,
    undo: undo_icon_default,
    wirestyle: wirestyle_icon_default
  };
  var images = {
    Adder: Adder_default,
    AdderArray: AdderArray_default,
    ALU: ALU_default,
    and: and_default,
    and3: and3_default,
    and4: and4_default,
    buf: buf_default,
    Clock: Clock_default,
    Comparator: Comparator_default,
    Counter: Counter_default,
    Decoder: Decoder_default,
    Decoder7Seg: Decoder7Seg_default,
    Decoder16Seg: Decoder16Seg_default,
    DecoderBCD4: DecoderBCD4_default,
    Demux: Demux_default,
    FlipflopD: FlipflopD_default,
    FlipflopJK: FlipflopJK_default,
    FlipflopT: FlipflopT_default,
    GateArray: GateArray_default,
    HalfAdder: HalfAdder_default,
    imply: imply_default,
    Input1: Input1_default,
    Input4: Input4_default,
    Input8: Input8_default,
    Random: Random_default,
    Rectangle: Rectangle_default,
    Label: Label_default,
    LatchSR: LatchSR_default,
    Mux: Mux_default,
    nand: nand_default,
    nand3: nand3_default,
    nand4: nand4_default,
    nimply: nimply_default,
    nor: nor_default,
    nor3: nor3_default,
    nor4: nor4_default,
    not: not_default,
    or: or_default,
    or3: or3_default,
    or4: or4_default,
    Output1: Output1_default,
    Output4: Output4_default,
    Output8: Output8_default,
    Display7Seg: Display7Seg_default,
    Display16Seg: Display16Seg_default,
    DisplayAscii: DisplayAscii_default,
    DisplayBar: DisplayBar_default,
    Display4: Display4_default,
    Display8: Display8_default,
    ShiftDisplay: ShiftDisplay_default,
    Passthrough1: Passthrough1_default,
    PassthroughN: PassthroughN_default,
    RAM: RAM_default,
    ROM: ROM_default,
    Register: Register_default,
    ShiftRegister: ShiftRegister_default,
    ControlledInverter: ControlledInverter_default,
    tri: tri_default,
    TristateBufferArray: TristateBufferArray_default,
    txa: txa_default,
    xnor: xnor_default,
    xnor3: xnor3_default,
    xnor4: xnor4_default,
    xor: xor_default,
    xor3: xor3_default,
    xor4: xor4_default
  };
  function isIconName(name2) {
    return name2 in icons;
  }
  __name(isIconName, "isIconName");
  function makeImage(name2, width, height) {
    return makeSvgHolder("svgimg", name2, raw(inlineSvgFor(images, name2)), width, height);
  }
  __name(makeImage, "makeImage");
  function makeIcon(name2, width, height) {
    return makeSvgHolder("svgicon", name2, raw(inlineSvgFor(icons, name2)), width, height);
  }
  __name(makeIcon, "makeIcon");
  function makeSvgHolder(className, iconName, content, width, height) {
    const elem = document.createElement("i");
    elem.classList.add(className);
    elem.setAttribute("data-icon", iconName);
    if (width !== void 0) {
      elem.style.width = `${width}px`;
    }
    if (height !== void 0) {
      elem.style.height = `${height}px`;
    }
    applyModifierTo(elem, content);
    return elem;
  }
  __name(makeSvgHolder, "makeSvgHolder");
  function inlineSvgFor(svgData, name2) {
    return svgData[name2];
  }
  __name(inlineSvgFor, "inlineSvgFor");
  function inlineIconSvgFor(name2) {
    return inlineSvgFor(icons, name2);
  }
  __name(inlineIconSvgFor, "inlineIconSvgFor");

  // simulator/src/htmlgen.ts
  function isModifierObject(mod) {
    return typeof mod.applyTo === "function";
  }
  __name(isModifierObject, "isModifierObject");
  function isNode(obj) {
    return typeof obj === "object" && "nodeType" in obj;
  }
  __name(isNode, "isNode");
  function applyModifierTo(parent, modifier) {
    if (isNode(modifier)) {
      parent.appendChild(modifier);
    } else if (isModifierObject(modifier)) {
      modifier.applyTo(parent);
    } else {
      const text = "" + modifier;
      parent.appendChild(document.createTextNode(text));
    }
  }
  __name(applyModifierTo, "applyModifierTo");
  function applyModifiersTo(parent, modifiers) {
    for (const mod of modifiers) {
      applyModifierTo(parent, mod);
    }
  }
  __name(applyModifiersTo, "applyModifiersTo");
  function elemBuilder(tagName) {
    return (...modifiers) => {
      return {
        render: () => {
          const el = document.createElement(tagName);
          applyModifiersTo(el, modifiers);
          return el;
        },
        applyTo: function(parent) {
          parent.appendChild(this.render());
        }
      };
    };
  }
  __name(elemBuilder, "elemBuilder");
  function attrBuilder(attrName) {
    const builder = /* @__PURE__ */ __name((attrValue) => {
      return {
        applyTo: (p) => p.setAttribute(attrName, "" + attrValue)
      };
    }, "builder");
    builder.attrName = attrName;
    return builder;
  }
  __name(attrBuilder, "attrBuilder");
  function data(dataName) {
    return attrBuilder("data-" + dataName);
  }
  __name(data, "data");
  function raw(rawHTML) {
    return {
      applyTo: (p) => p.insertAdjacentHTML("beforeend", rawHTML)
    };
  }
  __name(raw, "raw");
  function mods(...modifiers) {
    return {
      applyTo: (p) => applyModifiersTo(p, modifiers)
    };
  }
  __name(mods, "mods");
  var emptyMod = {
    applyTo: (__) => void 0
    // do nothing
  };
  function attr(attrName, attrValue) {
    return attrBuilder(attrName)(attrValue);
  }
  __name(attr, "attr");
  var div = elemBuilder("div");
  var span = elemBuilder("span");
  var a = elemBuilder("a");
  var b = elemBuilder("b");
  var i = elemBuilder("i");
  var ul = elemBuilder("ul");
  var ol = elemBuilder("ol");
  var li = elemBuilder("li");
  var table = elemBuilder("table");
  var thead = elemBuilder("thead");
  var tbody = elemBuilder("tbody");
  var tr = elemBuilder("tr");
  var th = elemBuilder("th");
  var td = elemBuilder("td");
  var input = elemBuilder("input");
  var select = elemBuilder("select");
  var option = elemBuilder("option");
  var button = elemBuilder("button");
  var label = elemBuilder("label");
  var img = elemBuilder("img");
  var canvas = elemBuilder("canvas");
  var style = attrBuilder("style");
  var type = attrBuilder("type");
  var cls = attrBuilder("class");
  var href = attrBuilder("href");
  var target = attrBuilder("target");
  var title = attrBuilder("title");
  var src = attrBuilder("src");
  var draggable = attrBuilder("draggable")("true");
  var br = raw("<br>");
  var asValue = /* @__PURE__ */ __name((bool) => b(isUnknown(bool) || isHighImpedance(bool) ? Unknown : String(Number(bool))), "asValue");
  function tooltipContent(title2, body, maxWidth = 200) {
    return div(
      style(`max-width: ${maxWidth}px`),
      title2 === void 0 ? emptyMod : div(style("padding-bottom: 3px; border-bottom: 1px solid grey;"), title2),
      div(body)
    );
  }
  __name(tooltipContent, "tooltipContent");
  var fixedWidthInContextMenu = style("font-family: monospace; font-weight: bolder; font-size: 90%");
  function setupSvgIcon(_iconElem) {
    var _a;
    const iconElem = _iconElem;
    const iconName = (_a = iconElem.dataset.icon) != null ? _a : "question";
    if (isIconName(iconName)) {
      iconElem.innerHTML = inlineIconSvgFor(iconName);
    } else {
      console.log(`Unknown icon name '${iconName}'`);
    }
  }
  __name(setupSvgIcon, "setupSvgIcon");

  // simulator/src/strings.ts
  var Template = class {
    constructor(templateString) {
      this.templateString = templateString;
    }
    expand(values) {
      return this.templateString.replace(/\$(s?)\{(\w+)(\?(\w*)(:(\w*))?)?\}/g, (match, s, key, plurDecl, plural, singDecl, singular) => {
        const value = values[key];
        if (s === "s") {
          return S.plural(value === void 0 ? 0 : Number(value), plural, singular);
        }
        return String(value != null ? value : "<<" + key + ">>");
      });
    }
  };
  __name(Template, "Template");
  function template(templ) {
    return new Template(templ);
  }
  __name(template, "template");
  var Strings_fr = {
    plural: (n, plural, singular) => Math.abs(n) < 2 ? singular != null ? singular : "" : plural != null ? plural : "s",
    ComponentBar: {
      Labels: {
        More: "Plus",
        Less: "Moins"
      },
      SectionNames: {
        InputOutput: "Entr\xE9es/ sorties",
        Layout: "Dispo- sition",
        Gates: "Portes",
        Components: "Compo- sants",
        Custom: "Person- nalis\xE9"
      },
      Components: RichStringEnum.withProps()({
        Input1: ["Entr\xE9e", "IN"],
        InputN: ["Entr\xE9e multiple", "IN mult."],
        Input8: ["Entr\xE9e octet (8 bits)", "IN 8 bits"],
        Clock: ["G\xE9n\xE9rateur de signal d\u2019horloge", "Horloge"],
        Random: ["Entr\xE9e al\xE9atoire", "Al\xE9atoire"],
        Output1: ["Sortie", "OUT"],
        OutputN: ["Sortie multiple", "OUT mult."],
        Output8: ["Sortie octet (8 bits)", "OUT 8 bits"],
        DisplayN: ["Afficheur d\u2019une valeur", "Afficheur"],
        Display8: ["Affichage de 8 bits", "Aff. 8 bits"],
        Display7Seg: ["Afficheur \xE0 7 segments", "7 segments"],
        Display16Seg: ["Afficheur \xE0 16 segments", "16 segments"],
        DisplayAscii: ["Affichage d\u2019un caract\xE8re ASCII (sur 7 bits)", "Caract\xE8re"],
        DisplayBar: ["Affichage d\u2019un bit sous forme de segment lumineux", "Segment"],
        ShiftDisplay: ["Affichage avec buffer \xE0 d\xE9calage", "Affichage \xE0 d\xE9calage"],
        Passthrough1: ["Broche", "Broche"],
        PassthroughN: ["Broche \xE0 plusieurs entr\xE9es-sortes", "Broche (n)"],
        Label: ["\xC9tiquette", "Label"],
        Rectangle: ["Rectangle de regroupement", "Groupe"],
        not: ["Porte NON", "NON"],
        buf: ["Buffer (porte OUI)", "OUI"],
        tri: ["Sortie \xE0 3 \xE9tats", "3 \xE9tats"],
        and: ["Porte ET", "ET"],
        or: ["Porte OU", "OU"],
        xor: ["Porte OU-X", "OU-X"],
        nand: ["Porte NON-ET", "NON-ET"],
        nor: ["Porte NON-OU", "NON-OU"],
        xnor: ["Porte NON-OU-X", "NON-OU-X"],
        imply: ["Porte IMPLIQUE", "IMPLIQUE"],
        nimply: ["Porte NON-IMPLIQUE", "NON-IMPL."],
        transfer: ["Fausse porte TRANSFERT \xE0 deux entr\xE9es", "TRANSF."],
        and3: ["Porte ET \xE0 3 entr\xE9es", "ET (3)"],
        or3: ["Porte OU \xE0 3 entr\xE9es", "OU (3)"],
        xor3: ["Porte OU-X \xE0 3 entr\xE9es", "OU-X (3)"],
        nand3: ["Porte NON-ET \xE0 3 entr\xE9es", "NON-ET (3)"],
        nor3: ["Porte NON-OU \xE0 3 entr\xE9es", "NON-OU (3)"],
        xnor3: ["Porte NON-OU-X \xE0 3 entr\xE9es", "NON-OU-X (3)"],
        and4: ["Porte ET \xE0 4 entr\xE9es", "ET (4)"],
        or4: ["Porte OU \xE0 4 entr\xE9es", "OU (4)"],
        xor4: ["Porte OU-X \xE0 4 entr\xE9es", "OU-X (4)"],
        nand4: ["Porte NON-ET \xE0 4 entr\xE9es", "NON-ET (4)"],
        nor4: ["Porte NON-OU \xE0 4 entr\xE9es", "NON-OU (4)"],
        xnor4: ["Porte NON-OU-X \xE0 4 entr\xE9es", "NON-OU-X (4)"],
        ControlledInverter: ["Inverseur commut\xE9", "Inv. comm."],
        GateArray: ["Porte multiple", "Porte mult."],
        TristateBufferArray: ["Sortie \xE0 3 \xE9tats multiple", "3 \xE9tats mult."],
        HalfAdder: ["Demi-additionneur", "Demi-add."],
        Adder: ["Additionneur", "Addit."],
        AdderArray: ["Additionneur multiple", "Add. mult."],
        ALU: ["Unit\xE9 arithm\xE9tique et logique", "ALU"],
        Mux: ["Multiplexer", "Mux"],
        Mux2to1: ["Multiplexer 2-vers-1 (1 bit de contr\xF4le)", "Mux 2-1"],
        Mux4to1: ["Multiplexer 4-vers-1 (2 bits de contr\xF4le)", "Mux 4-1"],
        Mux8to1: ["Multiplexer 8-vers-1 (3 bits de contr\xF4le)", "Mux 8-1"],
        Mux4to2: ["Multiplexer 4-vers-2 (1 bit de contr\xF4le)", "Mux 4-2"],
        Mux8to2: ["Multiplexer 8-vers-2 (2 bits de contr\xF4le)", "Mux 8-2"],
        Mux8to4: ["Multiplexer 8-vers-4 (1 bit de contr\xF4le)", "Mux 8-4"],
        Mux16to8: ["Multiplexer 16-vers-8 (1 bit de contr\xF4le)", "Mux 16-8"],
        Demux: ["D\xE9multiplexer", "Demux"],
        Demux1to2: ["D\xE9multiplexer 1-vers-2 (1 bit de contr\xF4le)", "Demux 1-2"],
        Demux1to4: ["D\xE9multiplexer 1-vers-4 (2 bits de contr\xF4le)", "Demux 1-4"],
        Demux1to8: ["D\xE9multiplexer 1-vers-8 (3 bits de contr\xF4le)", "Demux 1-8"],
        Demux2to4: ["D\xE9multiplexer 2-vers-4 (1 bit de contr\xF4le)", "Demux 2-4"],
        Demux2to8: ["D\xE9multiplexer 2-vers-8 (2 bits de contr\xF4le)", "Demux 2-8"],
        Demux4to8: ["D\xE9multiplexer 4-vers-8 (1 bit de contr\xF4le)", "Demux 4-8"],
        Demux8to16: ["D\xE9multiplexer 8-vers-16 (1 bit de contr\xF4le)", "Demux 8-16"],
        LatchSR: ["Verrou SR", "Verrou SR"],
        FlipflopJK: ["Bascule JK", "Basc. JK"],
        FlipflopT: ["Bascule T", "Basc. T"],
        FlipflopD: ["Bascule D", "Basc. D"],
        Register: ["Registre", "Registre"],
        ShiftRegister: ["Registre \xE0 d\xE9calage", "Reg. d\xE9c."],
        RAM: ["RAM (m\xE9moire vive)", "RAM"],
        ROM: ["ROM (m\xE9moire morte)", "ROM"],
        Counter: ["Compteur 4 bits", "Compteur"],
        Decoder: ["D\xE9codeur binaire vers 1-sur-n", "D\xE9codeur"],
        Decoder7Seg: ["D\xE9codeur 7 segments", "D\xE9c. 7 seg."],
        Decoder16Seg: ["D\xE9codeur ASCII vers 16 segments", "D\xE9c. 16 seg."],
        DecoderBCD4: ["D\xE9codeur 4 bits vers BCD sur 5 bits", "D\xE9c. BCD"],
        Comparator: ["Comparateur", "Compar."]
      })
    },
    Modes: {
      FULL: tuple("Admin", "En plus du mode complet, ce mode permet de rendre les entr\xE9es, les sorties des portes, voire les portes elles-m\xEAmes ind\xE9termin\xE9es"),
      DESIGN: tuple("Complet", "La totalit\xE9 des actions de conception d\u2019un circuit sont possible"),
      CONNECT: tuple("Connexion", "Il est possible de d\xE9placer et de connecter des \xE9l\xE9ments d\xE9j\xE0 sur le canevas, mais pas d\u2019en rajouter (le menu de gauche ne serait pas actif)"),
      TRYOUT: tuple("Test", "Il est seulement possible de changer les entr\xE9es pour tester un circuit pr\xE9\xE9tabli"),
      STATIC: tuple("Statique", "Les \xE9l\xE9ments sont juste affich\xE9s; aucune interaction n\u2019est possible")
    },
    Orientations: {
      e: "Vers la droite (par d\xE9faut)",
      s: "Vers le bas",
      w: "Vers la gauche",
      n: "Vers le haut"
    },
    Settings: {
      Settings: "R\xE9glages",
      CircuitName: "Nom:",
      DefaultFileName: "circuit",
      NameOfDownloadedFile: "Ceci sera le nom du fichier t\xE9l\xE9charg\xE9.",
      animateWires: tuple("Animer les fils", "Si coch\xE9, les fils sont anim\xE9s pour montrer dans quel sens logique le signal se propage."),
      hideWireColors: tuple("Cacher l\u2019\xE9tat des fils", "Si coch\xE9, les fils sont affich\xE9s avec une couleur neutre plut\xF4t que de montrer s\u2019ils v\xE9hiculent un 1 ou un 0."),
      hideInputColors: tuple("Cacher l\u2019\xE9tat des entr\xE9es", "Si coch\xE9, les entr\xE9es sont affich\xE9es avec une couleur neutre, m\xEAme si elles livrent au circuit une valeur bien d\xE9termin\xE9e. S\u2019utilise volontiers en cachant aussi l\u2019\xE9tat des fils."),
      hideOutputColors: tuple("Cacher l\u2019\xE9tat des sorties", "Si coch\xE9, les sorties sont affich\xE9es avec une couleur neutre. S\u2019utilise volontiers en cachant aussi l\u2019\xE9tat des fils."),
      hideMemoryContent: tuple("Cacher le contenu stock\xE9", "Si coch\xE9, les verrous, bascules, registres et autres m\xE9moires ne montrent pas leur contenu."),
      showGateTypes: tuple("Montrer type des portes", "Si coch\xE9, affiche sur les portes logique le nom de la fonction r\xE9alis\xE9e."),
      showDisconnectedPins: tuple("Toujours montrer les pattes", "Si non coch\xE9, les pattes non connect\xE9es des composants sont masqu\xE9es dans les modes o\xF9 les connexions du circuit ne peuvent pas \xEAtre modifi\xE9es (et restent visibles sinon)."),
      hideTooltips: tuple("D\xE9sactiver tooltips", "Si coch\xE9, les informations suppl\xE9mentaires des tooltips (comme les tables de v\xE9rit\xE9) ne seront pas affich\xE9es."),
      groupParallelWires: tuple("Grouper les fils parall\xE8les", "Si coch\xE9, les fils parral\xE8les allant d'un composant \xE0 un autre seront regroup\xE9s en un seul fil plus \xE9pais."),
      showHiddenWires: tuple("Montrer les fils cach\xE9s", "Si coch\xE9, les fils cach\xE9s seront quand m\xEAme affich\xE9s."),
      showAnchors: tuple("Montrer les ancrages", "Si coch\xE9, des fl\xE8ches indiqueront les composants auxquels sont ancr\xE9s les composants lors de leur d\xE9placement."),
      showIds: tuple("Montrer les identifiants", "Si coch\xE9, les identifiants des composants seront affich\xE9s."),
      propagationDelay: "Un 1 ou un 0 impos\xE9 sur une connexion sera r\xE9percut\xE9 \xE0 l\u2019autre bout de la connexion apr\xE8s ce d\xE9lai de propagation.",
      propagationDelayField: tuple("Propagation en", "ms"),
      zoomLevel: "Le niveau de zoom sur les composants du circuit.",
      zoomLevelField: tuple("Zoom:", "%"),
      showUserDataLink: tuple("Voir les", "donn\xE9es li\xE9es"),
      userDataHeader: "Les donn\xE9es suivantes sont export\xE9es avec le circuit:",
      wireStyle: "Style des fils:"
    },
    Tests: {
      Title: "Tests",
      DefaultTestCaseName: "Test",
      DefaultTestSuiteName: "Tests",
      SetInputs: "Entr\xE9es",
      WantedOutputs: "Sorties",
      SetTheseInputs: "R\xE9gler ces entr\xE9es",
      Run: "Tester",
      RunTestSuite: "Ex\xE9cuter les tests",
      DeleteTestCase: "Supprimer ce test",
      EditTestCaseName: "Renommer ce test",
      EnterNewTestCaseName: "Entrez le nouveau nom du test:",
      ComponentUsedInTestSuite: template("Ce composant est utilis\xE9 dans des tests. Voulez-vous vraiment le supprimer? Les tests seront conserv\xE9s, mais ne fonctionneront pas tant qu\u2019un autre composant avec cette r\xE9f\xE9rence (\u201C${ref}\u201D) ne sera pas ajout\xE9 au circuit.")
    },
    TopBar: {
      DirtyTooltip: "Le circuit a \xE9t\xE9 modifi\xE9 depuis la derni\xE8re sauvegarde.",
      CircuitNameTooltip: "Nom du circuit actuellement \xE9dit\xE9; cliquez pour modifier",
      SetCircuitName: "Tapez le nom du circuit (ou laissez vide pour le nom par d\xE9faut):",
      CustomComponentCaptionTooltip: "Nom du sous-circuit actuellement \xE9dit\xE9; cliquez pour modifier",
      CloseCircuit: "Retour au circuit complet",
      Undo: tuple("Annuler", "Annule la derni\xE8re action"),
      Redo: tuple("R\xE9tablir", "R\xE9tablit la derni\xE8re action annul\xE9e ou r\xE9p\xE8te l\u2019action pr\xE9c\xE9dente"),
      Download: tuple("T\xE9l\xE9charger", "T\xE9l\xE9charge le circuit (ou les composants personnalis\xE9s avec la touche Option/Alt)"),
      Screenshot: tuple("Screenshot", "T\xE9l\xE9charge le circuit sous forme d\u2019image (PNG ou SVG avec touche Option/Alt)"),
      Open: tuple("Ouvrir", "Ouvre un circuit pr\xE9c\xE9demment t\xE9l\xE9charg\xE9"),
      Reset: tuple("R\xE9initialiser", "R\xE9initialise l\u2019\xE9tat de ce circuit"),
      TimelinePlay: tuple("Play", "D\xE9marre l\u2019\xE9coulement du temps"),
      TimelinePause: tuple("Pause", "Arr\xEAte l\u2019\xE9coulement du temps"),
      TimelineStep: tuple("Pas \xE0 pas", "Avance au prochain \xE9v\xE9nement"),
      TimeLabel: "Temps: ",
      Design: tuple("Concevoir", "Compose ou modifie le circuit"),
      Delete: tuple("Supprimer", "Supprime des \xE9l\xE9ments du circuit"),
      Move: tuple("D\xE9placer", "D\xE9place tout le circuit"),
      Tests: tuple("Tests", "Montre les tests pour ce circuit")
    },
    Messages: {
      UnsupportedFileType: template("Type de fichier non pris en charge: ${type}."),
      LoadedDefinitions: template("${n} composant$s{n} personnalis\xE9$s{n} charg\xE9$s{n}"),
      SavedToUrl: "Circuit enregistr\xE9 dans l\u2019URL",
      SetAnchorPrompt: "Cliquez sur le composant auquel s\u2019ancrer",
      AnchorAdded: "Ancrage ajout\xE9",
      CircularAnchorsForbidden: "Les ancrages circulaires ne sont pas pris en charge.",
      NotImplemented: "Cette fonctionnalit\xE9 n\u2019est pas encore impl\xE9ment\xE9e.",
      NoPermission: "Cette action n\u2019est pas autoris\xE9e dans ce mode.",
      ReallyCloseWindow: "Voulez-vous vraiment fermer la fen\xEAtre sans prendre en compte les derniers changements?",
      DevelopedBy: "D\xE9velopp\xE9 par ",
      DidUndo: "Annuler",
      DidRedo: "R\xE9tablir",
      DidRepeat: "R\xE9p\xE9ter",
      NothingToUndo: "Rien \xE0 annuler",
      NothingToRedo: "Rien \xE0 r\xE9tablir ou r\xE9p\xE9ter",
      NewTestCaseTitle: "Cr\xE9ation d\u2019un nouveau test de circuit",
      NewTestCaseSetName: "Entrez le nom du test:",
      TestCaseInputToSet: template("Entr\xE9e$s{n} \xE0 r\xE9gler:"),
      TestCaseOuputToCheck: template("Sorties$s{n} attendue$s{n}:"),
      TooManyInputsForAutoTestCases: template("Impossible de cr\xE9er automatiquement des tests pour plus de ${max} entr\xE9es."),
      AutoTestCasesWarning: template("Ceci va cr\xE9er ${numCases} tests, un pour chacune des combinaisons des ${numInputs} entr\xE9es. Voulez-vous continuer?"),
      ComputingTestCases: "G\xE9n\xE9ration des tests\u2026",
      RunningTests: "Exc\xE9cution des tests\u2026"
    },
    Components: {
      Generic: {
        contextMenu: {
          Delete: "Supprimer",
          Reset: "R\xE9activer",
          MakeNewComponent: "Cr\xE9er un nouveau composant\u2026",
          MakeNewComponentFailed: "Impossible de cr\xE9er un nouveau composant.",
          MakeNewTestCase: "Cr\xE9er un nouveau test\u2026",
          MakeAllTestCases: "Cr\xE9er tous les tests\u2026",
          MakeNewTestCaseFailed: "Impossible de cr\xE9er un nouveau test.",
          SetIdentifier: "Attribuer un identifiant\u2026",
          ChangeIdentifier: tuple("Changer l\u2019identifiant (", ")\u2026"),
          SetIdentifierPrompt: "Choisissez l\u2019identifiant unique \xE0 attribuer \xE0 ce composant:",
          IdentifierCannotBeEmpty: "L\u2019identifiant ne peut pas \xEAtre vide.",
          IdentifierAlreadyInUseShouldSwap: "L\u2019identifiant est d\xE9j\xE0 utilis\xE9 par un autre composant. Voulez-vous inverser les identifiants?",
          SetAnchor: "D\xE9finir l\u2019ancrage\u2026",
          ClearAnchor: tuple("Supprimer l\u2019ancrage (", ")"),
          Orientation: "Orientation",
          ChangeOrientationDesc: "Changez l\u2019orientation avec Commande + double-clic sur le composant",
          LockPosition: "Verrouiller la position",
          ShowAsUnknown: "Afficher comme inconnu",
          ForceOutputSingle: "Forcer la sortie",
          ForceOutputMultiple: "Forcer une sortie",
          Output: "Sortie",
          NormalOutput: "Sortie normale",
          ForceAsUnknown: "Forcer comme \xE9tat inconnu",
          ForceAs1: "Forcer \xE0 1",
          ForceAs0: "Forcer \xE0 0",
          ForceAsZ: "Forcer \xE0 haute imp\xE9dance",
          ForceOutputDesc: "Forcez une sortie avec Option + double-clic sur la sortie",
          SetName: "Ajouter un nom\u2026",
          ChangeName: "Changer le nom\u2026",
          SetNamePrompt: "Choisissez le nom \xE0 afficher ou laissez vide pour le supprimer:",
          SetFontPrompt: tuple("Entrez une sp\xE9cification de police ou laissez vide pour la valeur par d\xE9faut (", "):"),
          TriggerOn: "Stocker au",
          TriggerRisingEdge: "flanc montant",
          TriggerFallingEdge: "flanc descendant",
          ShowContent: "Montrer le contenu",
          ParamControlBitAtBottom: "Bit de contr\xF4le en bas",
          ParamControlBitsAtBottom: "Bits de contr\xF4le en bas",
          ParamNumInputs: tuple("Nombre d\u2019entr\xE9es", template("${val} entr\xE9e$s{val}")),
          ParamNumBits: tuple("Nombre de bits", template("${val} bit$s{val}")),
          ParamNumWords: tuple("Nombre de lignes", template("${val} ligne$s{val}"))
        },
        InputCarryInDesc: "Cin (retenue pr\xE9c\xE9dente)",
        InputClockDesc: "Clock (horloge)",
        InputClearDesc: "C (Clear, mise \xE0 0)",
        InputPresetDesc: "P (Preset, mise \xE0 1)",
        InputSetDesc: "S (Set, mise \xE0 1)",
        InputResetDesc: "R (Reset, mise \xE0 0)",
        InputDataDesc: "D (Donn\xE9es)",
        InputWriteEnableDesc: "WE (\xE9criture activ\xE9e)",
        OutputSumDesc: "S (somme)",
        OutputCarryDesc: "C (retenue)",
        OutputCarryOutDesc: "Cout (retenue)",
        OutputQDesc: "Q (sortie normale)",
        OutputQBarDesc: "Q\u0305 (sortie invers\xE9e)"
      },
      Custom: {
        MenuButtonSuffix: " (composant personnalis\xE9)",
        contextMenu: {
          ChangeName: "Renommer\u2026",
          ChangeNamePrompt: "Choisissez le nom de ce composant personnalit\xE9:",
          ChangeNameEmpty: "Le nom ne peut pas \xEAtre vide.",
          ChangeCircuit: "Modifier le circuit",
          Delete: "Supprimer ce composant",
          EditFromComponentMessage: "Vous pouvez modifier ce composant depuis le menu d\u2019un composant du circuit.",
          CannotDeleteInUse: "Impossible de supprimer ce composant car il est utilis\xE9 dans le circuit.",
          CannotDeleteInUseBy: template("Impossible de supprimer ce composant car il est utilis\xE9 dans la d\xE9finition d\u2019un autre composant (${caption})."),
          ConfirmDelete: "Voulez-vous vraiment supprimer ce composant personnalis\xE9?"
        },
        tooltip: {
          titleSuffix: " (composant personnalis\xE9)",
          desc: "Ce composant calcule ses sorties selon le circuit personnalis\xE9 que vous avez d\xE9fini."
        },
        messages: {
          EmptySelection: "Aucun composant n\u2019est s\xE9lectionn\xE9.",
          NoInput: "Aucune entr\xE9e n\u2019est s\xE9lectionn\xE9e.",
          NoOutput: "Aucune sortie n\u2019est s\xE9lectionn\xE9e.",
          InputsOutputsMustHaveNames: "Toutes les entr\xE9es et sorties doivent avoir un nom.",
          MissingComponents: template("Les composants suivants sont connect\xE9s \xE0 des sorties mais ne sont pas s\xE9lectionn\xE9s: ${list}."),
          NoWires: "Aucun fil n\u2019est pr\xE9sent entre les composants s\xE9lectionn\xE9s.",
          UselessComponents: template("Les composants suivants ne sont pas connect\xE9s \xE0 des sorties et sont inutiles: ${list}."),
          CannotIncludeClock: "Les horloges ne peuvent pas \xEAtre incluses dans les composants personnalis\xE9s. Ajoutez une entr\xE9e normale, qui pourra \xEAtre connect\xE9e \xE0 une horloge de l'ext\xE9rieur du composant.",
          CannotBeModified: "Ce composant ne peut pas \xEAtre modifi\xE9 dans ce mode.",
          EnterCaptionPrompt: "Entrez le nom (unique) du composant personnalis\xE9:",
          ComponentAlreadyExists: template("Un composant personnalis\xE9 avec l\u2019identifiant '${id}' existe d\xE9j\xE0."),
          InputsOutputsChanged: "Les entr\xE9es et sorties ont chang\xE9 et certaines connexions pourront \xEAtre supprim\xE9es en adaptant le circuit. Voulez-vous continuer?",
          NotInMainEditor: "Revenez d\u2019abord \xE0 l\u2019\xE9diteur principal pour modifier le circuit personnalis\xE9 de ce composant."
        }
      },
      Adder: {
        tooltip: {
          title: "Additionneur",
          desc: "Additionne deux bits A et B et une retenue d\u2019entr\xE9e Cin, et fournit un bit de somme S et une retenue de sortie Cout."
        }
      },
      AdderArray: {
        tooltip: {
          title: template("Additionneur \xE0 ${numBits} bit$s{numBits}"),
          desc: "Additionne les deux nombres d'entr\xE9es A et B avec une retenue d\u2019entr\xE9e Cin, et fournit les bits de somme S et une retenue de sortie Cout."
        }
      },
      ALU: {
        "A+B": tuple("+", "Addition"),
        "A-B": tuple("A\u2013B", "Soustraction (A \u2013 B)"),
        "B-A": tuple("B\u2013A", "Soustraction (B \u2013 A)"),
        "A+1": tuple("A+1", "A + 1"),
        "A-1": tuple("A\u20131", "A \u2013 1"),
        "-A": tuple("\u2013A", "N\xE9gation d\u2019A"),
        "A*2": tuple("A\xD72", "Addition d\u2019A \xE0 lui-m\xEAme (A \xD7 2)"),
        "A/2": tuple("A/2", "D\xE9calage arithm\xE9tique \xE0 droite de 1 (A / 2)"),
        "A|B": tuple("OU", "Disjonction (A OU B)"),
        "A&B": tuple("ET", "Conjonction (A ET B)"),
        "A|~B": tuple("OU-n", "A OU NON(B)"),
        "A&~B": tuple("ET-n", "A ET NON(B)"),
        "~A": tuple("A\u0305", "Inversion d\u2019A"),
        "A^B": tuple("OU-X", "Disjonction excl. (A OU-X B)"),
        "A<<": tuple("<<", "D\xE9calage logique \xE0 gauche de 1 de A"),
        "A>>": tuple(">>", "D\xE9calage logique \xE0 droite de 1 de A"),
        InputCinDesc: "retenue d\u2019entr\xE9e",
        OutputCoutDesc: "retenue de sortie",
        tooltip: {
          title: "Unit\xE9 arithm\xE9tique et logique (ALU)",
          CurrentlyCarriesOut: "Effectue actuellement",
          SomeUnknownOperation: "une op\xE9ration inconnue",
          ThisOperation: "l\u2019op\xE9ration"
        },
        contextMenu: {
          toggleShowOp: "Afficher l\u2019op\xE9ration",
          ParamUseExtendedOpcode: "Utiliser op\xE9rations \xE9tendues"
        }
      },
      Clock: {
        tooltip: {
          title: "Horloge",
          period: tuple("P\xE9riode: ", " ms"),
          dutycycle: tuple("Rapport cyclique: ", "%"),
          phase: tuple("D\xE9phasage: ", " ms")
        },
        contextMenu: {
          Period: "P\xE9riode",
          CustomPeriod: "Autre",
          SetPeriodMillis: "Entrez la p\xE9riode de l\u2019horloge en millisecondes:",
          InvalidPeriod: "La p\xE9riode doit \xEAtre un nombre entier positif.",
          ReplaceWithInput: "Remplacer par entr\xE9e"
        },
        timeline: {
          NextRisingEdge: "Prochain flanc montant de l\u2019horloge",
          NextFallingEdge: "Prochain flanc descendant de l\u2019horloge"
        }
      },
      Comparator: {
        tooltip: {
          title: "Comparateur",
          desc: "Comparateur entre deux bits A et B, activ\xE9 par une entr\xE9e E."
        }
      },
      Counter: {
        tooltip: {
          title: "Compteur",
          desc: "Compteur \xE0 quatre bits."
        },
        contextMenu: {
          DisplayTempl: template("Affichage ${desc}"),
          DisplayNone: "absent",
          DisplayDecimal: "d\xE9cimal",
          DisplayHex: "hexad\xE9cimal"
        }
      },
      Decoder: {
        tooltip: {
          title: "D\xE9codeur binaire",
          desc: template("Ce d\xE9codeur prend en entr\xE9e un nombre binaire cod\xE9 sur ${numFrom} bit$s{numFrom} et active la sortie correspondante parmi ${numTo} (actuellement, ${n}).")
        }
      },
      Decoder7Seg: {
        tooltip: "D\xE9codeur 7 segments"
      },
      Decoder16Seg: {
        tooltip: "D\xE9codeur ASCII vers 16 segments"
      },
      DecoderBCD4: {
        tooltip: "D\xE9codeur 4 bits vers BCD (binary-coded decimal)"
      },
      Demux: {
        tooltip: template("D\xE9multiplexeur ${from} vers ${to}")
      },
      FlipflopD: {
        tooltip: {
          title: "Bascule D",
          desc: "Stocke un bit."
        }
      },
      FlipflopJK: {
        InputJDesc: "J (Jump, mise \xE0 1)",
        InputKDesc: "K (Kill, mise \xE0 0)",
        tooltip: {
          title: "Bascule JK",
          desc: "Stocke un bit."
        }
      },
      FlipflopT: {
        InputTDesc: "T (Toggle, bascule)",
        tooltip: {
          title: "Bascule T",
          desc: "Stocke un bit."
        }
      },
      Gate: {
        not: tuple("NON", "NON", "La sortie est \xE9gale \xE0 l\u2019entr\xE9e invers\xE9e."),
        buf: tuple("OUI", "OUI", "La sortie est \xE9gale \xE0 l\u2019entr\xE9e."),
        and: tuple("ET", "ET", "La sortie vaut 1 lorsque toutes les entr\xE9es valent 1."),
        or: tuple("OU", "OU", "La sortie vaut 1 lorsqu\u2019au moins une des entr\xE9es vaut 1."),
        xor: tuple("OU-X", "OU-X", "La sortie vaut 1 lorsqu\u2019un nombre impair d\u2019entr\xE9es valent 1."),
        nand: tuple("NON-ET", "N-ET", "Porte ET invers\xE9e: la sortie vaut 1 \xE0 moins que toutes les entr\xE9es ne valent 1."),
        nor: tuple("NON-OU", "N-OU", "Porte OU invers\xE9e: la sortie vaut 1 lorsque toutes les entr\xE9es valent 0."),
        xnor: tuple("NON-OU-X", "N-OU-X", "Porte OU-X invers\xE9e: la sortie vaut 1 lorsqu\u2019un nombre pair d\u2019entr\xE9es valent 1."),
        imply: tuple("IMPLIQUE", "IMPL", "La sortie vaut 1 si la premi\xE8re entr\xE9e vaut 0 ou si les deux entr\xE9es valent 1."),
        rimply: tuple("IMPLIQUE (bis)", "IMPL", "La sortie vaut 1 si la seconde entr\xE9e vaut 0 ou si les deux entr\xE9es valent 1."),
        nimply: tuple("NON-IMPLIQUE", "N-IMPL", "Porte IMPLIQUE invers\xE9e: la sortie ne vaut 1 que lorsque la premi\xE8re entr\xE9e vaut 1 et la seconde 0."),
        rnimply: tuple("NON-IMPLIQUE (bis)", "N-IMPL", "Porte IMPLIQUE invers\xE9e: la sortie ne vaut 1 que lorsque la premi\xE8re entr\xE9e vaut 0 et la seconde 1."),
        txa: tuple("TRANSFERT-A", void 0, "La sortie est \xE9gale \xE0 la premi\xE8re entr\xE9e; la seconde entr\xE9e est ignor\xE9e."),
        txb: tuple("TRANSFERT-B", void 0, "La sortie est \xE9gale \xE0 la seconde entr\xE9e; la premi\xE8re entr\xE9e est ignor\xE9e."),
        txna: tuple("TRANSFERT-NON-A", void 0, "La sortie est \xE9gale \xE0 la premi\xE8re entr\xE9e invers\xE9e; la seconde entr\xE9e est ignor\xE9e."),
        txnb: tuple("TRANSFERT-NON-B", void 0, "La sortie est \xE9gale \xE0 la seconde entr\xE9e invers\xE9e; la premi\xE8re entr\xE9e est ignor\xE9e."),
        tooltip: {
          GateTitle: (gateType) => mods("Porte ", gateType),
          UnknownGate: "Porte inconnue",
          Input: "Entr\xE9e",
          Output: "Sortie",
          CurrentlyDelivers: "Actuellement, il livre",
          ShouldCurrentlyDeliver: "Actuellement, il devrait livrer",
          UndeterminedOutputBecauseInputUnknown: "une sortie ind\xE9termin\xE9e comme son entr\xE9e n\u2019est pas connue. Sa table de v\xE9rit\xE9 est:",
          UndeterminedOutputBecauseInputsUnknown: "une sortie ind\xE9termin\xE9e comme toutes ses entr\xE9es ne sont connues. Sa table de v\xE9rit\xE9 est:",
          ThisOutput: "une sortie de",
          BecauseInputIs: "car son entr\xE9e est",
          AccordingToTruthTable: "selon la table de v\xE9rit\xE9 suivante:",
          Inverter: tuple("Inverseur (porte ", ")"),
          Buffer: tuple("Buffer (porte ", ")")
        },
        contextMenu: {
          ReplaceBy: "Remplacer par",
          GateTempl: template("Porte ${type}"),
          ShowAs: "Afficher comme",
          NormalGateTempl: template("Porte ${type} normale"),
          UnknownGate: "Porte inconnue (avec \xAB?\xBB)",
          VariantChangeDesc: "Changez entre les variantes avec Majuscule + double-clic sur la porte"
        }
      },
      HalfAdder: {
        tooltip: {
          title: "Demi-additionneur",
          desc: "Additionne deux bits A et B et fournit un bit de somme S et une retenue de sortie C."
        }
      },
      Input: {
        tooltip: {
          title: template("Entr\xE9e (${numBits} bit$s{numBits})")
        },
        contextMenu: {
          LockValue: "Verrouiller cette valeur",
          PushButton: "Poussoir",
          ToggleButton: "Commutateur",
          ReplaceWithClock: "Remplacer par horloge",
          InputSetFromOutside: "Entr\xE9e contr\xF4l\xE9e depuis l\u2019ext\xE9rieur"
        }
      },
      Random: {
        tooltip: {
          title: "Valeur al\xE9atoire",
          desc: tuple("\xC0 chaque coup d\u2019horloge, la valeur de sortie sera 1 avec une probabilit\xE9 de ", ".")
        },
        contextMenu: {
          ShowProb: "Montrer la probabilit\xE9"
        }
      },
      Rectangle: {
        contextMenu: {
          Size: "Taille",
          SizePrompt: "Entrez la taille de ce rectangle:",
          Rounded: "Arrondi",
          WithBackgroundColor: "Avec couleur de fond",
          SetTitle: "Ajouter un titre\u2026",
          ChangeTitle: "Changer le titre\u2026",
          SetTitlePrompt: "Entrez le titre \xE0 afficher ou laissez vide pour le supprimer:",
          InsideFrame: "\xC0 l\u2019int\xE9rieur du cadre",
          Font: "Police\u2026",
          Color: "Couleur",
          ColorYellow: "Jaune",
          ColorRed: "Rouge",
          ColorGreen: "Vert",
          ColorBlue: "Bleu",
          ColorTurquoise: "Turquoise",
          ColorGrey: "Gris",
          Border: "Bordure",
          BorderNone: "Aucune bordure",
          Border1px: "Fine (1 pixel)",
          Border2px: "Moyenne (2 pixels)",
          Border3px: "\xC9paisse (3 pixels)",
          Border5px: "Tr\xE8s \xE9paisse (5 pixels)",
          Border10px: "\xC9norme (10 pixels)",
          TitlePlacement: "Position du titre",
          PlacementTop: "En haut",
          PlacementTopLeft: "En haut \xE0 gauche",
          PlacementTopRight: "En haut \xE0 droite",
          PlacementBottom: "En bas",
          PlacementBottomLeft: "En bas \xE0 gauche",
          PlacementBottomRight: "En bas \xE0 droite",
          PlacementLeft: "\xC0 gauche",
          PlacementRight: "\xC0 droite",
          PlacementCenter: "Au centre"
        }
      },
      Label: {
        contextMenu: {
          ChangeText: "Changer le texte\u2026",
          ChangeTextPrompt: "Choisissez le texte \xE0 afficher:",
          Font: "Police\u2026"
        }
      },
      LatchSR: {
        tooltip: {
          title: "Verrou SR",
          desc: "Stocke un bit."
        }
      },
      Mux: {
        tooltip: template("Multiplexeur ${from} vers ${to}")
      },
      MuxDemux: {
        contextMenu: {
          ShowWiring: "Afficher les connexions",
          UseZForDisconnected: "Utiliser Z pour sorties d\xE9connect\xE9es",
          ParamNumFrom: tuple("Nombre d\u2019entr\xE9es", template("${val} entr\xE9e$s{val}")),
          ParamNumTo: tuple("Nombre de sorties", template("${val} sortie$s{val}"))
        }
      },
      Output: {
        tooltip: {
          title: template("Sortie (${numBits} bit$s{numBits})")
        }
      },
      Display7Seg: {
        tooltip: "Afficheur 7 segments"
      },
      Display16Seg: {
        tooltip: "Afficheur 16 segments"
      },
      DisplayAscii: {
        tooltip: {
          title: "Afficheur de caract\xE8re ASCII",
          desc: tuple("Affiche le caract\xE8re ASCII repr\xE9sent\xE9 par ses 7 entr\xE9es, actuellement ", "."),
          CurrentlyUndefined: "Comme toutes ses entr\xE9es ne sont pas connues, ce caract\xE8re est actuellement ind\xE9fini.",
          CurrentlyThisCharacter: "Actuellement, c\u2019est le caract\xE8re num\xE9ro",
          WhichIsNotPrintable: " (un caract\xE8re non imprimable)."
        },
        contextMenu: {
          AdditionalDisplay: "Affichage suppl\xE9mentaire",
          DisplayNone: "Aucun",
          DisplayDecimal: "Valeur d\xE9cimale",
          DisplayHex: "Valeur hexad\xE9cimale",
          ChangeDisplayDesc: "Changez l\u2019affichage suppl\xE9mentaire avec un double-clic sur le composant"
        }
      },
      DisplayBar: {
        tooltip: {
          title: "Afficheur lumineux",
          ValueUnknown: "Son \xE9tat est ind\xE9termin\xE9 car son entr\xE9e n\u2019est pas connue.",
          ValueZ: "Son \xE9tat est ind\xE9termin\xE9 car son entr\xE9e est flottante (haute imp\xE9dance).",
          Value1: tuple("Il est actuellement allum\xE9 car son entr\xE9e est de ", "."),
          Value0: tuple("Il est actuellement \xE9teint car son entr\xE9e est de ", ".")
        },
        contextMenu: {
          TransparentWhenOff: "Transparent si \xE9teint",
          Display: "Affichage",
          DisplayVerticalBar: "Barre verticale",
          DisplayHorizontalBar: "Barre horizontale",
          DisplaySmallSquare: "Petit carr\xE9",
          DisplayLargeSquare: "Grand carr\xE9",
          DisplayChangeDesc: "Changez l\u2019affichage avec un double-clic sur le composant",
          Color: "Couleur",
          ColorGreen: "Vert",
          ColorRed: "Rouge",
          ColorYellow: "Jaune"
        }
      },
      Display: {
        tooltip: {
          title: template("Afficheur ${numBits} bit$s{numBits}"),
          desc: tuple(template("Affiche la valeur ${radixStr} de ses ${numBits} entr\xE9e$s{numBits}, actuellement "), "."),
          RadixBinary: "binaire",
          RadixDecimal: "d\xE9cimale",
          RadixSignedDecimal: "d\xE9cimale sign\xE9e",
          RadixHexadecimal: "hexad\xE9cimale",
          RadixGeneric: template("en base ${radix}"),
          CurrentlyUndefined: "Comme toutes ses entr\xE9es ne sont pas connues, cette valeur est actuellement ind\xE9finie."
        },
        contextMenu: {
          DisplayAs: "Afficher",
          DisplayNone: "Aucun",
          DisplayAsBinary: "en binaire (base 2)",
          DisplayAsDecimal: "en d\xE9cimal (base 10)",
          DisplayAsSignedDecimal: "en d\xE9cimal sign\xE9",
          DisplayAsOctal: "en octal (base 8)",
          DisplayAsHexadecimal: "en hexad\xE9cimal (base 16)",
          DisplayAsUnknown: "comme inconnu"
        }
      },
      ShiftDisplay: {
        tooltip: "Affichage \xE0 d\xE9calage",
        contextMenu: {
          Decoding: "D\xE9codage",
          DecodingNone: "Aucun",
          DecodingOctal: "Octal",
          DecodingHex: "Hexad\xE9cimal",
          DecodingAscii7: "ASCII (7 bits)",
          DecodingAscii8: "ASCII (8 bits)",
          DecodingUint4: "Entier sur 4 bits",
          DecodingInt4: "Entier sign\xE9 sur 4 bits",
          DecodingUint8: "Entier sur 8 bits",
          DecodingInt8: "Entier sign\xE9 sur 8 bits",
          DecodingUint16: "Entier sur 16 bits",
          DecodingInt16: "Entier sign\xE9 sur 16 bits",
          DecodingChangeWarning: "Attention, changer le d\xE9codage peut tronquer la valeur stock\xE9e",
          Grouping: "Regrouper les donn\xE9es",
          GroupingNone: "Pas de regroupement",
          GroupBy: template("Par ${n}")
        },
        EmptyCaption: "(vide)"
      },
      Passthrough: {
        tooltip: "Broche. Sert uniquement \xE0 arranger les connexions.",
        contextMenu: {
          Slant: "Inclinaison",
          SlantNone: "Aucune",
          SlantRight: "De 45\xB0 vers la droite",
          SlantLeft: "De 45\xB0 vers la gauche"
        }
      },
      GateArray: {
        tooltip: {
          title: "Porte multiple",
          desc: template("Effectue plusieurs fois en parall\xE8le l\u2019op\xE9ration logique choisie; actuellement, ${op}.")
        },
        contextMenu: {
          Type: "Type",
          ShowAsUnknown: "Masquer le type"
        }
      },
      TristateBufferArray: {
        tooltip: {
          title: "Sortie \xE0 3 \xE9tats multiple",
          desc: "Repr\xE9sente plusieurs sorties \xE0 trois \xE9tats, contr\xF4l\xE9es par un seul bit de contr\xF4le."
        }
      },
      RAM: {
        tooltip: {
          title: "RAM (m\xE9moire vive)",
          desc: template("Stocke ${numWords} ligne$s{numWords} de ${numDataBits} bit$s{numDataBits}.")
        },
        contextMenu: {
          SelectedDataDisplay: "Affichage des donn\xE9es address\xE9es",
          EditContent: "\xC9diter le contenu\u2026",
          EditContentPrompt: "Tapez le nouveau contenu de la m\xE9moire en s\xE9parant les lignes par des espaces. S\u2019il y a autant de caract\xE8res que de bits, les donn\xE9es sont lues comme \xE9tant du binaire, sinon, comme de l'hexad\xE9cimal.",
          SaveContent: "Sauvegarder le contenu",
          LoadContent: "Charger le contenu\u2026",
          SwapROMRAM: "\xC9changer ROM et RAM"
        }
      },
      ROM: {
        tooltip: {
          title: "ROM (m\xE9moire morte)",
          desc: template("Stocke ${numWords} ligne$s{numWords} de ${numDataBits} bits${numDataBits}.")
        }
      },
      Register: {
        tooltip: {
          title: "Registre",
          desc: template("Stocke ${numBits} bit$s{numBits}.")
        },
        contextMenu: {
          ParamHasIncDec: "Avec incr\xE9mentaiton",
          Saturating: "Avec saturation"
        }
      },
      ShiftRegister: {
        tooltip: {
          title: "Registre \xE0 d\xE9calage",
          desc: template("Stocke ${numBits} bit$s{numBits} et les d\xE9cale \xE0 chaque activation.")
        }
      },
      ControlledInverter: {
        tooltip: {
          title: "Inverseur commut\xE9",
          desc: "Inverse ses entr\xE9es si le bit de contr\xF4le S vaut 1; sinon, les sorties sont \xE9gales aux entr\xE9es."
        }
      },
      TristateBuffer: {
        tooltip: "Sortie \xE0 3 \xE9tats"
      },
      Wire: {
        contextMenu: {
          AddMiddlePoint: "Ajouter un point interm\xE9diaire",
          AddPassthrough: "Ajouter une broche",
          CustomPropagationDelay: template("D\xE9lai de propagation sp\xE9cifique${current}\u2026"),
          CustomPropagationDelayDesc: template("D\xE9lai de propagation personnalis\xE9 en millisecondes pour cette connexion (laisser vide pour utiliser la valeur par d\xE9faut du circuit, actuellement de ${current} ms):"),
          WireColor: "Couleur du fil",
          WireColorBlack: "Noir (par d\xE9faut)",
          WireColorRed: "Rouge",
          WireColorBlue: "Bleu",
          WireColorYellow: "Jaune",
          WireColorGreen: "Vert",
          WireColorWhite: "Blanc",
          WireStyle: "Style",
          WireStyleDefault: "Par d\xE9faut",
          WireStyleAuto: "Auto",
          WireStyleStraight: "Ligne",
          WireStyleSquareHV: "H puis V",
          WireStyleSquareVH: "V puis H",
          WireStyleCurved: "Courbe",
          HiddenWire: "Masquer le fil"
        },
        timeline: {
          PropagatingValue: template("Propagation de la valeur ${val} sur le fil")
        }
      }
    },
    Dialogs: {
      Generic: {
        Close: "Fermer"
      },
      Share: {
        title: "Partager ce circuit",
        URL: "URL:",
        EmbedInIframe: "Inclusion via <iframe>:",
        EmbedWithWebComp: "Inclusion via un web component:",
        EmbedInMarkdown: "Inclusion en Markdown/Myst:"
      }
    }
  };
  var Strings_en = {
    plural: (n, plural, singular) => Math.abs(n) === 1 ? singular != null ? singular : "" : plural != null ? plural : "s",
    ComponentBar: {
      SectionNames: {
        InputOutput: "Input/ Output",
        Gates: "Gates",
        Layout: "Layout",
        Components: "Compo- nents",
        Custom: "Custom"
      },
      Labels: {
        More: "More",
        Less: "Less"
      },
      Components: RichStringEnum.withProps()({
        Input1: ["Input", "IN"],
        InputN: ["Multiple Inputs", "IN Mult."],
        Input8: ["Byte (8-Bit) Input", "IN (8-Bit)"],
        Clock: ["Clock Generator", "Clock"],
        Random: ["Random Input", "Random"],
        Output1: ["Output", "OUT"],
        OutputN: ["Multiple Outputs", "OUT Mult."],
        Output8: ["Byte (8-Bit) Output", "OUT (8-Bit)"],
        DisplayN: ["Value Display", "Display"],
        Display8: ["Byte (8-Bit) Display", "8-Bit Displ."],
        Display7Seg: ["7-Segment Display", "7-Segment"],
        Display16Seg: ["16-Segment Display", "16-Segment"],
        DisplayAscii: ["ASCII Character (7-Bit) Display", "Character"],
        DisplayBar: ["Bit Display as a Light Bar", "Bar"],
        ShiftDisplay: ["Display with Shift Buffer", "Shift Displ."],
        Passthrough1: ["Passthrough", "Passthrough"],
        PassthroughN: ["Passthrough with multiple inputs-outputs", "Passthr. (n)"],
        Label: ["Label", "Label"],
        Rectangle: ["Grouping Rectangle", "Group"],
        not: ["NOT Gate", "NOT"],
        buf: ["Buffer", "BUF"],
        tri: ["Tristate Buffer", "Tristate"],
        and: ["AND Gate", "AND"],
        or: ["OR Gate", "OR"],
        xor: ["XOR Gate", "XOR"],
        nand: ["NAND Gate", "NAND"],
        nor: ["NOR Gate", "NOR"],
        xnor: ["XNOR Gate", "XNOR"],
        imply: ["IMPLY Gate", "IMPLY"],
        nimply: ["NIMPLY Gate", "NIMPLY"],
        transfer: ["Fake 2-Input TRANSFER Gate", "TRANSF."],
        and3: ["3-Input AND Gate", "AND (3)"],
        or3: ["3-Input OR Gate", "OR (3)"],
        xor3: ["3-Input XOR Gate", "XOR (3)"],
        nand3: ["3-Input NAND Gate", "NAND (3)"],
        nor3: ["3-Input NOR Gate", "NOR (3)"],
        xnor3: ["3-Input XNOR Gate", "XNOR (3)"],
        and4: ["4-Input AND Gate", "AND (4)"],
        or4: ["4-Input AND Gate", "OR (4)"],
        xor4: ["4-Input AND Gate", "XOR (4)"],
        nand4: ["4-Input AND Gate", "NAND (4)"],
        nor4: ["4-Input AND Gate", "NOR (4)"],
        xnor4: ["4-Input AND Gate", "XNOR (4)"],
        ControlledInverter: ["Switched Inverter", "Switched Inv."],
        GateArray: ["Gate Array", "Gate Array"],
        TristateBufferArray: ["Tristate Buffer Array", "Tristate Arr."],
        HalfAdder: ["Half Adder", "Half Adder"],
        Adder: ["Full Adder", "Full Adder"],
        AdderArray: ["Adder Array", "Adder Arr."],
        ALU: ["Arithmetic and Logic Unit", "ALU"],
        Mux: ["Multiplexer", "Mux"],
        Mux2to1: ["2-to-1 Multiplexer (1 Control Bit)", "Mux 2-1"],
        Mux4to1: ["4-to-1 Multiplexer (2 Control Bit)", "Mux 4-1"],
        Mux8to1: ["8-to-1 Multiplexer (3 Control Bit)", "Mux 8-1"],
        Mux4to2: ["4-to-2 Multiplexer (1 Control Bit)", "Mux 4-2"],
        Mux8to2: ["8-to-2 Multiplexer (2 Control Bit)", "Mux 8-2"],
        Mux8to4: ["8-to-4 Multiplexer (1 Control Bit)", "Mux 8-4"],
        Mux16to8: ["16-to-8 Multiplexer (1 Control Bit)", "Mux 16-8"],
        Demux: ["Demultiplexer", "Demux"],
        Demux1to2: ["1-to-2 Demultiplexer (1 Control Bit)", "Demux 1-2"],
        Demux1to4: ["1-to-4 Demultiplexer (2 Control Bit)", "Demux 1-4"],
        Demux1to8: ["1-to-8 Demultiplexer (3 Control Bit)", "Demux 1-8"],
        Demux2to4: ["2-to-4 Demultiplexer (1 Control Bit)", "Demux 2-4"],
        Demux2to8: ["2-to-8 Demultiplexer (2 Control Bit)", "Demux 2-8"],
        Demux4to8: ["4-to-8 Demultiplexer (1 Control Bit)", "Demux 4-8"],
        Demux8to16: ["8-to-16 Demultiplexer (1 Control Bit)", "Demux 8-16"],
        LatchSR: ["SR Latch", "SR Latch"],
        FlipflopJK: ["JK Flip-Flop", "FF-JK"],
        FlipflopT: ["T Flip-Flop", "FF-T"],
        FlipflopD: ["D Flip-Flop", "FF-D"],
        Register: ["Register", "Register"],
        ShiftRegister: ["Shift Register", "Shift Reg."],
        RAM: ["RAM Module", "RAM"],
        ROM: ["ROM Module", "ROM"],
        Counter: ["4-Bit Counter", "Counter"],
        Decoder: ["Binary to One-of-N Decoder", "Decoder"],
        Decoder7Seg: ["7-Segment Decoder", "7-Seg. Dec."],
        Decoder16Seg: ["ASCII-to-16-Segment Decoder", "16-Seg. Dec."],
        DecoderBCD4: ["4-Bit-to-BCD Decoder", "BCD Dec."],
        Comparator: ["Comparator", "Compar."]
      })
    },
    Modes: {
      FULL: tuple("Admin", "In addition to the full mode, this enables features like hiding wire colors, setting inputs and output to undetermined values, create faulty components, etc."),
      DESIGN: tuple("Full", "All standard circuit-design features are enabled"),
      CONNECT: tuple("Connect", "You can move and connect components already on the canvas, but not add more components (the left component bar is not shown)"),
      TRYOUT: tuple("Tryout", "You can only change inputs to try out a already-designed circuit"),
      STATIC: tuple("Static", "Components are displayed without any possible interaction")
    },
    Orientations: {
      e: "Right (default)",
      s: "Down",
      w: "Left",
      n: "Up"
    },
    Settings: {
      Settings: "Settings",
      CircuitName: "Name:",
      DefaultFileName: "circuit",
      NameOfDownloadedFile: "This will be the name of the downloaded file.",
      animateWires: tuple("Animate wires", "If checked, wires are shown as animated to show the propagation direction."),
      hideWireColors: tuple("Hide wire colors", "If checked, wires are shown with a neutral color instead of showing whether they carry a 1 or a 0."),
      hideInputColors: tuple("Hide input colors", "If checked, inputs are shown with a neutral color, even if they still deliver a well determined value. Can be used together with hidden wire colors."),
      hideOutputColors: tuple("Hide output colors", "If checked, outputs are shown with a neutral color. Can be used together with hidden wire colors."),
      hideMemoryContent: tuple("Hide stored values", "If checked, latches, flip-flops, registers and other memory components don\u2019t show the content they store."),
      showGateTypes: tuple("Show gate types", "If checked, gates types are displayed textually on top of the gate symbol."),
      showDisconnectedPins: tuple("Always show pins", "If unchecked, disconnected component pins are hidden in modes where new connections can\u2019t be made (but stay visible otherwise)."),
      hideTooltips: tuple("Disable tooltips", "If checked, additional information in component tooltips (such as truth tables) won\u2019t be shown."),
      groupParallelWires: tuple("Group parallel wires", "If checked, parallel wires from one component to another will be grouped together as a thicker wire."),
      showHiddenWires: tuple("Show hidden wires", "If checked, hidden wires will still be shown."),
      showAnchors: tuple("Show anchors", "If checked, arrows will be shown to denote which component is anchored to which other component while moving."),
      showIds: tuple("Show IDs", "If checked, component IDs will be shown on top of them"),
      propagationDelay: "A 1 or 0 output on some wire will propagate to the other end of the wire after this propagation delay.",
      propagationDelayField: tuple("Propagation in", "ms"),
      zoomLevel: "The zoom level on the circuit components.",
      zoomLevelField: tuple("Zoom:", "%"),
      showUserDataLink: tuple("See ", "linked data"),
      userDataHeader: "This data is exported with the circuit:",
      wireStyle: "Wire style:"
    },
    Tests: {
      Title: "Tests",
      DefaultTestCaseName: "Test",
      DefaultTestSuiteName: "Test Suite",
      SetInputs: "Inputs",
      WantedOutputs: "Outputs",
      SetTheseInputs: "Set these inputs",
      Run: "Run",
      RunTestSuite: "Run test suite",
      DeleteTestCase: "Delete this test case",
      EditTestCaseName: "Rename this test case",
      EnterNewTestCaseName: "Enter the new name for this test case:",
      ComponentUsedInTestSuite: template("This component is used in test suites. Do you really want to delete it? The tests will be kept, but won\u2019t work until another component with this reference (\u201C${ref}\u201D) is added to the circuit.")
    },
    TopBar: {
      DirtyTooltip: "The circuit has been modified since the last download/save",
      CircuitNameTooltip: "Name of the circuit; click to change",
      SetCircuitName: "Set the name of the circuit (or leave empty to use the default name):",
      CustomComponentCaptionTooltip: "Name of the subcircuit currently being edited; click to change",
      CloseCircuit: "Back to the main circuit",
      Undo: tuple("Undo", "Undo the last action"),
      Redo: tuple("Redo", "Redo the last undone action or repeat the last action"),
      Download: tuple("Download", "Download the circuit (or the custom components with Option/Alt key down)"),
      Screenshot: tuple("Screenshot", "Download the circuit as an image (PNG or SVG with Option/Alt key down)"),
      Open: tuple("Open", "Open a previously downloaded circuit"),
      Reset: tuple("Reset", "Reset the state of this circuit"),
      TimelinePlay: tuple("Play", "Starts logical time"),
      TimelinePause: tuple("Pause", "Stops logical time"),
      TimelineStep: tuple("Step", "Moves logical time to the next scheduled event"),
      TimeLabel: "Time: ",
      Design: tuple("Design", "Create or modify the circuit"),
      Delete: tuple("Delete", "Delete elements from the circuit"),
      Move: tuple("Move", "Move the whole circuit"),
      Tests: tuple("Tests", "Show tests for the circuit")
    },
    Messages: {
      UnsupportedFileType: template("Unsupported file type: ${type}."),
      LoadedDefinitions: template("Loaded ${n} custom component definition$s{n}"),
      SavedToUrl: "Circuit saved to URL",
      SetAnchorPrompt: "Click on the component to anchor to",
      AnchorAdded: "Anchor added",
      CircularAnchorsForbidden: "Circular anchors are not supported.",
      NotImplemented: "This feature is not implemented yet.",
      NoPermission: "This action is not allowed in this mode.",
      ReallyCloseWindow: "Do you really want to close the window without saving the changes?",
      DevelopedBy: "Developed by",
      DidUndo: "Undo",
      DidRedo: "Redo",
      DidRepeat: "Repeat",
      NothingToUndo: "Nothing to undo",
      NothingToRedo: "Nothing to redo or repeat",
      NewTestCaseTitle: "Create a new test case",
      NewTestCaseSetName: "Enter the name of the new test case:",
      TestCaseInputToSet: template("Input$s{n} to set:"),
      TestCaseOuputToCheck: template("Output$s{n} to check:"),
      TooManyInputsForAutoTestCases: template("Cannot create test cases automatically for more than ${max} inputs."),
      AutoTestCasesWarning: template("This will create ${numCases} test cases, one for each combination of the ${numInputs} inputs. Do you want to continue?"),
      ComputingTestCases: "Generating test cases\u2026",
      RunningTests: "Running test cases\u2026"
    },
    Components: {
      Generic: {
        contextMenu: {
          Delete: "Delete",
          Reset: "Reset",
          MakeNewComponent: "Make New Component\u2026",
          MakeNewComponentFailed: "Cannot create new custom component.",
          MakeNewTestCase: "Make New Test Case\u2026",
          MakeAllTestCases: "Make All Test Cases\u2026",
          MakeNewTestCaseFailed: "Cannot create new test case.",
          SetIdentifier: "Set Identifier\u2026",
          ChangeIdentifier: tuple("Change Identifier (", ")\u2026"),
          SetIdentifierPrompt: "Choose the unique identifier to use for this component:",
          IdentifierCannotBeEmpty: "The identifier cannot be empty.",
          IdentifierAlreadyInUseShouldSwap: "The identifier is already in use. Do you want to swap the component identifiers?",
          SetAnchor: "Set Anchor\u2026",
          ClearAnchor: tuple("Remove Anchor (", ")"),
          Orientation: "Orientation",
          ChangeOrientationDesc: "Change the orientation with Command + double click on the component",
          LockPosition: "Lock Position",
          ShowAsUnknown: "Show As Unknown",
          ForceOutputSingle: "Force Output",
          ForceOutputMultiple: "Force an Output",
          Output: "Output",
          NormalOutput: "Normal Output",
          ForceAsUnknown: "Force as Unkown",
          ForceAs1: "Force as 1",
          ForceAs0: "Force as 0",
          ForceAsZ: "Force as High Impedance",
          ForceOutputDesc: "Force an output with Option + click on an output node",
          SetName: "Set Name\u2026",
          ChangeName: "Change Name\u2026",
          SetNamePrompt: "Choose the name to display or leave empty to remove it:",
          SetFontPrompt: tuple("Enter a font specification or leave empty to use the default value (", "):"),
          TriggerOn: "Trigger on",
          TriggerRisingEdge: "Rising Edge",
          TriggerFallingEdge: "Fallling Edge",
          ShowContent: "Show Content",
          ParamControlBitAtBottom: "Control Bit at Bottom",
          ParamControlBitsAtBottom: "Control Bits at Bottom",
          ParamNumInputs: tuple("Number of Inputs", template("${val} Input$s{val}")),
          ParamNumBits: tuple("Number of Bits", template("${val} Bit$s{val}")),
          ParamNumWords: tuple("Number of Lines", template("${val} Line$s{val}"))
        },
        InputCarryInDesc: "Cin (Previous Carry)",
        InputClockDesc: "Clock",
        InputClearDesc: "C (Clear, set to 0)",
        InputPresetDesc: "P (Preset, set to 1)",
        InputSetDesc: "S (Set, set to 1)",
        InputResetDesc: "R (Reset, set to 0)",
        InputDataDesc: "D (Data)",
        InputWriteEnableDesc: "WE (Write Enable)",
        OutputSumDesc: "S (Sum)",
        OutputCarryDesc: "C (Carry)",
        OutputCarryOutDesc: "Cout (Carry)",
        OutputQDesc: "Q (Normal Output)",
        OutputQBarDesc: "Q\u0305 (Inverted Output)"
      },
      Custom: {
        MenuButtonSuffix: " (custom component)",
        contextMenu: {
          ChangeName: "Rename\u2026",
          ChangeNamePrompt: "Enter the name of this custom component:",
          ChangeNameEmpty: "The name cannot be empty.",
          ChangeCircuit: "Edit Circuit",
          Delete: "Delete Custom Component",
          EditFromComponentMessage: "You can edit this custom component by right-clicking such a component in the circuit.",
          CannotDeleteInUse: "Cannot delete this custom component because it is in use in the circuit.",
          CannotDeleteInUseBy: template("Cannot delete this custom component because it is used to define another component (${caption})."),
          ConfirmDelete: "Are you sure you want to delete this custom component?"
        },
        tooltip: {
          titleSuffix: " (Custom Component)",
          desc: "This custom component computes its outputs according to the circuit you have defined."
        },
        messages: {
          EmptySelection: "No components are selected.",
          NoInput: "No input is selected.",
          NoOutput: "No output is selected.",
          InputsOutputsMustHaveNames: "All inputs and outputs must have unique (non-dynamic) names.",
          MissingComponents: template("The following components are connected to outputs but are missing from selection: ${list}."),
          NoWires: "There are no wires between the selected components.",
          UselessComponents: template("The following components are not connected to outputs and are useless: ${list}."),
          CannotIncludeClock: "Clocks cannot be included in custom components. Add a normal input, which can later be connected to an external clock.",
          CannotBeModified: "This custom component cannot be modified in this mode.",
          EnterCaptionPrompt: "Entrez le nom (unique) du composant personnalis\xE9:",
          ComponentAlreadyExists: template("A custom component definition with id '${id}' already exists."),
          InputsOutputsChanged: "The inputs and outputs have changed and some connections may be removed by adapting the circuit. Do you want to continue?",
          NotInMainEditor: "Please go back to the main editor to edit the custom circuit of this component."
        }
      },
      Adder: {
        tooltip: {
          title: "Adder",
          desc: "Adds two bits A and B together with an input carry Cin, and outputs a sum bit S and an output carry Cout."
        }
      },
      AdderArray: {
        tooltip: {
          title: template("${numBits}-Bit Adder Array"),
          desc: "Adds the two inputs numbers A et B together with an input carry Cin, and outputs sum bits S and an output carry Cout."
        }
      },
      ALU: {
        "A+B": tuple("+", "Addition"),
        "A-B": tuple("A\u2013B", "Subtraction (A \u2013 B)"),
        "B-A": tuple("B\u2013A", "Subtraction (B \u2013 A)"),
        "A+1": tuple("A+1", "A + 1"),
        "A-1": tuple("A\u20131", "A \u2013 1"),
        "-A": tuple("\u2013A", "Negation of A"),
        "A*2": tuple("A\xD72", "Addition of A to itself (A \xD7 2)"),
        "A/2": tuple("A/2", "Arithmetic right shift by 1 (A/2)"),
        "A|B": tuple("OR", "Disjunction (A OR B)"),
        "A&B": tuple("AND", "Conjunction (A AND B)"),
        "A|~B": tuple("ORn", "A OR NOT(B)"),
        "A&~B": tuple("ANDn", "A AND NOT(B)"),
        "~A": tuple("A\u0305", "Inversion of A"),
        "A^B": tuple("XOR", "Excl. Disjunction (A XOR B)"),
        "A<<": tuple("<<", "Logical Left Shift by 1 of A"),
        "A>>": tuple(">>", "Logical Right Shift by 1 of A"),
        InputCinDesc: "input carry",
        OutputCoutDesc: "output carry",
        tooltip: {
          title: "Arithmetic and Logic Unit (ALU)",
          CurrentlyCarriesOut: "Currently carries out",
          SomeUnknownOperation: "an unknown operation",
          ThisOperation: "operation"
        },
        contextMenu: {
          toggleShowOp: "Show Operation",
          ParamUseExtendedOpcode: "Use Extended Opcode"
        }
      },
      Clock: {
        tooltip: {
          title: "Clock",
          period: tuple("Period: ", " ms"),
          dutycycle: tuple("Duty cycle: ", "%"),
          phase: tuple("Phase: ", " ms")
        },
        contextMenu: {
          Period: "Period",
          CustomPeriod: "Other",
          SetPeriodMillis: "Enter the period in milliseconds:",
          InvalidPeriod: "The period must be a positive number.",
          ReplaceWithInput: "Replace with Input"
        },
        timeline: {
          NextRisingEdge: "Next rising edge of the clock",
          NextFallingEdge: "Next falling edge of the clock"
        }
      },
      Comparator: {
        tooltip: {
          title: "Comparator",
          desc: "Comparator between two bits A and B, enabled by an input E."
        }
      },
      Counter: {
        tooltip: {
          title: "Counter",
          desc: "4-bit counter."
        },
        contextMenu: {
          DisplayTempl: template("${desc} Display"),
          DisplayNone: "No",
          DisplayDecimal: "Decimal",
          DisplayHex: "Hexadecimal"
        }
      },
      Decoder: {
        tooltip: {
          title: "Binary Decoder",
          desc: template("Takes as input a binary number coded on ${numFrom} bit$s{numFrom} and activates the corresponding output among ${numTo} (currently, ${n}).")
        }
      },
      Decoder7Seg: {
        tooltip: "7-Segment Decoder"
      },
      Decoder16Seg: {
        tooltip: "7-Bit ASCII to 16-Segment Decoder"
      },
      DecoderBCD4: {
        tooltip: "4-Bit to BCD (Binary-Coded Decimal) Decoder"
      },
      Demux: {
        tooltip: template("${from}-to-${to} Demultiplexer")
      },
      FlipflopD: {
        tooltip: {
          title: "D Flip-Flop",
          desc: "Stores one bit."
        }
      },
      FlipflopJK: {
        InputJDesc: "J (Jump, set to 1)",
        InputKDesc: "K (Kill, set to 0)",
        tooltip: {
          title: "JK Flip-Flop",
          desc: "Stores one bit."
        }
      },
      FlipflopT: {
        InputTDesc: "T (Toggle)",
        tooltip: {
          title: "T Flip-Flop",
          desc: "Stores one bit."
        }
      },
      Gate: {
        not: tuple("NOT", "NOT", "The output is the inverted input."),
        buf: tuple("BUF", "BUF", "The output is the same as the input."),
        and: tuple("AND", "AND", "The output is 1 when all inputs are 1."),
        or: tuple("OR", "OR", "The output is 1 when at least one of the inputs is 1."),
        xor: tuple("XOR", "XOR", "The output is 1 when an odd number of inputs are 1."),
        nand: tuple("NAND", "NAND", "Inverted AND gate: the output is 1 unless all inputs are 1."),
        nor: tuple("NOR", "NOR", "Inverted OR gate: the output is 1 when all inputs are 0."),
        xnor: tuple("XNOR", "XNOR", "Inverted XOR gate: the output is 1 when an even number of inputs are 1."),
        imply: tuple("IMPLY", "IMPL", "The output is 1 if the first input is 0 or if both inputs are 1."),
        rimply: tuple("IMPLY (bis)", "IMPL", "The output is 1 if the second input is 0 or if both inputs are 1."),
        nimply: tuple("NIMPLY", "N-IMPL", "Inverted IMPLY gate: the output is only 1 if the first input is 1 and the second one 0."),
        rnimply: tuple("NIMPLY (bis)", "N-IMPL", "Inverted IMPLY gate: la sortie ne vaut 1 que lorsque la premi\xE8re entr\xE9e vaut 0 et la seconde 1."),
        txa: tuple("TRANSFER-A", void 0, "The output is the same as the first input; the second input is ignored."),
        txb: tuple("TRANSFER-B", void 0, "The output is the same as the second input; the first input is ignored."),
        txna: tuple("TRANSFER-NOT-A", void 0, "The output is the inverted first input; the second input is ignored."),
        txnb: tuple("TRANSFER-NOT-B", void 0, "The output is the inverted second input; the first input is ignored."),
        tooltip: {
          GateTitle: (gateType) => mods(gateType, " Gate"),
          UnknownGate: "Unknown Gate",
          Input: "Input",
          Output: "Output",
          CurrentlyDelivers: "It currently delivers",
          ShouldCurrentlyDeliver: "it should currently deliver",
          UndeterminedOutputBecauseInputUnknown: "an unknown output as its input is unknown. Its truth table is:",
          UndeterminedOutputBecauseInputsUnknown: "an unknown output as not all inputs are known. Its truth table is:",
          ThisOutput: "the output",
          BecauseInputIs: "because its input is",
          AccordingToTruthTable: "according to the following truth table:",
          Inverter: tuple("Inverter (", " gate)"),
          Buffer: tuple("Buffer (", " gate)")
        },
        contextMenu: {
          ReplaceBy: "Replace By",
          GateTempl: template("${type} Gate"),
          ShowAs: "Show As",
          NormalGateTempl: template("Normal ${type} Gate"),
          UnknownGate: "Unknown Gate (with \u201C?\u201D)",
          VariantChangeDesc: "Switch to a variant with Shift + double-click on the gate"
        }
      },
      HalfAdder: {
        tooltip: {
          title: "Half Adder",
          desc: "Adds two bits A and B. Outputs a sum bit S and an output carry bit C."
        }
      },
      Input: {
        tooltip: {
          title: template("Input (${numBits}-Bit)")
        },
        contextMenu: {
          LockValue: "Lock This Value",
          PushButton: "Push Button",
          ToggleButton: "Toggle Button",
          ReplaceWithClock: "Replace With Clock",
          InputSetFromOutside: "Input set from outside"
        }
      },
      Random: {
        tooltip: {
          title: "Random Input",
          desc: tuple("When triggered by the clock, the output value will be 1 with probability ", ".")
        },
        contextMenu: {
          ShowProb: "Show Probability"
        }
      },
      Rectangle: {
        contextMenu: {
          Size: "Size",
          SizePrompt: "Enter the size of this rectangle:",
          Rounded: "Rounded",
          WithBackgroundColor: "With Background Color",
          SetTitle: "Add Title\u2026",
          ChangeTitle: "Change Title\u2026",
          SetTitlePrompt: "Enter the title to display or leave empty to remove it:",
          InsideFrame: "Inside Frame",
          Font: "Font",
          Color: "Color",
          ColorYellow: "Yellow",
          ColorRed: "Red",
          ColorGreen: "Green",
          ColorBlue: "Blue",
          ColorTurquoise: "Turquoise",
          ColorGrey: "Grey",
          Border: "Border",
          BorderNone: "None",
          Border1px: "Fine (1 pixel)",
          Border2px: "Medium (2 pixels)",
          Border3px: "Thick (3 pixels)",
          Border5px: "Very Thick (5 pixels)",
          Border10px: "Huge (10 pixels)",
          TitlePlacement: "Title Placement",
          PlacementTop: "Top",
          PlacementTopLeft: "Top Left",
          PlacementTopRight: "Top Right",
          PlacementBottom: "Bottom",
          PlacementBottomLeft: "Bottom Left",
          PlacementBottomRight: "Bottom Right",
          PlacementLeft: "Left",
          PlacementRight: "Right",
          PlacementCenter: "Center"
        }
      },
      Label: {
        contextMenu: {
          ChangeText: "Change Text\u2026",
          ChangeTextPrompt: "Type the text to display:",
          Font: "Font\u2026"
        }
      },
      LatchSR: {
        tooltip: {
          title: "SR Latch",
          desc: "Stores one bit."
        }
      },
      Mux: {
        tooltip: template("${from}-to-${to} Multiplexer")
      },
      MuxDemux: {
        contextMenu: {
          ShowWiring: "Show Internal Wiring",
          UseZForDisconnected: "Use Z For Disconnected Pins",
          ParamNumFrom: tuple("Number of Inputs", template("${val} Input$s{val}")),
          ParamNumTo: tuple("Number of Outputs", template("${val} Output$s{val}"))
        }
      },
      Output: {
        tooltip: {
          title: template("Output (${numBits}-Bit)")
        }
      },
      Display7Seg: {
        tooltip: "7-Segment Display"
      },
      Display16Seg: {
        tooltip: "16-Segment Display"
      },
      DisplayAscii: {
        tooltip: {
          title: "ASCII Character Display",
          desc: tuple("Displays the ASCII character represented by the 7 inputs, currently ", "."),
          CurrentlyUndefined: "As not all inputs are known, this character is currently undefined.",
          CurrentlyThisCharacter: "Currently, this character is",
          WhichIsNotPrintable: " (a non-printable character)."
        },
        contextMenu: {
          AdditionalDisplay: "Additional Display",
          DisplayNone: "None",
          DisplayDecimal: "Decimal Value",
          DisplayHex: "Hexadecimal Value",
          ChangeDisplayDesc: "Change the additional display with a double-click on the component"
        }
      },
      DisplayBar: {
        tooltip: {
          title: "Bar/LED Display",
          ValueUnknown: "Its state is undefined because its input is unknown.",
          ValueZ: "Its state is undefined because its input is floating (high impedance).",
          Value1: tuple("It is currently on because its input is ", "."),
          Value0: tuple("It is currently off because its input is ", ".")
        },
        contextMenu: {
          TransparentWhenOff: "Transparent When Off",
          Display: "Display",
          DisplayVerticalBar: "Vertical Bar",
          DisplayHorizontalBar: "Horizontal Bar",
          DisplaySmallSquare: "Small Square",
          DisplayLargeSquare: "Large Square",
          DisplayChangeDesc: "Change display types with a double-click on the component",
          Color: "Color",
          ColorGreen: "Green",
          ColorRed: "Red",
          ColorYellow: "Yellow"
        }
      },
      Display: {
        tooltip: {
          title: template("${numBits}-Bit Display"),
          desc: tuple(template("Displays the ${radixStr} value of its ${numBits} input$s{numBits}, which is currently "), "."),
          RadixBinary: "binary",
          RadixDecimal: "decimal",
          RadixSignedDecimal: "signed decimal",
          RadixHexadecimal: "hexadecimal",
          RadixGeneric: template("base-${radix}"),
          CurrentlyUndefined: "As not all inputs are known, this value is currently undefined."
        },
        contextMenu: {
          DisplayAs: "Display as",
          DisplayNone: "None",
          DisplayAsBinary: "Binary (Base 2)",
          DisplayAsDecimal: "Decimal (Base 10)",
          DisplayAsSignedDecimal: "Signed Decimal",
          DisplayAsOctal: "Octal (Base 8)",
          DisplayAsHexadecimal: "Hexadecimal (Base 16)",
          DisplayAsUnknown: "Unkown"
        }
      },
      ShiftDisplay: {
        tooltip: "Shift Buffer Display",
        contextMenu: {
          Decoding: "Decoding",
          DecodingNone: "None",
          DecodingOctal: "Octal",
          DecodingHex: "Hexadecimal",
          DecodingAscii7: "ASCII (on 7 bits)",
          DecodingAscii8: "ASCII (on 8 bits)",
          DecodingUint4: "4-Bit Integer",
          DecodingInt4: "4-Bit Signed Integer",
          DecodingUint8: "8-Bit Integer",
          DecodingInt8: "8-Bit Signed Integer",
          DecodingUint16: "16-Bit Integer",
          DecodingInt16: "16-Bit Signed Integer",
          DecodingChangeWarning: "Changing the decoding may truncate the stored value.",
          Grouping: "Group Data",
          GroupingNone: "No Grouping",
          GroupBy: template("By ${n}")
        },
        EmptyCaption: "(empty)"
      },
      Passthrough: {
        tooltip: "Passthrough. Only used to arrange wires.",
        contextMenu: {
          Slant: "Slant",
          SlantNone: "None",
          SlantRight: "Rightward By 45\xB0",
          SlantLeft: "Leftward By 45\xB0"
        }
      },
      GateArray: {
        tooltip: {
          title: "Gate Array",
          desc: template("Computes in parallel several times the chosen logical operation, which currently is ${op}.")
        },
        contextMenu: {
          Type: "Type",
          ShowAsUnknown: "Hide Type"
        }
      },
      TristateBufferArray: {
        tooltip: {
          title: "Tristate Buffer Array",
          desc: "Represents multiple tristate buffers switched by a single control bit."
        }
      },
      RAM: {
        tooltip: {
          title: "RAM (Random-Access Memory)",
          desc: template("Stores ${numWords} row$s{numWords} of ${numDataBits} bit$s{numDataBits}.")
        },
        contextMenu: {
          SelectedDataDisplay: "Addressed Data Display",
          EditContent: "Edit Content\u2026",
          EditContentPrompt: "Type in the new memory content, separating lines with spaces. If there are as many characters as bits, the input is parsed as a binary string, and otherwise as a hexadecimal string.",
          SaveContent: "Save Content",
          LoadContent: "Load Content\u2026",
          SwapROMRAM: "Swap ROM/RAM"
        }
      },
      ROM: {
        tooltip: {
          title: "ROM (Read-Only Memory)",
          desc: template("Stores ${numWords} row$s{numWords} of ${numDataBits} bit$s{numDataBits}.")
        }
      },
      Register: {
        tooltip: {
          title: "Register",
          desc: template("Stores ${numBits} bit$s{numBits}.")
        },
        contextMenu: {
          ParamHasIncDec: "With Increment/Decrement",
          Saturating: "Saturating"
        }
      },
      ShiftRegister: {
        tooltip: {
          title: "Shift Register",
          desc: template("Stores ${numBits} bit$s{numBits} and shifts them left or right at each activation.")
        }
      },
      ControlledInverter: {
        tooltip: {
          title: "Switched Inverter",
          desc: "Inverts its inputs when the control bit S is on; otherwise, just outputs the inputs."
        }
      },
      TristateBuffer: {
        tooltip: "Tristate Buffer"
      },
      Wire: {
        contextMenu: {
          AddMiddlePoint: "Add Middle Point",
          AddPassthrough: "Add Passthrough",
          CustomPropagationDelay: template("Specific Propagation Delay${current}\u2026"),
          CustomPropagationDelayDesc: template("Specific propagation delay in milliseconds for this connection (leave empty to use the default value for the circuit, which currently is ${current} ms):"),
          WireColor: "Wire Color",
          WireColorBlack: "Black (default)",
          WireColorRed: "Red",
          WireColorGreen: "Green",
          WireColorBlue: "Blue",
          WireColorYellow: "Yellow",
          WireColorWhite: "White",
          WireStyle: "Style",
          WireStyleDefault: "By Default",
          WireStyleAuto: "Auto",
          WireStyleStraight: "Straight",
          WireStyleSquareHV: "H then V",
          WireStyleSquareVH: "V then H",
          WireStyleCurved: "Curve",
          HiddenWire: "Hide Wire"
        },
        timeline: {
          PropagatingValue: template("Propagation of value ${val} on wire")
        }
      }
    },
    Dialogs: {
      Generic: {
        Close: "Close"
      },
      Share: {
        title: "Share Circuit",
        URL: "URL:",
        EmbedInIframe: "Embed using <iframe>:",
        EmbedWithWebComp: "Embed with a web component:",
        EmbedInMarkdown: "Embed in Markdown/Myst:"
      }
    }
  };
  var langs = {
    fr: Strings_fr,
    en: Strings_en
  };
  function isLang(lang) {
    return lang in langs;
  }
  __name(isLang, "isLang");
  function setLang(l) {
    S = langs[l];
    _lang = l;
  }
  __name(setLang, "setLang");
  function getLang() {
    return _lang;
  }
  __name(getLang, "getLang");
  var DefaultLang = "en";
  var S = langs[DefaultLang];
  var _lang = DefaultLang;

  // simulator/src/TestSuite.ts
  function buildMap(repr, compList, isInputOutput) {
    const map = /* @__PURE__ */ new Map();
    for (const [ref, value] of Object.entries(repr)) {
      const comp = compList.get(ref);
      if (isInputOutput(comp)) {
        map.set(comp, value);
      } else {
        map.set(ref, value);
      }
    }
    return map;
  }
  __name(buildMap, "buildMap");
  function fixMap(map, compList, isInputOutput) {
    for (const [k, v] of map.entries()) {
      if (isString(k)) {
        const comp = compList.get(k);
        if (isInputOutput(comp)) {
          map.delete(k);
          map.set(comp, v);
        }
      }
    }
  }
  __name(fixMap, "fixMap");
  function isInput(comp) {
    return (comp == null ? void 0 : comp.def.type) === ComponentTypeInput;
  }
  __name(isInput, "isInput");
  function isOutput(comp) {
    return (comp == null ? void 0 : comp.def.type) === ComponentTypeOutput;
  }
  __name(isOutput, "isOutput");
  var TestCaseCombinational = class {
    static get Repr() {
      return t3.intersection([
        t3.type({
          in: t3.record(t3.string, InputOutputValueRepr),
          out: t3.record(t3.string, InputOutputValueRepr)
        }),
        t3.partial({
          name: t3.string,
          stopOnFail: t3.boolean
        })
      ], "TestCaseCombinational");
    }
    constructor(repr, compList) {
      var _a;
      if (repr !== void 0) {
        this.name = repr.name;
        this.in = buildMap(repr.in, compList, isInput);
        this.out = buildMap(repr.out, compList, isOutput);
        this.stopOnFail = (_a = repr.stopOnFail) != null ? _a : false;
      } else {
        this.name = S.Tests.DefaultTestCaseName;
        this.in = /* @__PURE__ */ new Map();
        this.out = /* @__PURE__ */ new Map();
        this.stopOnFail = false;
      }
    }
    tryFixReferences(compList) {
      fixMap(this.in, compList, isInput);
      fixMap(this.out, compList, isOutput);
    }
    toJSON() {
      const mapRepr = /* @__PURE__ */ __name((map) => Object.fromEntries(
        [...map.entries()].map(
          ([k, v]) => {
            var _a;
            return [isString(k) ? k : (_a = k.ref) != null ? _a : "?", v];
          }
        )
      ), "mapRepr");
      return {
        name: this.name,
        in: mapRepr(this.in),
        out: mapRepr(this.out),
        stopOnFail: this.stopOnFail === true ? true : void 0
      };
    }
  };
  __name(TestCaseCombinational, "TestCaseCombinational");
  var TestSuite = class {
    static get Repr() {
      return t3.intersection([
        t3.type({
          cases: t3.array(TestCaseCombinational.Repr)
        }),
        t3.partial({
          name: t3.string,
          hidden: t3.boolean
        })
      ], "TestSuite");
    }
    static get ReprArray() {
      return t3.array(TestSuite.Repr);
    }
    constructor(reprAndComps) {
      var _a;
      if (reprAndComps !== void 0) {
        const [repr, compList] = reprAndComps;
        this.name = repr.name;
        this.isHidden = (_a = repr.hidden) != null ? _a : false;
        this.testCases = repr.cases.map((tc) => new TestCaseCombinational(tc, compList));
      } else {
        this.name = void 0;
        this.isHidden = false;
        this.testCases = [];
      }
    }
    toJSON() {
      return {
        name: this.name,
        hidden: this.isHidden === true ? true : void 0,
        cases: this.testCases.map((tc) => tc.toJSON())
      };
    }
  };
  __name(TestSuite, "TestSuite");
  var TestCaseResult = {
    Pass: { _tag: "pass" },
    Skip: { _tag: "skip" },
    Fail: (mismatches) => ({ _tag: "fail", mismatches }),
    Error: (msg) => ({ _tag: "error", msg })
  };
  var TestSuiteResults = class {
    constructor(testSuite) {
      this.testSuite = testSuite;
      this.testCaseResults = [];
    }
    addTestCaseResult(testCase, result) {
      this.testCaseResults.push([testCase, result]);
    }
    isAllPass() {
      return this.testCaseResults.every(([, result]) => result._tag === "pass");
    }
    dump() {
      console.group(`Test Suite Results for ${this.testSuite.name}`);
      for (const [testCase, result] of this.testCaseResults) {
        console.group(`Test Case ${testCase.name}`);
        if (result._tag === "pass") {
          console.log("PASS");
        } else if (result._tag === "fail") {
          const mismatches = result.mismatches.map((m) => `${m.output.ref}: ${reprForLogicValues(m.actual, false)} instead of ${reprForLogicValues(m.expected, false)}`);
          console.log("FAIL - mismatches: " + mismatches.join(", "));
        } else if (result._tag === "error") {
          console.log(`ERROR - ${result.msg}`);
        }
        console.groupEnd();
      }
      console.groupEnd();
    }
  };
  __name(TestSuiteResults, "TestSuiteResults");
  var TestSuites = class {
    constructor(parent) {
      this.parent = parent;
      this._testSuites = [];
    }
    get suites() {
      return this._testSuites;
    }
    totalCases() {
      return this._testSuites.reduce((acc, suite) => acc + suite.testCases.length, 0);
    }
    set(testSuites) {
      this._testSuites.length = 0;
      this._testSuites.push(...testSuites);
    }
    push(testSuite) {
      this._testSuites.push(testSuite);
    }
    hasReferenceTo(ref) {
      if (ref === void 0) {
        return false;
      }
      const isRef = /* @__PURE__ */ __name((s, ref2) => isString(s) ? s === ref2 : s.ref === ref2, "isRef");
      for (const suite of this._testSuites) {
        for (const testCase of suite.testCases) {
          for (const input2 of testCase.in.keys()) {
            if (isRef(input2, ref)) {
              return true;
            }
          }
          for (const output of testCase.out.keys()) {
            if (isRef(output, ref)) {
              return true;
            }
          }
        }
      }
      return false;
    }
  };
  __name(TestSuites, "TestSuites");

  // node_modules/bezier-js/src/utils.js
  var { abs, cos, sin, acos, atan2, sqrt, pow } = Math;
  function crt(v) {
    return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);
  }
  __name(crt, "crt");
  var pi = Math.PI;
  var tau = 2 * pi;
  var quart = pi / 2;
  var epsilon = 1e-6;
  var nMax = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var nMin = Number.MIN_SAFE_INTEGER || -9007199254740991;
  var ZERO = { x: 0, y: 0, z: 0 };
  var utils = {
    // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
    Tvalues: [
      -0.06405689286260563,
      0.06405689286260563,
      -0.1911188674736163,
      0.1911188674736163,
      -0.3150426796961634,
      0.3150426796961634,
      -0.4337935076260451,
      0.4337935076260451,
      -0.5454214713888396,
      0.5454214713888396,
      -0.6480936519369755,
      0.6480936519369755,
      -0.7401241915785544,
      0.7401241915785544,
      -0.820001985973903,
      0.820001985973903,
      -0.8864155270044011,
      0.8864155270044011,
      -0.9382745520027328,
      0.9382745520027328,
      -0.9747285559713095,
      0.9747285559713095,
      -0.9951872199970213,
      0.9951872199970213
    ],
    // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
    Cvalues: [
      0.12793819534675216,
      0.12793819534675216,
      0.1258374563468283,
      0.1258374563468283,
      0.12167047292780339,
      0.12167047292780339,
      0.1155056680537256,
      0.1155056680537256,
      0.10744427011596563,
      0.10744427011596563,
      0.09761865210411388,
      0.09761865210411388,
      0.08619016153195327,
      0.08619016153195327,
      0.0733464814110803,
      0.0733464814110803,
      0.05929858491543678,
      0.05929858491543678,
      0.04427743881741981,
      0.04427743881741981,
      0.028531388628933663,
      0.028531388628933663,
      0.0123412297999872,
      0.0123412297999872
    ],
    arcfn: function(t38, derivativeFn) {
      const d = derivativeFn(t38);
      let l = d.x * d.x + d.y * d.y;
      if (typeof d.z !== "undefined") {
        l += d.z * d.z;
      }
      return sqrt(l);
    },
    compute: function(t38, points, _3d) {
      if (t38 === 0) {
        points[0].t = 0;
        return points[0];
      }
      const order2 = points.length - 1;
      if (t38 === 1) {
        points[order2].t = 1;
        return points[order2];
      }
      const mt = 1 - t38;
      let p = points;
      if (order2 === 0) {
        points[0].t = t38;
        return points[0];
      }
      if (order2 === 1) {
        const ret = {
          x: mt * p[0].x + t38 * p[1].x,
          y: mt * p[0].y + t38 * p[1].y,
          t: t38
        };
        if (_3d) {
          ret.z = mt * p[0].z + t38 * p[1].z;
        }
        return ret;
      }
      if (order2 < 4) {
        let mt2 = mt * mt, t210 = t38 * t38, a2, b2, c, d = 0;
        if (order2 === 2) {
          p = [p[0], p[1], p[2], ZERO];
          a2 = mt2;
          b2 = mt * t38 * 2;
          c = t210;
        } else if (order2 === 3) {
          a2 = mt2 * mt;
          b2 = mt2 * t38 * 3;
          c = mt * t210 * 3;
          d = t38 * t210;
        }
        const ret = {
          x: a2 * p[0].x + b2 * p[1].x + c * p[2].x + d * p[3].x,
          y: a2 * p[0].y + b2 * p[1].y + c * p[2].y + d * p[3].y,
          t: t38
        };
        if (_3d) {
          ret.z = a2 * p[0].z + b2 * p[1].z + c * p[2].z + d * p[3].z;
        }
        return ret;
      }
      const dCpts = JSON.parse(JSON.stringify(points));
      while (dCpts.length > 1) {
        for (let i2 = 0; i2 < dCpts.length - 1; i2++) {
          dCpts[i2] = {
            x: dCpts[i2].x + (dCpts[i2 + 1].x - dCpts[i2].x) * t38,
            y: dCpts[i2].y + (dCpts[i2 + 1].y - dCpts[i2].y) * t38
          };
          if (typeof dCpts[i2].z !== "undefined") {
            dCpts[i2].z = dCpts[i2].z + (dCpts[i2 + 1].z - dCpts[i2].z) * t38;
          }
        }
        dCpts.splice(dCpts.length - 1, 1);
      }
      dCpts[0].t = t38;
      return dCpts[0];
    },
    computeWithRatios: function(t38, points, ratios, _3d) {
      const mt = 1 - t38, r = ratios, p = points;
      let f1 = r[0], f2 = r[1], f3 = r[2], f4 = r[3], d;
      f1 *= mt;
      f2 *= t38;
      if (p.length === 2) {
        d = f1 + f2;
        return {
          x: (f1 * p[0].x + f2 * p[1].x) / d,
          y: (f1 * p[0].y + f2 * p[1].y) / d,
          z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,
          t: t38
        };
      }
      f1 *= mt;
      f2 *= 2 * mt;
      f3 *= t38 * t38;
      if (p.length === 3) {
        d = f1 + f2 + f3;
        return {
          x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,
          y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,
          z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,
          t: t38
        };
      }
      f1 *= mt;
      f2 *= 1.5 * mt;
      f3 *= 3 * mt;
      f4 *= t38 * t38 * t38;
      if (p.length === 4) {
        d = f1 + f2 + f3 + f4;
        return {
          x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,
          y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,
          z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,
          t: t38
        };
      }
    },
    derive: function(points, _3d) {
      const dpoints = [];
      for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {
        const list = [];
        for (let j = 0, dpt; j < c; j++) {
          dpt = {
            x: c * (p[j + 1].x - p[j].x),
            y: c * (p[j + 1].y - p[j].y)
          };
          if (_3d) {
            dpt.z = c * (p[j + 1].z - p[j].z);
          }
          list.push(dpt);
        }
        dpoints.push(list);
        p = list;
      }
      return dpoints;
    },
    between: function(v, m, M) {
      return m <= v && v <= M || utils.approximately(v, m) || utils.approximately(v, M);
    },
    approximately: function(a2, b2, precision) {
      return abs(a2 - b2) <= (precision || epsilon);
    },
    length: function(derivativeFn) {
      const z = 0.5, len = utils.Tvalues.length;
      let sum = 0;
      for (let i2 = 0, t38; i2 < len; i2++) {
        t38 = z * utils.Tvalues[i2] + z;
        sum += utils.Cvalues[i2] * utils.arcfn(t38, derivativeFn);
      }
      return z * sum;
    },
    map: function(v, ds, de, ts, te) {
      const d1 = de - ds, d2 = te - ts, v2 = v - ds, r = v2 / d1;
      return ts + d2 * r;
    },
    lerp: function(r, v1, v2) {
      const ret = {
        x: v1.x + r * (v2.x - v1.x),
        y: v1.y + r * (v2.y - v1.y)
      };
      if (v1.z !== void 0 && v2.z !== void 0) {
        ret.z = v1.z + r * (v2.z - v1.z);
      }
      return ret;
    },
    pointToString: function(p) {
      let s = p.x + "/" + p.y;
      if (typeof p.z !== "undefined") {
        s += "/" + p.z;
      }
      return s;
    },
    pointsToString: function(points) {
      return "[" + points.map(utils.pointToString).join(", ") + "]";
    },
    copy: function(obj) {
      return JSON.parse(JSON.stringify(obj));
    },
    angle: function(o, v1, v2) {
      const dx1 = v1.x - o.x, dy1 = v1.y - o.y, dx2 = v2.x - o.x, dy2 = v2.y - o.y, cross = dx1 * dy2 - dy1 * dx2, dot = dx1 * dx2 + dy1 * dy2;
      return atan2(cross, dot);
    },
    // round as string, to avoid rounding errors
    round: function(v, d) {
      const s = "" + v;
      const pos = s.indexOf(".");
      return parseFloat(s.substring(0, pos + 1 + d));
    },
    dist: function(p1, p2) {
      const dx = p1.x - p2.x, dy = p1.y - p2.y;
      return sqrt(dx * dx + dy * dy);
    },
    closest: function(LUT, point) {
      let mdist = pow(2, 63), mpos, d;
      LUT.forEach(function(p, idx) {
        d = utils.dist(point, p);
        if (d < mdist) {
          mdist = d;
          mpos = idx;
        }
      });
      return { mdist, mpos };
    },
    abcratio: function(t38, n) {
      if (n !== 2 && n !== 3) {
        return false;
      }
      if (typeof t38 === "undefined") {
        t38 = 0.5;
      } else if (t38 === 0 || t38 === 1) {
        return t38;
      }
      const bottom2 = pow(t38, n) + pow(1 - t38, n), top2 = bottom2 - 1;
      return abs(top2 / bottom2);
    },
    projectionratio: function(t38, n) {
      if (n !== 2 && n !== 3) {
        return false;
      }
      if (typeof t38 === "undefined") {
        t38 = 0.5;
      } else if (t38 === 0 || t38 === 1) {
        return t38;
      }
      const top2 = pow(1 - t38, n), bottom2 = pow(t38, n) + top2;
      return top2 / bottom2;
    },
    lli8: function(x1, y1, x2, y2, x3, y3, x4, y4) {
      const nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4), ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4), d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
      if (d == 0) {
        return false;
      }
      return { x: nx / d, y: ny / d };
    },
    lli4: function(p1, p2, p3, p4) {
      const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, x3 = p3.x, y3 = p3.y, x4 = p4.x, y4 = p4.y;
      return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);
    },
    lli: function(v1, v2) {
      return utils.lli4(v1, v1.c, v2, v2.c);
    },
    makeline: function(p1, p2) {
      return new Bezier(
        p1.x,
        p1.y,
        (p1.x + p2.x) / 2,
        (p1.y + p2.y) / 2,
        p2.x,
        p2.y
      );
    },
    findbbox: function(sections) {
      let mx = nMax, my = nMax, MX = nMin, MY = nMin;
      sections.forEach(function(s) {
        const bbox = s.bbox();
        if (mx > bbox.x.min)
          mx = bbox.x.min;
        if (my > bbox.y.min)
          my = bbox.y.min;
        if (MX < bbox.x.max)
          MX = bbox.x.max;
        if (MY < bbox.y.max)
          MY = bbox.y.max;
      });
      return {
        x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },
        y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my }
      };
    },
    shapeintersections: function(s1, bbox1, s2, bbox2, curveIntersectionThreshold) {
      if (!utils.bboxoverlap(bbox1, bbox2))
        return [];
      const intersections = [];
      const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];
      const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];
      a1.forEach(function(l1) {
        if (l1.virtual)
          return;
        a2.forEach(function(l2) {
          if (l2.virtual)
            return;
          const iss = l1.intersects(l2, curveIntersectionThreshold);
          if (iss.length > 0) {
            iss.c1 = l1;
            iss.c2 = l2;
            iss.s1 = s1;
            iss.s2 = s2;
            intersections.push(iss);
          }
        });
      });
      return intersections;
    },
    makeshape: function(forward, back, curveIntersectionThreshold) {
      const bpl = back.points.length;
      const fpl = forward.points.length;
      const start2 = utils.makeline(back.points[bpl - 1], forward.points[0]);
      const end2 = utils.makeline(forward.points[fpl - 1], back.points[0]);
      const shape = {
        startcap: start2,
        forward,
        back,
        endcap: end2,
        bbox: utils.findbbox([start2, forward, back, end2])
      };
      shape.intersections = function(s2) {
        return utils.shapeintersections(
          shape,
          shape.bbox,
          s2,
          s2.bbox,
          curveIntersectionThreshold
        );
      };
      return shape;
    },
    getminmax: function(curve, d, list) {
      if (!list)
        return { min: 0, max: 0 };
      let min3 = nMax, max3 = nMin, t38, c;
      if (list.indexOf(0) === -1) {
        list = [0].concat(list);
      }
      if (list.indexOf(1) === -1) {
        list.push(1);
      }
      for (let i2 = 0, len = list.length; i2 < len; i2++) {
        t38 = list[i2];
        c = curve.get(t38);
        if (c[d] < min3) {
          min3 = c[d];
        }
        if (c[d] > max3) {
          max3 = c[d];
        }
      }
      return { min: min3, mid: (min3 + max3) / 2, max: max3, size: max3 - min3 };
    },
    align: function(points, line) {
      const tx = line.p1.x, ty = line.p1.y, a2 = -atan2(line.p2.y - ty, line.p2.x - tx), d = /* @__PURE__ */ __name(function(v) {
        return {
          x: (v.x - tx) * cos(a2) - (v.y - ty) * sin(a2),
          y: (v.x - tx) * sin(a2) + (v.y - ty) * cos(a2)
        };
      }, "d");
      return points.map(d);
    },
    roots: function(points, line) {
      line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
      const order2 = points.length - 1;
      const aligned = utils.align(points, line);
      const reduce = /* @__PURE__ */ __name(function(t38) {
        return 0 <= t38 && t38 <= 1;
      }, "reduce");
      if (order2 === 2) {
        const a3 = aligned[0].y, b3 = aligned[1].y, c2 = aligned[2].y, d2 = a3 - 2 * b3 + c2;
        if (d2 !== 0) {
          const m1 = -sqrt(b3 * b3 - a3 * c2), m2 = -a3 + b3, v12 = -(m1 + m2) / d2, v2 = -(-m1 + m2) / d2;
          return [v12, v2].filter(reduce);
        } else if (b3 !== c2 && d2 === 0) {
          return [(2 * b3 - c2) / (2 * b3 - 2 * c2)].filter(reduce);
        }
        return [];
      }
      const pa = aligned[0].y, pb = aligned[1].y, pc = aligned[2].y, pd = aligned[3].y;
      let d = -pa + 3 * pb - 3 * pc + pd, a2 = 3 * pa - 6 * pb + 3 * pc, b2 = -3 * pa + 3 * pb, c = pa;
      if (utils.approximately(d, 0)) {
        if (utils.approximately(a2, 0)) {
          if (utils.approximately(b2, 0)) {
            return [];
          }
          return [-c / b2].filter(reduce);
        }
        const q3 = sqrt(b2 * b2 - 4 * a2 * c), a22 = 2 * a2;
        return [(q3 - b2) / a22, (-b2 - q3) / a22].filter(reduce);
      }
      a2 /= d;
      b2 /= d;
      c /= d;
      const p = (3 * b2 - a2 * a2) / 3, p3 = p / 3, q = (2 * a2 * a2 * a2 - 9 * a2 * b2 + 27 * c) / 27, q2 = q / 2, discriminant = q2 * q2 + p3 * p3 * p3;
      let u1, v1, x1, x2, x3;
      if (discriminant < 0) {
        const mp3 = -p / 3, mp33 = mp3 * mp3 * mp3, r = sqrt(mp33), t38 = -q / (2 * r), cosphi = t38 < -1 ? -1 : t38 > 1 ? 1 : t38, phi = acos(cosphi), crtr = crt(r), t1 = 2 * crtr;
        x1 = t1 * cos(phi / 3) - a2 / 3;
        x2 = t1 * cos((phi + tau) / 3) - a2 / 3;
        x3 = t1 * cos((phi + 2 * tau) / 3) - a2 / 3;
        return [x1, x2, x3].filter(reduce);
      } else if (discriminant === 0) {
        u1 = q2 < 0 ? crt(-q2) : -crt(q2);
        x1 = 2 * u1 - a2 / 3;
        x2 = -u1 - a2 / 3;
        return [x1, x2].filter(reduce);
      } else {
        const sd = sqrt(discriminant);
        u1 = crt(-q2 + sd);
        v1 = crt(q2 + sd);
        return [u1 - v1 - a2 / 3].filter(reduce);
      }
    },
    droots: function(p) {
      if (p.length === 3) {
        const a2 = p[0], b2 = p[1], c = p[2], d = a2 - 2 * b2 + c;
        if (d !== 0) {
          const m1 = -sqrt(b2 * b2 - a2 * c), m2 = -a2 + b2, v1 = -(m1 + m2) / d, v2 = -(-m1 + m2) / d;
          return [v1, v2];
        } else if (b2 !== c && d === 0) {
          return [(2 * b2 - c) / (2 * (b2 - c))];
        }
        return [];
      }
      if (p.length === 2) {
        const a2 = p[0], b2 = p[1];
        if (a2 !== b2) {
          return [a2 / (a2 - b2)];
        }
        return [];
      }
      return [];
    },
    curvature: function(t38, d1, d2, _3d, kOnly) {
      let num, dnm, adk, dk, k = 0, r = 0;
      const d = utils.compute(t38, d1);
      const dd = utils.compute(t38, d2);
      const qdsum = d.x * d.x + d.y * d.y;
      if (_3d) {
        num = sqrt(
          pow(d.y * dd.z - dd.y * d.z, 2) + pow(d.z * dd.x - dd.z * d.x, 2) + pow(d.x * dd.y - dd.x * d.y, 2)
        );
        dnm = pow(qdsum + d.z * d.z, 3 / 2);
      } else {
        num = d.x * dd.y - d.y * dd.x;
        dnm = pow(qdsum, 3 / 2);
      }
      if (num === 0 || dnm === 0) {
        return { k: 0, r: 0 };
      }
      k = num / dnm;
      r = dnm / num;
      if (!kOnly) {
        const pk = utils.curvature(t38 - 1e-3, d1, d2, _3d, true).k;
        const nk = utils.curvature(t38 + 1e-3, d1, d2, _3d, true).k;
        dk = (nk - k + (k - pk)) / 2;
        adk = (abs(nk - k) + abs(k - pk)) / 2;
      }
      return { k, r, dk, adk };
    },
    inflections: function(points) {
      if (points.length < 4)
        return [];
      const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }), a2 = p[2].x * p[1].y, b2 = p[3].x * p[1].y, c = p[1].x * p[2].y, d = p[3].x * p[2].y, v1 = 18 * (-3 * a2 + 2 * b2 + 3 * c - d), v2 = 18 * (3 * a2 - b2 - 3 * c), v3 = 18 * (c - a2);
      if (utils.approximately(v1, 0)) {
        if (!utils.approximately(v2, 0)) {
          let t38 = -v3 / v2;
          if (0 <= t38 && t38 <= 1)
            return [t38];
        }
        return [];
      }
      const d2 = 2 * v1;
      if (utils.approximately(d2, 0))
        return [];
      const trm = v2 * v2 - 4 * v1 * v3;
      if (trm < 0)
        return [];
      const sq = Math.sqrt(trm);
      return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function(r) {
        return 0 <= r && r <= 1;
      });
    },
    bboxoverlap: function(b1, b2) {
      const dims = ["x", "y"], len = dims.length;
      for (let i2 = 0, dim, l, t38, d; i2 < len; i2++) {
        dim = dims[i2];
        l = b1[dim].mid;
        t38 = b2[dim].mid;
        d = (b1[dim].size + b2[dim].size) / 2;
        if (abs(l - t38) >= d)
          return false;
      }
      return true;
    },
    expandbox: function(bbox, _bbox) {
      if (_bbox.x.min < bbox.x.min) {
        bbox.x.min = _bbox.x.min;
      }
      if (_bbox.y.min < bbox.y.min) {
        bbox.y.min = _bbox.y.min;
      }
      if (_bbox.z && _bbox.z.min < bbox.z.min) {
        bbox.z.min = _bbox.z.min;
      }
      if (_bbox.x.max > bbox.x.max) {
        bbox.x.max = _bbox.x.max;
      }
      if (_bbox.y.max > bbox.y.max) {
        bbox.y.max = _bbox.y.max;
      }
      if (_bbox.z && _bbox.z.max > bbox.z.max) {
        bbox.z.max = _bbox.z.max;
      }
      bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;
      bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;
      if (bbox.z) {
        bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;
      }
      bbox.x.size = bbox.x.max - bbox.x.min;
      bbox.y.size = bbox.y.max - bbox.y.min;
      if (bbox.z) {
        bbox.z.size = bbox.z.max - bbox.z.min;
      }
    },
    pairiteration: function(c1, c2, curveIntersectionThreshold) {
      const c1b = c1.bbox(), c2b = c2.bbox(), r = 1e5, threshold = curveIntersectionThreshold || 0.5;
      if (c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold) {
        return [
          (r * (c1._t1 + c1._t2) / 2 | 0) / r + "/" + (r * (c2._t1 + c2._t2) / 2 | 0) / r
        ];
      }
      let cc1 = c1.split(0.5), cc2 = c2.split(0.5), pairs = [
        { left: cc1.left, right: cc2.left },
        { left: cc1.left, right: cc2.right },
        { left: cc1.right, right: cc2.right },
        { left: cc1.right, right: cc2.left }
      ];
      pairs = pairs.filter(function(pair) {
        return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());
      });
      let results = [];
      if (pairs.length === 0)
        return results;
      pairs.forEach(function(pair) {
        results = results.concat(
          utils.pairiteration(pair.left, pair.right, threshold)
        );
      });
      results = results.filter(function(v, i2) {
        return results.indexOf(v) === i2;
      });
      return results;
    },
    getccenter: function(p1, p2, p3) {
      const dx1 = p2.x - p1.x, dy1 = p2.y - p1.y, dx2 = p3.x - p2.x, dy2 = p3.y - p2.y, dx1p = dx1 * cos(quart) - dy1 * sin(quart), dy1p = dx1 * sin(quart) + dy1 * cos(quart), dx2p = dx2 * cos(quart) - dy2 * sin(quart), dy2p = dx2 * sin(quart) + dy2 * cos(quart), mx1 = (p1.x + p2.x) / 2, my1 = (p1.y + p2.y) / 2, mx2 = (p2.x + p3.x) / 2, my2 = (p2.y + p3.y) / 2, mx1n = mx1 + dx1p, my1n = my1 + dy1p, mx2n = mx2 + dx2p, my2n = my2 + dy2p, arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n), r = utils.dist(arc, p1);
      let s = atan2(p1.y - arc.y, p1.x - arc.x), m = atan2(p2.y - arc.y, p2.x - arc.x), e = atan2(p3.y - arc.y, p3.x - arc.x), _;
      if (s < e) {
        if (s > m || m > e) {
          s += tau;
        }
        if (s > e) {
          _ = e;
          e = s;
          s = _;
        }
      } else {
        if (e < m && m < s) {
          _ = e;
          e = s;
          s = _;
        } else {
          e += tau;
        }
      }
      arc.s = s;
      arc.e = e;
      arc.r = r;
      return arc;
    },
    numberSort: function(a2, b2) {
      return a2 - b2;
    }
  };

  // node_modules/bezier-js/src/poly-bezier.js
  var PolyBezier = class {
    constructor(curves) {
      this.curves = [];
      this._3d = false;
      if (!!curves) {
        this.curves = curves;
        this._3d = this.curves[0]._3d;
      }
    }
    valueOf() {
      return this.toString();
    }
    toString() {
      return "[" + this.curves.map(function(curve) {
        return utils.pointsToString(curve.points);
      }).join(", ") + "]";
    }
    addCurve(curve) {
      this.curves.push(curve);
      this._3d = this._3d || curve._3d;
    }
    length() {
      return this.curves.map(function(v) {
        return v.length();
      }).reduce(function(a2, b2) {
        return a2 + b2;
      });
    }
    curve(idx) {
      return this.curves[idx];
    }
    bbox() {
      const c = this.curves;
      var bbox = c[0].bbox();
      for (var i2 = 1; i2 < c.length; i2++) {
        utils.expandbox(bbox, c[i2].bbox());
      }
      return bbox;
    }
    offset(d) {
      const offset2 = [];
      this.curves.forEach(function(v) {
        offset2.push(...v.offset(d));
      });
      return new PolyBezier(offset2);
    }
  };
  __name(PolyBezier, "PolyBezier");

  // node_modules/bezier-js/src/bezier.js
  var { abs: abs2, min, max, cos: cos2, sin: sin2, acos: acos2, sqrt: sqrt2 } = Math;
  var pi2 = Math.PI;
  var Bezier = class {
    constructor(coords) {
      let args = coords && coords.forEach ? coords : Array.from(arguments).slice();
      let coordlen = false;
      if (typeof args[0] === "object") {
        coordlen = args.length;
        const newargs = [];
        args.forEach(function(point2) {
          ["x", "y", "z"].forEach(function(d) {
            if (typeof point2[d] !== "undefined") {
              newargs.push(point2[d]);
            }
          });
        });
        args = newargs;
      }
      let higher = false;
      const len = args.length;
      if (coordlen) {
        if (coordlen > 4) {
          if (arguments.length !== 1) {
            throw new Error(
              "Only new Bezier(point[]) is accepted for 4th and higher order curves"
            );
          }
          higher = true;
        }
      } else {
        if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {
          if (arguments.length !== 1) {
            throw new Error(
              "Only new Bezier(point[]) is accepted for 4th and higher order curves"
            );
          }
        }
      }
      const _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z !== "undefined";
      const points = this.points = [];
      for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {
        var point = {
          x: args[idx],
          y: args[idx + 1]
        };
        if (_3d) {
          point.z = args[idx + 2];
        }
        points.push(point);
      }
      const order2 = this.order = points.length - 1;
      const dims = this.dims = ["x", "y"];
      if (_3d)
        dims.push("z");
      this.dimlen = dims.length;
      const aligned = utils.align(points, { p1: points[0], p2: points[order2] });
      const baselength = utils.dist(points[0], points[order2]);
      this._linear = aligned.reduce((t38, p) => t38 + abs2(p.y), 0) < baselength / 50;
      this._lut = [];
      this._t1 = 0;
      this._t2 = 1;
      this.update();
    }
    static quadraticFromPoints(p1, p2, p3, t38) {
      if (typeof t38 === "undefined") {
        t38 = 0.5;
      }
      if (t38 === 0) {
        return new Bezier(p2, p2, p3);
      }
      if (t38 === 1) {
        return new Bezier(p1, p2, p2);
      }
      const abc = Bezier.getABC(2, p1, p2, p3, t38);
      return new Bezier(p1, abc.A, p3);
    }
    static cubicFromPoints(S2, B, E, t38, d1) {
      if (typeof t38 === "undefined") {
        t38 = 0.5;
      }
      const abc = Bezier.getABC(3, S2, B, E, t38);
      if (typeof d1 === "undefined") {
        d1 = utils.dist(B, abc.C);
      }
      const d2 = d1 * (1 - t38) / t38;
      const selen = utils.dist(S2, E), lx = (E.x - S2.x) / selen, ly = (E.y - S2.y) / selen, bx1 = d1 * lx, by1 = d1 * ly, bx2 = d2 * lx, by2 = d2 * ly;
      const e1 = { x: B.x - bx1, y: B.y - by1 }, e2 = { x: B.x + bx2, y: B.y + by2 }, A = abc.A, v1 = { x: A.x + (e1.x - A.x) / (1 - t38), y: A.y + (e1.y - A.y) / (1 - t38) }, v2 = { x: A.x + (e2.x - A.x) / t38, y: A.y + (e2.y - A.y) / t38 }, nc1 = { x: S2.x + (v1.x - S2.x) / t38, y: S2.y + (v1.y - S2.y) / t38 }, nc2 = {
        x: E.x + (v2.x - E.x) / (1 - t38),
        y: E.y + (v2.y - E.y) / (1 - t38)
      };
      return new Bezier(S2, nc1, nc2, E);
    }
    static getUtils() {
      return utils;
    }
    getUtils() {
      return Bezier.getUtils();
    }
    static get PolyBezier() {
      return PolyBezier;
    }
    valueOf() {
      return this.toString();
    }
    toString() {
      return utils.pointsToString(this.points);
    }
    toSVG() {
      if (this._3d)
        return false;
      const p = this.points, x = p[0].x, y = p[0].y, s = ["M", x, y, this.order === 2 ? "Q" : "C"];
      for (let i2 = 1, last = p.length; i2 < last; i2++) {
        s.push(p[i2].x);
        s.push(p[i2].y);
      }
      return s.join(" ");
    }
    setRatios(ratios) {
      if (ratios.length !== this.points.length) {
        throw new Error("incorrect number of ratio values");
      }
      this.ratios = ratios;
      this._lut = [];
    }
    verify() {
      const print = this.coordDigest();
      if (print !== this._print) {
        this._print = print;
        this.update();
      }
    }
    coordDigest() {
      return this.points.map(function(c, pos) {
        return "" + pos + c.x + c.y + (c.z ? c.z : 0);
      }).join("");
    }
    update() {
      this._lut = [];
      this.dpoints = utils.derive(this.points, this._3d);
      this.computedirection();
    }
    computedirection() {
      const points = this.points;
      const angle = utils.angle(points[0], points[this.order], points[1]);
      this.clockwise = angle > 0;
    }
    length() {
      return utils.length(this.derivative.bind(this));
    }
    static getABC(order2 = 2, S2, B, E, t38 = 0.5) {
      const u = utils.projectionratio(t38, order2), um = 1 - u, C = {
        x: u * S2.x + um * E.x,
        y: u * S2.y + um * E.y
      }, s = utils.abcratio(t38, order2), A = {
        x: B.x + (B.x - C.x) / s,
        y: B.y + (B.y - C.y) / s
      };
      return { A, B, C, S: S2, E };
    }
    getABC(t38, B) {
      B = B || this.get(t38);
      let S2 = this.points[0];
      let E = this.points[this.order];
      return Bezier.getABC(this.order, S2, B, E, t38);
    }
    getLUT(steps) {
      this.verify();
      steps = steps || 100;
      if (this._lut.length === steps + 1) {
        return this._lut;
      }
      this._lut = [];
      steps++;
      this._lut = [];
      for (let i2 = 0, p, t38; i2 < steps; i2++) {
        t38 = i2 / (steps - 1);
        p = this.compute(t38);
        p.t = t38;
        this._lut.push(p);
      }
      return this._lut;
    }
    on(point, error) {
      error = error || 5;
      const lut = this.getLUT(), hits = [];
      for (let i2 = 0, c, t38 = 0; i2 < lut.length; i2++) {
        c = lut[i2];
        if (utils.dist(c, point) < error) {
          hits.push(c);
          t38 += i2 / lut.length;
        }
      }
      if (!hits.length)
        return false;
      return t /= hits.length;
    }
    project(point) {
      const LUT = this.getLUT(), l = LUT.length - 1, closest = utils.closest(LUT, point), mpos = closest.mpos, t1 = (mpos - 1) / l, t210 = (mpos + 1) / l, step = 0.1 / l;
      let mdist = closest.mdist, t38 = t1, ft = t38, p;
      mdist += 1;
      for (let d; t38 < t210 + step; t38 += step) {
        p = this.compute(t38);
        d = utils.dist(point, p);
        if (d < mdist) {
          mdist = d;
          ft = t38;
        }
      }
      ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;
      p = this.compute(ft);
      p.t = ft;
      p.d = mdist;
      return p;
    }
    get(t38) {
      return this.compute(t38);
    }
    point(idx) {
      return this.points[idx];
    }
    compute(t38) {
      if (this.ratios) {
        return utils.computeWithRatios(t38, this.points, this.ratios, this._3d);
      }
      return utils.compute(t38, this.points, this._3d, this.ratios);
    }
    raise() {
      const p = this.points, np = [p[0]], k = p.length;
      for (let i2 = 1, pi3, pim; i2 < k; i2++) {
        pi3 = p[i2];
        pim = p[i2 - 1];
        np[i2] = {
          x: (k - i2) / k * pi3.x + i2 / k * pim.x,
          y: (k - i2) / k * pi3.y + i2 / k * pim.y
        };
      }
      np[k] = p[k - 1];
      return new Bezier(np);
    }
    derivative(t38) {
      return utils.compute(t38, this.dpoints[0], this._3d);
    }
    dderivative(t38) {
      return utils.compute(t38, this.dpoints[1], this._3d);
    }
    align() {
      let p = this.points;
      return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));
    }
    curvature(t38) {
      return utils.curvature(t38, this.dpoints[0], this.dpoints[1], this._3d);
    }
    inflections() {
      return utils.inflections(this.points);
    }
    normal(t38) {
      return this._3d ? this.__normal3(t38) : this.__normal2(t38);
    }
    __normal2(t38) {
      const d = this.derivative(t38);
      const q = sqrt2(d.x * d.x + d.y * d.y);
      return { t: t38, x: -d.y / q, y: d.x / q };
    }
    __normal3(t38) {
      const r1 = this.derivative(t38), r2 = this.derivative(t38 + 0.01), q1 = sqrt2(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z), q2 = sqrt2(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);
      r1.x /= q1;
      r1.y /= q1;
      r1.z /= q1;
      r2.x /= q2;
      r2.y /= q2;
      r2.z /= q2;
      const c = {
        x: r2.y * r1.z - r2.z * r1.y,
        y: r2.z * r1.x - r2.x * r1.z,
        z: r2.x * r1.y - r2.y * r1.x
      };
      const m = sqrt2(c.x * c.x + c.y * c.y + c.z * c.z);
      c.x /= m;
      c.y /= m;
      c.z /= m;
      const R = [
        c.x * c.x,
        c.x * c.y - c.z,
        c.x * c.z + c.y,
        c.x * c.y + c.z,
        c.y * c.y,
        c.y * c.z - c.x,
        c.x * c.z - c.y,
        c.y * c.z + c.x,
        c.z * c.z
      ];
      const n = {
        t: t38,
        x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,
        y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,
        z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z
      };
      return n;
    }
    hull(t38) {
      let p = this.points, _p = [], q = [], idx = 0;
      q[idx++] = p[0];
      q[idx++] = p[1];
      q[idx++] = p[2];
      if (this.order === 3) {
        q[idx++] = p[3];
      }
      while (p.length > 1) {
        _p = [];
        for (let i2 = 0, pt, l = p.length - 1; i2 < l; i2++) {
          pt = utils.lerp(t38, p[i2], p[i2 + 1]);
          q[idx++] = pt;
          _p.push(pt);
        }
        p = _p;
      }
      return q;
    }
    split(t1, t210) {
      if (t1 === 0 && !!t210) {
        return this.split(t210).left;
      }
      if (t210 === 1) {
        return this.split(t1).right;
      }
      const q = this.hull(t1);
      const result = {
        left: this.order === 2 ? new Bezier([q[0], q[3], q[5]]) : new Bezier([q[0], q[4], q[7], q[9]]),
        right: this.order === 2 ? new Bezier([q[5], q[4], q[2]]) : new Bezier([q[9], q[8], q[6], q[3]]),
        span: q
      };
      result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);
      result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);
      result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);
      result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);
      if (!t210) {
        return result;
      }
      t210 = utils.map(t210, t1, 1, 0, 1);
      return result.right.split(t210).left;
    }
    extrema() {
      const result = {};
      let roots = [];
      this.dims.forEach(
        function(dim) {
          let mfn = /* @__PURE__ */ __name(function(v) {
            return v[dim];
          }, "mfn");
          let p = this.dpoints[0].map(mfn);
          result[dim] = utils.droots(p);
          if (this.order === 3) {
            p = this.dpoints[1].map(mfn);
            result[dim] = result[dim].concat(utils.droots(p));
          }
          result[dim] = result[dim].filter(function(t38) {
            return t38 >= 0 && t38 <= 1;
          });
          roots = roots.concat(result[dim].sort(utils.numberSort));
        }.bind(this)
      );
      result.values = roots.sort(utils.numberSort).filter(function(v, idx) {
        return roots.indexOf(v) === idx;
      });
      return result;
    }
    bbox() {
      const extrema = this.extrema(), result = {};
      this.dims.forEach(
        function(d) {
          result[d] = utils.getminmax(this, d, extrema[d]);
        }.bind(this)
      );
      return result;
    }
    overlaps(curve) {
      const lbbox = this.bbox(), tbbox = curve.bbox();
      return utils.bboxoverlap(lbbox, tbbox);
    }
    offset(t38, d) {
      if (typeof d !== "undefined") {
        const c = this.get(t38), n = this.normal(t38);
        const ret = {
          c,
          n,
          x: c.x + n.x * d,
          y: c.y + n.y * d
        };
        if (this._3d) {
          ret.z = c.z + n.z * d;
        }
        return ret;
      }
      if (this._linear) {
        const nv = this.normal(0), coords = this.points.map(function(p) {
          const ret = {
            x: p.x + t38 * nv.x,
            y: p.y + t38 * nv.y
          };
          if (p.z && nv.z) {
            ret.z = p.z + t38 * nv.z;
          }
          return ret;
        });
        return [new Bezier(coords)];
      }
      return this.reduce().map(function(s) {
        if (s._linear) {
          return s.offset(t38)[0];
        }
        return s.scale(t38);
      });
    }
    simple() {
      if (this.order === 3) {
        const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);
        const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);
        if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0)
          return false;
      }
      const n1 = this.normal(0);
      const n2 = this.normal(1);
      let s = n1.x * n2.x + n1.y * n2.y;
      if (this._3d) {
        s += n1.z * n2.z;
      }
      return abs2(acos2(s)) < pi2 / 3;
    }
    reduce() {
      let i2, t1 = 0, t210 = 0, step = 0.01, segment, pass1 = [], pass2 = [];
      let extrema = this.extrema().values;
      if (extrema.indexOf(0) === -1) {
        extrema = [0].concat(extrema);
      }
      if (extrema.indexOf(1) === -1) {
        extrema.push(1);
      }
      for (t1 = extrema[0], i2 = 1; i2 < extrema.length; i2++) {
        t210 = extrema[i2];
        segment = this.split(t1, t210);
        segment._t1 = t1;
        segment._t2 = t210;
        pass1.push(segment);
        t1 = t210;
      }
      pass1.forEach(function(p1) {
        t1 = 0;
        t210 = 0;
        while (t210 <= 1) {
          for (t210 = t1 + step; t210 <= 1 + step; t210 += step) {
            segment = p1.split(t1, t210);
            if (!segment.simple()) {
              t210 -= step;
              if (abs2(t1 - t210) < step) {
                return [];
              }
              segment = p1.split(t1, t210);
              segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);
              segment._t2 = utils.map(t210, 0, 1, p1._t1, p1._t2);
              pass2.push(segment);
              t1 = t210;
              break;
            }
          }
        }
        if (t1 < 1) {
          segment = p1.split(t1, 1);
          segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);
          segment._t2 = p1._t2;
          pass2.push(segment);
        }
      });
      return pass2;
    }
    translate(v, d1, d2) {
      d2 = typeof d2 === "number" ? d2 : d1;
      const o = this.order;
      let d = this.points.map((_, i2) => (1 - i2 / o) * d1 + i2 / o * d2);
      return new Bezier(
        this.points.map((p, i2) => ({
          x: p.x + v.x * d[i2],
          y: p.y + v.y * d[i2]
        }))
      );
    }
    scale(d) {
      const order2 = this.order;
      let distanceFn = false;
      if (typeof d === "function") {
        distanceFn = d;
      }
      if (distanceFn && order2 === 2) {
        return this.raise().scale(distanceFn);
      }
      const clockwise = this.clockwise;
      const points = this.points;
      if (this._linear) {
        return this.translate(
          this.normal(0),
          distanceFn ? distanceFn(0) : d,
          distanceFn ? distanceFn(1) : d
        );
      }
      const r1 = distanceFn ? distanceFn(0) : d;
      const r2 = distanceFn ? distanceFn(1) : d;
      const v = [this.offset(0, 10), this.offset(1, 10)];
      const np = [];
      const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);
      if (!o) {
        throw new Error("cannot scale this curve. Try reducing it first.");
      }
      [0, 1].forEach(function(t38) {
        const p = np[t38 * order2] = utils.copy(points[t38 * order2]);
        p.x += (t38 ? r2 : r1) * v[t38].n.x;
        p.y += (t38 ? r2 : r1) * v[t38].n.y;
      });
      if (!distanceFn) {
        [0, 1].forEach((t38) => {
          if (order2 === 2 && !!t38)
            return;
          const p = np[t38 * order2];
          const d2 = this.derivative(t38);
          const p2 = { x: p.x + d2.x, y: p.y + d2.y };
          np[t38 + 1] = utils.lli4(p, p2, o, points[t38 + 1]);
        });
        return new Bezier(np);
      }
      [0, 1].forEach(function(t38) {
        if (order2 === 2 && !!t38)
          return;
        var p = points[t38 + 1];
        var ov = {
          x: p.x - o.x,
          y: p.y - o.y
        };
        var rc = distanceFn ? distanceFn((t38 + 1) / order2) : d;
        if (distanceFn && !clockwise)
          rc = -rc;
        var m = sqrt2(ov.x * ov.x + ov.y * ov.y);
        ov.x /= m;
        ov.y /= m;
        np[t38 + 1] = {
          x: p.x + rc * ov.x,
          y: p.y + rc * ov.y
        };
      });
      return new Bezier(np);
    }
    outline(d1, d2, d3, d4) {
      d2 = d2 === void 0 ? d1 : d2;
      if (this._linear) {
        const n = this.normal(0);
        const start2 = this.points[0];
        const end2 = this.points[this.points.length - 1];
        let s, mid, e;
        if (d3 === void 0) {
          d3 = d1;
          d4 = d2;
        }
        s = { x: start2.x + n.x * d1, y: start2.y + n.y * d1 };
        e = { x: end2.x + n.x * d3, y: end2.y + n.y * d3 };
        mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };
        const fline = [s, mid, e];
        s = { x: start2.x - n.x * d2, y: start2.y - n.y * d2 };
        e = { x: end2.x - n.x * d4, y: end2.y - n.y * d4 };
        mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };
        const bline = [e, mid, s];
        const ls2 = utils.makeline(bline[2], fline[0]);
        const le2 = utils.makeline(fline[2], bline[0]);
        const segments2 = [ls2, new Bezier(fline), le2, new Bezier(bline)];
        return new PolyBezier(segments2);
      }
      const reduced = this.reduce(), len = reduced.length, fcurves = [];
      let bcurves = [], p, alen = 0, tlen = this.length();
      const graduated = typeof d3 !== "undefined" && typeof d4 !== "undefined";
      function linearDistanceFunction(s, e, tlen2, alen2, slen) {
        return function(v) {
          const f1 = alen2 / tlen2, f2 = (alen2 + slen) / tlen2, d = e - s;
          return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);
        };
      }
      __name(linearDistanceFunction, "linearDistanceFunction");
      reduced.forEach(function(segment) {
        const slen = segment.length();
        if (graduated) {
          fcurves.push(
            segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))
          );
          bcurves.push(
            segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))
          );
        } else {
          fcurves.push(segment.scale(d1));
          bcurves.push(segment.scale(-d2));
        }
        alen += slen;
      });
      bcurves = bcurves.map(function(s) {
        p = s.points;
        if (p[3]) {
          s.points = [p[3], p[2], p[1], p[0]];
        } else {
          s.points = [p[2], p[1], p[0]];
        }
        return s;
      }).reverse();
      const fs = fcurves[0].points[0], fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1], bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1], be = bcurves[0].points[0], ls = utils.makeline(bs, fs), le = utils.makeline(fe, be), segments = [ls].concat(fcurves).concat([le]).concat(bcurves);
      return new PolyBezier(segments);
    }
    outlineshapes(d1, d2, curveIntersectionThreshold) {
      d2 = d2 || d1;
      const outline = this.outline(d1, d2).curves;
      const shapes = [];
      for (let i2 = 1, len = outline.length; i2 < len / 2; i2++) {
        const shape = utils.makeshape(
          outline[i2],
          outline[len - i2],
          curveIntersectionThreshold
        );
        shape.startcap.virtual = i2 > 1;
        shape.endcap.virtual = i2 < len / 2 - 1;
        shapes.push(shape);
      }
      return shapes;
    }
    intersects(curve, curveIntersectionThreshold) {
      if (!curve)
        return this.selfintersects(curveIntersectionThreshold);
      if (curve.p1 && curve.p2) {
        return this.lineIntersects(curve);
      }
      if (curve instanceof Bezier) {
        curve = curve.reduce();
      }
      return this.curveintersects(
        this.reduce(),
        curve,
        curveIntersectionThreshold
      );
    }
    lineIntersects(line) {
      const mx = min(line.p1.x, line.p2.x), my = min(line.p1.y, line.p2.y), MX = max(line.p1.x, line.p2.x), MY = max(line.p1.y, line.p2.y);
      return utils.roots(this.points, line).filter((t38) => {
        var p = this.get(t38);
        return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);
      });
    }
    selfintersects(curveIntersectionThreshold) {
      const reduced = this.reduce(), len = reduced.length - 2, results = [];
      for (let i2 = 0, result, left2, right2; i2 < len; i2++) {
        left2 = reduced.slice(i2, i2 + 1);
        right2 = reduced.slice(i2 + 2);
        result = this.curveintersects(left2, right2, curveIntersectionThreshold);
        results.push(...result);
      }
      return results;
    }
    curveintersects(c1, c2, curveIntersectionThreshold) {
      const pairs = [];
      c1.forEach(function(l) {
        c2.forEach(function(r) {
          if (l.overlaps(r)) {
            pairs.push({ left: l, right: r });
          }
        });
      });
      let intersections = [];
      pairs.forEach(function(pair) {
        const result = utils.pairiteration(
          pair.left,
          pair.right,
          curveIntersectionThreshold
        );
        if (result.length > 0) {
          intersections = intersections.concat(result);
        }
      });
      return intersections;
    }
    arcs(errorThreshold) {
      errorThreshold = errorThreshold || 0.5;
      return this._iterate(errorThreshold, []);
    }
    _error(pc, np1, s, e) {
      const q = (e - s) / 4, c1 = this.get(s + q), c2 = this.get(e - q), ref = utils.dist(pc, np1), d1 = utils.dist(pc, c1), d2 = utils.dist(pc, c2);
      return abs2(d1 - ref) + abs2(d2 - ref);
    }
    _iterate(errorThreshold, circles) {
      let t_s = 0, t_e = 1, safety;
      do {
        safety = 0;
        t_e = 1;
        let np1 = this.get(t_s), np2, np3, arc, prev_arc;
        let curr_good = false, prev_good = false, done;
        let t_m = t_e, prev_e = 1, step = 0;
        do {
          prev_good = curr_good;
          prev_arc = arc;
          t_m = (t_s + t_e) / 2;
          step++;
          np2 = this.get(t_m);
          np3 = this.get(t_e);
          arc = utils.getccenter(np1, np2, np3);
          arc.interval = {
            start: t_s,
            end: t_e
          };
          let error = this._error(arc, np1, t_s, t_e);
          curr_good = error <= errorThreshold;
          done = prev_good && !curr_good;
          if (!done)
            prev_e = t_e;
          if (curr_good) {
            if (t_e >= 1) {
              arc.interval.end = prev_e = 1;
              prev_arc = arc;
              if (t_e > 1) {
                let d = {
                  x: arc.x + arc.r * cos2(arc.e),
                  y: arc.y + arc.r * sin2(arc.e)
                };
                arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));
              }
              break;
            }
            t_e = t_e + (t_e - t_s) / 2;
          } else {
            t_e = t_m;
          }
        } while (!done && safety++ < 100);
        if (safety >= 100) {
          break;
        }
        prev_arc = prev_arc ? prev_arc : arc;
        circles.push(prev_arc);
        t_s = prev_e;
      } while (t_e < 1);
      return circles;
    }
  };
  __name(Bezier, "Bezier");

  // simulator/src/components/Wire.ts
  var t7 = __toESM(require_lib());

  // simulator/src/components/Component.ts
  var t5 = __toESM(require_lib());
  var import_json52 = __toESM(require_dist());

  // simulator/src/UIPermissions.ts
  function perm(mode) {
    return (parent) => parent.editor.mode >= mode;
  }
  __name(perm, "perm");
  var UIPermissions = {
    canModifyTestCases: perm(4 /* FULL */),
    canModifyCustomComponents: perm(3 /* DESIGN */)
  };

  // simulator/src/components/Drawable.ts
  var t4 = __toESM(require_lib());
  var MenuData = {
    sep() {
      return { _tag: "sep" };
    },
    text(caption) {
      return { _tag: "text", caption };
    },
    item(icon, caption, action, shortcut, danger) {
      return { _tag: "item", icon, caption, action, shortcut, danger };
    },
    submenu(icon, caption, items) {
      return { _tag: "submenu", icon, caption, items };
    }
  };
  var _DrawContextImpl = class {
    constructor(comp, g, drawParams, isMouseOver, borderColor) {
      this.g = g;
      this.drawParams = drawParams;
      this.isMouseOver = isMouseOver;
      this.borderColor = borderColor;
      this.entranceTransform = g.getTransform();
      this.entranceTransformInv = this.entranceTransform.inverse();
      comp.applyDrawTransform(g);
      this.componentTransform = g.getTransform();
    }
    exit() {
      this.g.setTransform(this.entranceTransform);
    }
    inNonTransformedFrame(f) {
      this.g.setTransform(this.entranceTransform);
      f(this);
      this.g.setTransform(this.componentTransform);
    }
    rotatePoint(x, y) {
      return mult(this.entranceTransformInv, ...mult(this.componentTransform, x, y));
    }
  };
  __name(_DrawContextImpl, "_DrawContextImpl");
  function mult(m, x, y) {
    return [
      m.a * x + m.c * y + m.e,
      m.b * x + m.d * y + m.f
    ];
  }
  __name(mult, "mult");
  var Drawable = class {
    constructor(parent) {
      this._ref = void 0;
      this.parent = parent;
    }
    get ref() {
      return this._ref;
    }
    doSetValidatedId(id) {
      this._ref = id;
    }
    requestRedraw(req) {
      var _a;
      const fullReq = req;
      fullReq.component = this;
      (_a = this.parent.ifEditing) == null ? void 0 : _a.redrawMgr.requestRedraw(req);
    }
    get drawZIndex() {
      return DrawZIndex.Normal;
    }
    draw(g, drawParams) {
      var _a, _b;
      const inSelectionRect = (_b = (_a = drawParams.currentSelection) == null ? void 0 : _a.isSelected(this)) != null ? _b : false;
      const isMouseOver = this === drawParams.currentMouseOverComp || inSelectionRect;
      const borderColor = !isMouseOver ? COLOR_COMPONENT_BORDER : drawParams.anythingMoving && this.lockPos ? COLOR_MOUSE_OVER_DANGER : COLOR_MOUSE_OVER;
      const ctx = new _DrawContextImpl(this, g, drawParams, isMouseOver, borderColor);
      try {
        this.doDraw(g, ctx);
      } finally {
        ctx.exit();
      }
    }
    applyDrawTransform(__g2) {
    }
    get lockPos() {
      return false;
    }
    cursorWhenMouseover(__e2) {
      return void 0;
    }
    toString() {
      return `${this.constructor.name}(${this.toStringDetails()})`;
    }
    toStringDetails() {
      return "";
    }
    makeTooltip() {
      return void 0;
    }
    makeContextMenu() {
      return void 0;
    }
    makeSetIdContextMenuItem() {
      const currentId = this._ref;
      const s = S.Components.Generic.contextMenu;
      const caption = currentId === void 0 ? s.SetIdentifier : span(s.ChangeIdentifier[0], span(fixedWidthInContextMenu, currentId), s.ChangeIdentifier[1]);
      return MenuData.item("ref", caption, () => {
        this.runSetIdDialog();
      }, "\u2325\u21A9\uFE0E");
    }
    runSetIdDialog() {
      const s = S.Components.Generic.contextMenu;
      while (true) {
        const currentId = this._ref;
        const newId = window.prompt(s.SetIdentifierPrompt, currentId);
        if (newId === null) {
          break;
        }
        if (newId === currentId) {
          break;
        }
        if (!(this instanceof ComponentBase)) {
          this.doSetValidatedId(newId.length === 0 ? void 0 : newId);
        } else {
          if (newId.length === 0) {
            window.alert(s.IdentifierCannotBeEmpty);
            continue;
          }
          const componentList = this.parent.components;
          const otherComp = componentList.get(newId);
          if (otherComp === void 0) {
            componentList.changeIdOf(this, newId);
          } else {
            if (window.confirm(s.IdentifierAlreadyInUseShouldSwap)) {
              componentList.swapIdsOf(otherComp, this);
            } else {
              continue;
            }
          }
        }
        this.requestRedraw({ why: "ref changed" });
        break;
      }
    }
    // Return { wantsDragEvents: true } (default) to signal the component
    // wants to get all mouseDragged and the final mouseUp event. Useful to
    // return false to allow drag destinations to get a mouseUp
    mouseDown(__) {
      return { wantsDragEvents: true };
    }
    mouseDragged(__) {
    }
    mouseUp(__) {
      return InteractionResult.NoChange;
    }
    // Return true to indicate it was handled and had an effect
    // (and presumably doesn't need to be handled any more)
    mouseClicked(__) {
      return InteractionResult.NoChange;
    }
    // Return true to indicate it was handled and had an effect
    // (and presumably doesn't need to be handled any more)
    mouseDoubleClicked(__) {
      return InteractionResult.NoChange;
    }
    keyDown(e) {
      if (e.key === "Enter" && e.altKey) {
        this.runSetIdDialog();
      }
    }
  };
  __name(Drawable, "Drawable");
  var Orientations_ = {
    "e": {},
    "s": {},
    "w": {},
    "n": {}
  };
  var Orientations = RichStringEnum.withProps()(Orientations_);
  var Orientation = {
    default: "e",
    invert(o) {
      switch (o) {
        case "e":
          return "w";
        case "w":
          return "e";
        case "n":
          return "s";
        case "s":
          return "n";
      }
    },
    nextClockwise(o) {
      switch (o) {
        case "e":
          return "s";
        case "s":
          return "w";
        case "w":
          return "n";
        case "n":
          return "e";
      }
    },
    nextCounterClockwise(o) {
      switch (o) {
        case "e":
          return "n";
        case "n":
          return "w";
        case "w":
          return "s";
        case "s":
          return "e";
      }
    },
    isVertical(o) {
      return o === "s" || o === "n";
    },
    add(compOrient, nodeOrient) {
      switch (compOrient) {
        case "e":
          return nodeOrient;
        case "w":
          return Orientation.invert(nodeOrient);
        case "s":
          return Orientation.nextClockwise(nodeOrient);
        case "n":
          return Orientation.nextCounterClockwise(nodeOrient);
      }
    }
  };
  var PositionSupportRepr = t4.type({
    pos: t4.readonly(t4.tuple([t4.number, t4.number])),
    anchor: typeOrUndefined(t4.string),
    lockPos: typeOrUndefined(t4.boolean),
    orient: typeOrUndefined(t4.keyof(Orientations_)),
    ref: typeOrUndefined(t4.string)
  });
  var DrawableWithPosition = class extends Drawable {
    // not set in ctor, always begins as undefined
    constructor(parent, saved) {
      var _a, _b;
      super(parent);
      this._anchor = void 0;
      if (saved !== void 0) {
        this.doSetValidatedId(saved.ref);
        this._posX = saved.pos[0];
        this._posY = saved.pos[1];
        this._lockPos = (_a = saved.lockPos) != null ? _a : false;
        this._orient = (_b = saved.orient) != null ? _b : Orientation.default;
      } else {
        const editor = this.parent.editor;
        this._posX = Math.max(0, editor.mouseX);
        this._posY = editor.mouseY;
        this._lockPos = false;
        this._orient = Orientation.default;
      }
    }
    toJSONBase() {
      var _a;
      return {
        pos: [this.posX, this.posY],
        lockPos: !this._lockPos ? void 0 : true,
        orient: this.orient === Orientation.default ? void 0 : this.orient,
        anchor: (_a = this._anchor) == null ? void 0 : _a.ref,
        ref: this.ref
        // last because usually stripped by serialization
      };
    }
    get posX() {
      return this._posX;
    }
    get posY() {
      return this._posY;
    }
    get lockPos() {
      return this._lockPos;
    }
    isInRect(rect) {
      return this._posX >= rect.left && this._posX <= rect.right && this._posY >= rect.top && this._posY <= rect.bottom;
    }
    get orient() {
      return this._orient;
    }
    canRotate() {
      return true;
    }
    canLockPos() {
      return true;
    }
    doSetLockPos(lockPos) {
      this._lockPos = lockPos;
    }
    doSetOrient(newOrient) {
      this._orient = newOrient;
      this.requestRedraw({ why: "orientation changed", invalidateMask: true });
    }
    get width() {
      return Orientation.isVertical(this._orient) ? this.unrotatedHeight : this.unrotatedWidth;
    }
    get height() {
      return Orientation.isVertical(this._orient) ? this.unrotatedWidth : this.unrotatedHeight;
    }
    applyDrawTransform(g) {
      const abcd = (() => {
        switch (this._orient) {
          case "e":
            return void 0;
          case "s":
            return [0, 1, -1, 0];
          case "w":
            return [-1, 0, 0, -1];
          case "n":
            return [0, -1, 1, 0];
        }
      })();
      if (abcd !== void 0) {
        g.translate(this.posX, this.posY);
        g.transform(...abcd, 0, 0);
        g.translate(-this.posX, -this.posY);
      }
    }
    isOver(x, y) {
      return this.parent.mode >= 2 /* CONNECT */ && inRect(this._posX, this._posY, this.width, this.height, x, y);
    }
    trySetPosition(posX, posY, snapToGrid) {
      const newPos = this.tryMakePosition(posX, posY, snapToGrid);
      if (newPos === void 0) {
        return;
      }
      this.doSetPosition(newPos[0], newPos[1]);
      return newPos;
    }
    tryMakePosition(posX, posY, snapToGrid) {
      const roundTo = snapToGrid ? GRID_STEP / 2 : 1;
      posX = Math.round(posX / roundTo) * roundTo;
      posY = Math.round(posY / roundTo) * roundTo;
      if (posX !== this._posX || posY !== this.posY) {
        return [posX, posY];
      }
      return void 0;
    }
    doSetPosition(posX, posY) {
      const delta = [posX - this._posX, posY - this._posY];
      this._posX = posX;
      this._posY = posY;
      this.requestRedraw({ why: "position changed", invalidateMask: true });
      this.positionChanged(delta);
    }
    makeOrientationAndPosMenuItems() {
      var _a;
      const s = S.Components.Generic.contextMenu;
      const shortcuts = { e: "\u2192", s: "\u2193", w: "\u2190", n: "\u2191" };
      const rotateItem = !this.canRotate() ? [] : [
        ["start", MenuData.submenu("direction", s.Orientation, [
          ...Orientations.values.map((orient) => {
            const isCurrent = this._orient === orient;
            const icon = isCurrent ? "check" : "none";
            const caption = S.Orientations[orient];
            const action = isCurrent ? () => void 0 : () => {
              this.doSetOrient(orient);
            };
            return MenuData.item(icon, caption, action, shortcuts[orient]);
          }),
          MenuData.sep(),
          MenuData.text(s.ChangeOrientationDesc)
        ])]
      ];
      const lockPosItem = !this.canLockPos() ? [] : [
        ["start", MenuData.item(this.lockPos ? "check" : "none", s.LockPosition, () => {
          this.doSetLockPos(!this.lockPos);
        }, "L")]
      ];
      const anchorItem = this._anchor === void 0 ? [
        ["start", MenuData.item("none", s.SetAnchor, () => {
          this.parent.editor.showMessage(S.Messages.SetAnchorPrompt);
          this.parent.editor.setCurrentMouseAction("setanchor", false, this);
        })]
      ] : [
        ["start", MenuData.item("none", span(s.ClearAnchor[0], span(fixedWidthInContextMenu, (_a = this._anchor.ref) != null ? _a : "???"), s.ClearAnchor[1]), () => {
          this.anchor = void 0;
        })]
      ];
      return [...rotateItem, ...lockPosItem, ...anchorItem];
    }
    keyDown(e) {
      if (this.canRotate()) {
        if (e.key === "ArrowRight") {
          this.doSetOrient("e");
          return;
        } else if (e.key === "ArrowDown") {
          this.doSetOrient("s");
          return;
        } else if (e.key === "ArrowLeft") {
          this.doSetOrient("w");
          return;
        } else if (e.key === "ArrowUp") {
          this.doSetOrient("n");
          return;
        }
      }
      if (this.canLockPos()) {
        if (e.key === "l") {
          this.doSetLockPos(!this.lockPos);
          return;
        }
      }
      super.keyDown(e);
    }
  };
  __name(DrawableWithPosition, "DrawableWithPosition");
  var DrawableWithDraggablePosition = class extends DrawableWithPosition {
    constructor(parent, saved) {
      super(parent, saved);
      this._isMovingWithContext = void 0;
    }
    get anchor() {
      return this._anchor;
    }
    // This will typically be called in the deserialization once all components
    // have been created
    set anchor(anchor) {
      if (this._anchor !== anchor) {
        if (this._anchor !== void 0) {
          this._anchor.removeAnchoredDrawable(this);
        }
        this._anchor = anchor;
        if (anchor !== void 0) {
          anchor.addAnchoredDrawable(this);
        }
      }
    }
    get isMoving() {
      return this._isMovingWithContext !== void 0;
    }
    tryStartMoving(e) {
      if (this.lockPos) {
        return;
      }
      if (this._isMovingWithContext === void 0) {
        const [offsetX, offsetY] = this.parent.editor.offsetXY(e);
        this._isMovingWithContext = {
          mouseOffsetToPosX: offsetX - this.posX,
          mouseOffsetToPosY: offsetY - this.posY,
          lastAnchorX: this.posX,
          lastAnchorY: this.posY,
          createdClone: void 0
        };
      }
    }
    tryStopMoving(e) {
      var _a;
      let wasMoving = false;
      if (this._isMovingWithContext !== void 0) {
        this._isMovingWithContext = void 0;
        wasMoving = true;
      }
      (_a = this.parent.ifEditing) == null ? void 0 : _a.moveMgr.setDrawableStoppedMoving(this, e);
      return wasMoving;
    }
    setPosition(x, y, snapToGrid) {
      const newPos = this.tryMakePosition(x, y, snapToGrid);
      if (newPos !== void 0) {
        this.doSetPosition(...newPos);
      }
    }
    mouseDown(e) {
      if (this.parent.mode >= 2 /* CONNECT */) {
        if (e.metaKey) {
          this.parent.linkMgr.startSettingAnchorFrom(this);
          return { wantsDragEvents: false };
        }
        this.tryStartMoving(e);
      }
      return { wantsDragEvents: true };
    }
    mouseDragged(e) {
      var _a;
      if (this.parent.mode >= 2 /* CONNECT */ && !this.lockPos) {
        (_a = this.parent.ifEditing) == null ? void 0 : _a.moveMgr.setDrawableMoving(this, e);
        const [x, y] = this.parent.editor.offsetXY(e);
        const snapToGrid = !e.metaKey;
        this.updateSelfPositionIfNeeded(x, y, snapToGrid, e);
      }
    }
    mouseUp(e) {
      var _a, _b;
      (_b = (_a = this._isMovingWithContext) == null ? void 0 : _a.createdClone) == null ? void 0 : _b.mouseUp(e);
      const result = this.tryStopMoving(e);
      return InteractionResult.fromBoolean(result);
    }
    updateSelfPositionIfNeeded(x, y, snapToGrid, e) {
      if (this._isMovingWithContext === void 0) {
        return void 0;
      }
      const { mouseOffsetToPosX, mouseOffsetToPosY, lastAnchorX, lastAnchorY, createdClone } = this._isMovingWithContext;
      if (createdClone !== void 0) {
        createdClone.mouseDragged(e);
        return void 0;
      }
      let targetX = x - mouseOffsetToPosX;
      let targetY = y - mouseOffsetToPosY;
      if (e.shiftKey) {
        const dx = Math.abs(lastAnchorX - targetX);
        const dy = Math.abs(lastAnchorY - targetY);
        if (dx <= dy) {
          targetX = lastAnchorX;
        } else {
          targetY = lastAnchorY;
        }
      }
      const newPos = this.tryMakePosition(targetX, targetY, snapToGrid);
      if (newPos === void 0) {
        return void 0;
      }
      let clone;
      if (e.altKey && this.parent.mode >= 3 /* DESIGN */ && (clone = this.makeClone(true)) !== void 0) {
        this._isMovingWithContext.createdClone = clone;
        this.parent.editor.eventMgr.setCurrentMouseOverComp(clone);
      } else {
        this.doSetPosition(...newPos);
      }
      return newPos;
    }
    makeClone(__setSpawning) {
      return void 0;
    }
  };
  __name(DrawableWithDraggablePosition, "DrawableWithDraggablePosition");

  // simulator/src/components/Node.ts
  var WireColor = {
    black: "black",
    red: "red",
    blue: "blue",
    yellow: "yellow",
    green: "green",
    white: "white"
  };
  var DEFAULT_WIRE_COLOR = WireColor.black;
  var NodeBase = class extends DrawableWithPosition {
    constructor(component, nodeSpec, group2, shortName, fullName, _gridOffsetX, _gridOffsetY, hasTriangle, relativePosition, _leadLengthOverride) {
      super(component.parent);
      this.component = component;
      this.group = group2;
      this.shortName = shortName;
      this.fullName = fullName;
      this._gridOffsetX = _gridOffsetX;
      this._gridOffsetY = _gridOffsetY;
      this.hasTriangle = hasTriangle;
      this._leadLengthOverride = _leadLengthOverride;
      this._isAlive = true;
      this._value = false;
      this._initialValue = void 0;
      this._color = DEFAULT_WIRE_COLOR;
      this.id = nodeSpec.id;
      if ("force" in nodeSpec) {
        this._forceValue = toLogicValue(nodeSpec.force);
      }
      if ("color" in nodeSpec && nodeSpec.color !== void 0) {
        this._color = nodeSpec.color;
      }
      if ("initialValue" in nodeSpec && nodeSpec.initialValue !== void 0) {
        const initialValue = toLogicValue(nodeSpec.initialValue);
        this._initialValue = initialValue;
        this._value = initialValue;
      }
      this.parent.nodeMgr.addLiveNode(this.asNode);
      this.updatePositionFromParent();
      this.doSetOrient(relativePosition);
      this._leadLength = this.updateLeadLength();
    }
    get asNode() {
      return this;
    }
    updateLeadLength(leadLengthOverride) {
      var _a;
      return this._leadLength = (_a = leadLengthOverride != null ? leadLengthOverride : this._leadLengthOverride) != null ? _a : this.defaultLeadLength(Orientation.isVertical(this.orient));
    }
    defaultLeadLength(isVertical) {
      const bias = this.hasTriangle ? -2 : 0;
      if (isVertical) {
        return bias + Math.abs(this._gridOffsetY) * GRID_STEP - this.component.unrotatedHeight / 2;
      }
      return bias + Math.abs(this._gridOffsetX) * GRID_STEP - this.component.unrotatedWidth / 2;
    }
    get leadLength() {
      return this._leadLength;
    }
    /**
     * @returns [leadEndX, leadEndY, nodeX, nodeY, wireProlongDirection]
     */
    get drawCoords() {
      const dir = this.wireProlongDirection;
      const x = this.posX;
      const y = this.posY;
      switch (dir) {
        case "e":
          return [x + this.leadLength, y, x, y, dir];
        case "w":
          return [x - this.leadLength, y, x, y, dir];
        case "n":
          return [x, y - this.leadLength, x, y, dir];
        case "s":
          return [x, y + this.leadLength, x, y, dir];
      }
    }
    /**
     * @returns [leadEndX, leadEndY, nodeX, nodeY]
     */
    get drawCoordsInParentTransform() {
      const x = this.posXInParentTransform;
      const y = this.posYInParentTransform;
      switch (this.orient) {
        case "e":
          return [x - this.leadLength, y, x, y];
        case "w":
          return [x + this.leadLength, y, x, y];
        case "n":
          return [x, y + this.leadLength, x, y];
        case "s":
          return [x, y - this.leadLength, x, y];
      }
    }
    get anchor() {
      return void 0;
    }
    set anchor(__) {
      throw new Error("Node does not support anchoring");
    }
    isOutput() {
      return Node2.isOutput(this.asNode);
    }
    get unrotatedWidth() {
      return WAYPOINT_DIAMETER;
    }
    get unrotatedHeight() {
      return WAYPOINT_DIAMETER;
    }
    get color() {
      return this._color;
    }
    doSetColor(color) {
      this._color = color;
      this.propagateColor(color);
      this.requestRedraw({ why: "color changed" });
    }
    propagateColor(__color) {
    }
    isOver(x, y) {
      return this.parent.mode >= 2 /* CONNECT */ && isOverWaypoint(x, y, this.posX, this.posY) && this.acceptsMoreConnections;
    }
    destroy() {
      this.preDestroy();
      this._isAlive = false;
      this.parent.nodeMgr.removeLiveNode(this.asNode);
    }
    forceDraw() {
      return false;
    }
    doDraw(g, ctx) {
      const mode = this.parent.mode;
      if (mode < 2 /* CONNECT */ && !this.forceDraw() || !this.acceptsMoreConnections) {
        return;
      }
      const showForced = this._forceValue !== void 0 && mode >= 4 /* FULL */;
      const showForcedWarning = mode >= 4 /* FULL */ && !isUnknown(this._value) && !isUnknown(this.value) && this._value !== this.value;
      const parentOrientIsVertical = Orientation.isVertical(this.component.orient);
      const neutral = this.parent.editor.options.hideWireColors;
      drawWaypoint(g, ctx, this.posX, this.posY, this.nodeDisplayStyle, this.value, ctx.isMouseOver, neutral, showForced, showForcedWarning, parentOrientIsVertical);
    }
    get isAlive() {
      return this._isAlive;
    }
    get value() {
      return this._forceValue !== void 0 ? this._forceValue : this._value;
    }
    set value(val) {
      const oldVisibleValue = this.value;
      if (val !== this._value) {
        this._value = val;
        this.propagateNewValueIfNecessary(oldVisibleValue);
      }
    }
    propagateNewValueIfNecessary(oldVisibleValue) {
      const newVisibleValue = this.value;
      if (newVisibleValue !== oldVisibleValue) {
        this.propagateNewValue(newVisibleValue);
      }
    }
    get gridOffsetX() {
      return this._gridOffsetX;
    }
    set gridOffsetX(newVal) {
      this._gridOffsetX = newVal;
      this.updatePositionFromParent();
    }
    get gridOffsetY() {
      return this._gridOffsetY;
    }
    set gridOffsetY(newVal) {
      this._gridOffsetY = newVal;
      this.updatePositionFromParent();
    }
    get posXInParentTransform() {
      return this.component.posX + this._gridOffsetX * GRID_STEP;
    }
    get posYInParentTransform() {
      return this.component.posY + this._gridOffsetY * GRID_STEP;
    }
    updatePositionFromParent() {
      var _a;
      const component = this.component;
      const [appliedGridOffsetX, appliedGridOffsetY] = (() => {
        switch (component.orient) {
          case "e":
            return [+this._gridOffsetX, +this._gridOffsetY];
          case "w":
            return [-this._gridOffsetX, -this._gridOffsetY];
          case "s":
            return [-this._gridOffsetY, +this._gridOffsetX];
          case "n":
            return [+this._gridOffsetY, -this._gridOffsetX];
        }
      })();
      return (_a = super.trySetPosition(
        component.posX + appliedGridOffsetX * GRID_STEP,
        component.posY + appliedGridOffsetY * GRID_STEP,
        false
      )) != null ? _a : [this.posX, this.posY];
    }
    /**
     * Points in the direction with which an outgoing wire from this node should start,
     * e.g. to draw a smooth curve
     */
    get wireProlongDirection() {
      switch (this.component.orient) {
        case "e":
          switch (this.orient) {
            case "e":
              return "w";
            case "w":
              return "e";
            case "s":
              return "n";
            case "n":
              return "s";
          }
          break;
        case "w":
          return this.orient;
        case "s":
          switch (this.orient) {
            case "e":
              return "n";
            case "w":
              return "s";
            case "s":
              return "e";
            case "n":
              return "w";
          }
          break;
        case "n":
          switch (this.orient) {
            case "e":
              return "s";
            case "w":
              return "n";
            case "s":
              return "w";
            case "n":
              return "e";
          }
      }
    }
    cursorWhenMouseover(__e2) {
      return "crosshair";
    }
    mouseDown(__) {
      this.parent.linkMgr.startDraggingWireFrom(this.asNode);
      return { wantsDragEvents: false };
    }
    mouseUp(__) {
      const newWire = this.parent.linkMgr.stopDraggingWireOn(this.asNode);
      if (newWire === void 0) {
        return InteractionResult.NoChange;
      }
      return tryMakeRepeatableNodeAction(newWire.startNode, newWire.endNode, (startNode, endNode) => {
        const newWire2 = this.parent.linkMgr.addWire(startNode, endNode, true);
        return newWire2 !== void 0;
      });
    }
  };
  __name(NodeBase, "NodeBase");
  var NodeIn = class extends NodeBase {
    constructor() {
      super(...arguments);
      this._tag = "_nodein";
      this._incomingWire = null;
      this.prefersSpike = false;
      this.isClock = false;
    }
    get incomingWire() {
      return this._incomingWire;
    }
    set incomingWire(wire) {
      this._incomingWire = wire;
      if (wire === null) {
        this.value = false;
      } else {
        this.value = wire.startNode.value;
      }
    }
    get connectedWires() {
      return this._incomingWire === null ? [] : [this._incomingWire];
    }
    preDestroy() {
      if (this._incomingWire !== null) {
        this.parent.linkMgr.deleteWire(this._incomingWire);
      }
    }
    get acceptsMoreConnections() {
      return this._incomingWire === null;
    }
    positionChanged(__delta) {
      var _a;
      (_a = this._incomingWire) == null ? void 0 : _a.invalidateWirePath();
    }
    get forceValue() {
      return void 0;
    }
    get initialValue() {
      return void 0;
    }
    propagateNewValue(__newValue) {
      this.component.setNeedsRecalc();
    }
    get nodeDisplayStyle() {
      const disconnected = this._incomingWire === null;
      return disconnected ? 1 /* IN_DISCONNECTED */ : 0 /* IN_CONNECTED */;
    }
  };
  __name(NodeIn, "NodeIn");
  var NodeOut = class extends NodeBase {
    constructor() {
      super(...arguments);
      this._tag = "_nodeout";
      this._outgoingWires = [];
    }
    get isClock() {
      return false;
    }
    addOutgoingWire(wire) {
      const i2 = this._outgoingWires.indexOf(wire);
      if (i2 === -1) {
        this._outgoingWires.push(wire);
      }
    }
    removeOutgoingWire(wire) {
      const i2 = this._outgoingWires.indexOf(wire);
      if (i2 !== -1) {
        this._outgoingWires.splice(i2, 1);
      }
    }
    get outgoingWires() {
      return this._outgoingWires;
    }
    get connectedWires() {
      return this._outgoingWires;
    }
    preDestroy() {
      for (const wire of [...this._outgoingWires]) {
        this.parent.linkMgr.deleteWire(wire);
      }
    }
    get acceptsMoreConnections() {
      return true;
    }
    positionChanged(__delta) {
      if (this._outgoingWires !== void 0) {
        for (const wire of this._outgoingWires) {
          wire.invalidateWirePath();
        }
      }
    }
    findWireTo(node) {
      return this._outgoingWires.find((wire) => wire.endNode === node);
    }
    get forceValue() {
      return this._forceValue;
    }
    set forceValue(newForceValue) {
      const oldVisibleValue = this.value;
      this._forceValue = newForceValue;
      this.propagateNewValueIfNecessary(oldVisibleValue);
      this.requestRedraw({ why: "changed forced output value", invalidateTests: true });
    }
    get initialValue() {
      return this._initialValue;
    }
    propagateColor(color) {
      for (const wire of this._outgoingWires) {
        wire.endNode.doSetColor(color);
      }
    }
    propagateNewValue(newValue) {
      const now = this.parent.editor.timeline.logicalTime();
      for (const wire of this._outgoingWires) {
        wire.propagateNewValue(newValue, now);
      }
    }
    forceDraw() {
      return this._outgoingWires.length > 1 && this.component.alwaysDrawMultiOutNodes;
    }
    get nodeDisplayStyle() {
      const disconnected = this._outgoingWires.length === 0;
      return disconnected ? 3 /* OUT_DISCONNECTED */ : 2 /* OUT_CONNECTED */;
    }
    mouseDoubleClicked(e) {
      const superChange = super.mouseDoubleClicked(e);
      if (superChange.isChange) {
        return superChange;
      }
      if (this.parent.mode >= 4 /* FULL */ && e.altKey && this.isOutput() && this.component.allowsForcedOutputs) {
        this.forceValue = (() => {
          switch (this._forceValue) {
            case void 0:
              return Unknown;
            case Unknown:
              return HighImpedance;
            case HighImpedance:
              return false;
            case false:
              return true;
            case true:
              return void 0;
          }
        })();
        return InteractionResult.SimpleChange;
      }
      return InteractionResult.NoChange;
    }
  };
  __name(NodeOut, "NodeOut");
  var Node2 = {
    isOutput(node) {
      return node._tag === "_nodeout";
    }
  };
  function tryMakeRepeatableNodeAction(startNode, endNode, handleNodes) {
    const startGroup = startNode.group;
    const endGroup = endNode.group;
    if (startGroup === void 0 || endGroup === void 0) {
      return InteractionResult.SimpleChange;
    }
    const startIndex = startGroup.indexOf(startNode);
    const startIncrement = startIndex < startGroup.nodes.length - 1 ? 1 : -1;
    const endIndex = endGroup.indexOf(endNode);
    const endIncrement = endIndex < endGroup.nodes.length - 1 ? 1 : -1;
    const makeRepeatFunction = /* @__PURE__ */ __name(function makeRepeatFunction2(startIndex2, endIndex2) {
      if (startIndex2 >= startGroup.nodes.length || startIndex2 < 0 || endIndex2 >= endGroup.nodes.length || endIndex2 < 0) {
        return false;
      }
      return () => {
        const success2 = handleNodes(startGroup.nodes[startIndex2], endGroup.nodes[endIndex2]);
        if (success2) {
          return makeRepeatFunction2(startIndex2 + startIncrement, endIndex2 + endIncrement);
        }
        return false;
      };
    }, "makeRepeatFunction");
    const repeat = makeRepeatFunction(startIndex + startIncrement, endIndex + endIncrement);
    if (repeat === false) {
      return InteractionResult.SimpleChange;
    }
    return InteractionResult.RepeatableChange(repeat);
  }
  __name(tryMakeRepeatableNodeAction, "tryMakeRepeatableNodeAction");

  // simulator/src/components/Component.ts
  var NodeSeqRepr = /* @__PURE__ */ __name((fullNodeRepr) => t5.union([
    t5.number,
    t5.string,
    // a range of IDs as string
    fullNodeRepr,
    t5.array(t5.union([
      t5.number,
      t5.string,
      fullNodeRepr
    ]))
  ], "NodeSeqRepr"), "NodeSeqRepr");
  var InputNodeRepr = t5.type({
    id: t5.number
  }, "InputNode");
  var OutputNodeRepr = t5.intersection([
    t5.type({ id: t5.number }),
    t5.partial({
      force: LogicValueRepr,
      initialValue: LogicValueRepr,
      color: t5.keyof(WireColor)
    })
  ], "OutputNode");
  var InputNodeSeqRepr = NodeSeqRepr(InputNodeRepr);
  var OutputNodeSeqRepr = NodeSeqRepr(OutputNodeRepr);
  var OnlyInNodeIds = t5.partial({ id: InputNodeSeqRepr });
  var OnlyOutNodeIds = t5.partial({ id: OutputNodeSeqRepr });
  var InAndOutNodeIds = t5.partial({
    in: InputNodeSeqRepr,
    out: OutputNodeSeqRepr
  });
  var NoNodeIds = t5.type({});
  var NodeIDsRepr = /* @__PURE__ */ __name((hasIn, hasOut) => hasIn ? hasOut ? InAndOutNodeIds : OnlyInNodeIds : hasOut ? OnlyOutNodeIds : NoNodeIds, "NodeIDsRepr");
  var ComponentRepr = /* @__PURE__ */ __name((hasIn, hasOut) => t5.intersection([
    t5.type({
      type: t5.string
    }),
    PositionSupportRepr,
    NodeIDsRepr(hasIn, hasOut)
  ], "Component"), "ComponentRepr");
  function isNodeArray(obj) {
    return isArray(obj);
  }
  __name(isNodeArray, "isNodeArray");
  var NodeGroup = class {
    constructor(parent, name2) {
      this.parent = parent;
      this.name = name2;
      this._orient = "e";
      this._avgGridOffets = void 0;
      this.hasNameOverrides = false;
      this._nodes = [];
      this._nodes.group = this;
    }
    get nodes() {
      return this._nodes;
    }
    addNode(node) {
      if (this._avgGridOffets !== void 0) {
        console.warn("Adding nodes to a group after the group's position has been used");
      }
      this._nodes.push(node);
      this._orient = node.orient;
    }
    get avgGridOffsets() {
      if (this._avgGridOffets === void 0) {
        let x = 0;
        let y = 0;
        for (const node of this._nodes) {
          x += node.gridOffsetX;
          y += node.gridOffsetY;
        }
        const len = this._nodes.length;
        this._avgGridOffets = [x / len, y / len];
      }
      return this._avgGridOffets;
    }
    get orient() {
      return this._orient;
    }
    get posXInParentTransform() {
      return this.parent.posX + this.avgGridOffsets[0] * GRID_STEP;
    }
    get posYInParentTransform() {
      return this.parent.posY + this.avgGridOffsets[1] * GRID_STEP;
    }
    // allows the Node type (rather than N for group.nodes.indexOf(...))
    indexOf(node) {
      for (let i2 = 0; i2 < this._nodes.length; i2++) {
        if (this._nodes[i2] === node) {
          return i2;
        }
      }
      return -1;
    }
  };
  __name(NodeGroup, "NodeGroup");
  function isDynamicName(obj) {
    if (!isRecord(obj)) {
      return false;
    }
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key) && typeof obj[key] !== "string") {
        return false;
      }
    }
    return true;
  }
  __name(isDynamicName, "isDynamicName");
  var ComponentNameRepr = typeOrUndefined(
    t5.union([
      t5.string,
      t5.record(t5.union([t5.string, t5.number]), t5.string)
    ])
  );
  function isNodeDesc(desc) {
    return isNumber(desc[0]);
  }
  __name(isNodeDesc, "isNodeDesc");
  var ComponentBase = class extends DrawableWithDraggablePosition {
    constructor(parent, def, saved) {
      super(parent, saved);
      this._anchoredDrawables = [];
      this.def = def;
      this._width = def.size.gridWidth * GRID_STEP;
      this._height = def.size.gridHeight * GRID_STEP;
      this._value = def.initialValue(saved);
      const ins = def.nodeRecs.ins;
      const outs = def.nodeRecs.outs;
      function countNodes(rec) {
        if (rec === void 0) {
          return 0;
        }
        let count = 0;
        for (const desc of Object.values(rec)) {
          if (isNodeDesc(desc)) {
            count++;
          } else {
            for (const innerDesc of desc) {
              if (isNodeDesc(innerDesc)) {
                count++;
              } else {
                count += innerDesc.length;
              }
            }
          }
        }
        return count;
      }
      __name(countNodes, "countNodes");
      const numInputs = countNodes(ins);
      const numOutputs = countNodes(outs);
      if (saved !== void 0) {
        this._state = 1 /* SPAWNED */;
      } else {
        this.setSpawning();
      }
      const [inputSpecs, outputSpecs, hasAnyPrecomputedInitialValues] = this.nodeSpecsFromRepr(saved, numInputs, numOutputs);
      [this.inputs, this.inputGroups] = this.makeNodes(ins, inputSpecs, NodeIn);
      [this.outputs, this.outputGroups] = this.makeNodes(outs, outputSpecs, NodeOut);
      if (!hasAnyPrecomputedInitialValues) {
        this.setNeedsRecalc(true);
      } else {
        this.requestPropagate();
      }
    }
    setSpawning() {
      var _a;
      this._state = 0 /* SPAWNING */;
      (_a = this.parent.ifEditing) == null ? void 0 : _a.moveMgr.setDrawableMoving(this);
    }
    setSpawned() {
      var _a;
      this._state = 1 /* SPAWNED */;
      (_a = this.parent.ifEditing) == null ? void 0 : _a.moveMgr.setDrawableStoppedMoving(this);
    }
    setInvalid() {
      this._state = 3 /* INVALID */;
    }
    /**
     * Returns the JSON representation of this component, but without nodes
     * and without the id. This is useful to clone a component. Nodes and ids
     * can then be restored on the clone.
     */
    toNodelessJSON() {
      const repr = this.toJSON();
      delete repr.ref;
      delete repr.in;
      delete repr.out;
      delete repr.id;
      return repr;
    }
    /**
     * Returns the JSON representation of the fields this superclass knows
     * about. Typically used by subclasses to provide only their specific JSON,
     * splatting in the result of super.toJSONBase() in the object.
     */
    toJSONBase() {
      const typeHolder = {
        // not sure why we need a separate object to splat in just
        // a few lines below, but this makes the compiler happy
        type: this.jsonType()
      };
      return __spreadValues(__spreadValues(__spreadValues({}, typeHolder), super.toJSONBase()), this.buildNodesRepr());
    }
    jsonType() {
      return this.def.type;
    }
    // creates the input/output nodes based on array of offsets (provided
    // by subclass) and spec (either loaded from JSON repr or newly generated)
    makeNodes(nodeRec, specs, node) {
      const nodes = {};
      const allNodes = [];
      const nodeGroups = /* @__PURE__ */ new Map();
      if (nodeRec !== void 0) {
        const makeNode = /* @__PURE__ */ __name((group2, shortName, desc) => {
          var _a, _b, _c;
          const spec = specs[nextSpecIndex++];
          const [offsetX, offsetY, orient, nameOrOptions, options_] = desc;
          let nameOverride = void 0;
          let options = void 0;
          if (isString(nameOrOptions)) {
            nameOverride = nameOrOptions;
          } else if (nameOrOptions !== void 0) {
            options = nameOrOptions;
          }
          if (options_ !== void 0) {
            options = options_;
          }
          const isClock = (_a = options == null ? void 0 : options.isClock) != null ? _a : false;
          const prefersSpike = (_b = options == null ? void 0 : options.prefersSpike) != null ? _b : false;
          const leadLength = options == null ? void 0 : options.leadLength;
          const hasTriangle = (_c = options == null ? void 0 : options.hasTriangle) != null ? _c : false;
          if (group2 !== void 0 && nameOverride !== void 0) {
            shortName = nameOverride;
            group2.hasNameOverrides = true;
          } else if ((options == null ? void 0 : options.labelName) !== void 0) {
            shortName = options.labelName;
          }
          const fullName = nameOverride === void 0 ? shortName : nameOverride;
          const newNode = new node(
            this,
            spec,
            group2,
            shortName,
            fullName,
            offsetX,
            offsetY,
            hasTriangle,
            orient,
            leadLength
          );
          if (prefersSpike || isClock) {
            if (newNode instanceof NodeIn) {
              newNode.prefersSpike = true;
              newNode.isClock = isClock;
            } else {
              console.warn(`prefersSpike is only supported for inputs, can't set it for ${name}`);
            }
          }
          allNodes.push(newNode);
          return newNode;
        }, "makeNode");
        let nextSpecIndex = 0;
        for (const [fieldName, desc] of Object.entries(nodeRec)) {
          if (isNodeDesc(desc)) {
            nodes[fieldName] = makeNode(void 0, fieldName, desc);
          } else {
            const makeNodesForGroup = /* @__PURE__ */ __name((groupDesc, groupName, namePrefix) => {
              const group2 = new NodeGroup(this, groupName);
              nodeGroups.set(groupName, group2);
              for (let i2 = 0; i2 < groupDesc.length; i2++) {
                group2.addNode(makeNode(group2, namePrefix + i2, groupDesc[i2]));
              }
              return group2.nodes;
            }, "makeNodesForGroup");
            if (isNodeDesc(desc[0])) {
              const groupDesc = desc;
              nodes[fieldName] = makeNodesForGroup(groupDesc, fieldName, fieldName);
            } else {
              const groupMultiDesc = desc;
              nodes[fieldName] = groupMultiDesc.map((groupDesc, i2) => makeNodesForGroup(groupDesc, `${fieldName}${i2}`, `${fieldName}${i2}.`));
            }
          }
        }
      }
      nodes._all = allNodes;
      return [nodes, nodeGroups];
    }
    // generates two arrays of normalized node specs either as loaded from
    // JSON or obtained with default values when _repr is null and we're
    // creating a new component from scratch
    nodeSpecsFromRepr(_repr, numInputs, numOutputs) {
      const nodeMgr = this.parent.nodeMgr;
      const makeDefaultSpec = /* @__PURE__ */ __name(() => ({ id: nodeMgr.getFreeId() }), "makeDefaultSpec");
      const makeDefaultSpecArray = /* @__PURE__ */ __name((len) => ArrayFillUsing(makeDefaultSpec, len), "makeDefaultSpecArray");
      if (_repr === void 0) {
        return [
          makeDefaultSpecArray(numInputs),
          makeDefaultSpecArray(numOutputs),
          false
        ];
      }
      let inputSpecs = [];
      let outputSpecs = [];
      const makeNormalizedSpecs = /* @__PURE__ */ __name((num, seqRepr) => {
        if (seqRepr === void 0) {
          return makeDefaultSpecArray(num);
        }
        const specs = [];
        function pushId(sourceId) {
          const id = nodeMgr.getFreeIdFrom(sourceId);
          specs.push({ id });
        }
        __name(pushId, "pushId");
        for (const spec of isArray(seqRepr) ? seqRepr : [seqRepr]) {
          if (isNumber(spec)) {
            pushId(spec);
          } else if (isString(spec)) {
            const [start2, end2] = spec.split("-").map((s) => parseInt(s));
            for (let i2 = start2; i2 <= end2; i2++) {
              pushId(i2);
            }
          } else {
            spec.id = nodeMgr.getFreeIdFrom(spec.id);
            specs.push(spec);
          }
        }
        return specs;
      }, "makeNormalizedSpecs");
      if (numInputs !== 0) {
        if (numOutputs !== 0) {
          const repr = _repr;
          inputSpecs = makeNormalizedSpecs(numInputs, repr.in);
          outputSpecs = makeNormalizedSpecs(numOutputs, repr.out);
        } else {
          const repr = _repr;
          inputSpecs = makeNormalizedSpecs(numInputs, repr.id);
        }
      } else if (numOutputs !== 0) {
        const repr = _repr;
        outputSpecs = makeNormalizedSpecs(numOutputs, repr.id);
      }
      const hasAnyPrecomputedInitialValues = outputSpecs.some((spec) => spec.initialValue !== void 0);
      return [inputSpecs, outputSpecs, hasAnyPrecomputedInitialValues];
    }
    // from the known nodes, builds the JSON representation of them,
    // using the most compact form available
    buildNodesRepr() {
      const numInputs = this.inputs._all.length;
      const numOutputs = this.outputs._all.length;
      function inNodeReprs(nodes) {
        const reprOne = /* @__PURE__ */ __name((node) => node.id, "reprOne");
        if (nodes.length === 1) {
          return reprOne(nodes[0]);
        } else {
          return compactRepr(nodes.map(reprOne));
        }
      }
      __name(inNodeReprs, "inNodeReprs");
      function outNodeReprs(nodes) {
        const reprOne = /* @__PURE__ */ __name((node) => {
          const valueNotForced = node.forceValue === void 0;
          const noInitialValue = node.initialValue === void 0;
          const hasStandardColor = node.color === DEFAULT_WIRE_COLOR;
          if (valueNotForced && hasStandardColor && noInitialValue) {
            return node.id;
          } else {
            return {
              id: node.id,
              intialValue: noInitialValue ? void 0 : toLogicValueRepr(node.initialValue),
              force: valueNotForced ? void 0 : toLogicValueRepr(node.forceValue),
              color: hasStandardColor ? void 0 : node.color
            };
          }
        }, "reprOne");
        if (nodes.length === 1) {
          return reprOne(nodes[0]);
        } else {
          return compactRepr(nodes.map(reprOne));
        }
      }
      __name(outNodeReprs, "outNodeReprs");
      function compactRepr(reprs) {
        const newArray = [];
        let currentRangeStart = void 0;
        let currentRangeEnd = void 0;
        function pushRange() {
          if (currentRangeStart !== void 0 && currentRangeEnd !== void 0) {
            if (currentRangeStart === currentRangeEnd) {
              newArray.push(currentRangeStart);
            } else if (currentRangeEnd === currentRangeStart + 1) {
              newArray.push(currentRangeStart);
              newArray.push(currentRangeEnd);
            } else {
              newArray.push(`${currentRangeStart}-${currentRangeEnd}`);
            }
            currentRangeStart = void 0;
            currentRangeEnd = void 0;
          }
        }
        __name(pushRange, "pushRange");
        for (const repr of reprs) {
          if (isNumber(repr)) {
            if (currentRangeStart !== void 0 && repr - 1 === currentRangeEnd) {
              currentRangeEnd = repr;
            } else {
              pushRange();
              currentRangeStart = currentRangeEnd = repr;
            }
          } else {
            pushRange();
            newArray.push(repr);
          }
        }
        pushRange();
        if (newArray.length === 1) {
          return newArray[0];
        }
        return newArray;
      }
      __name(compactRepr, "compactRepr");
      return numInputs !== 0 ? numOutputs !== 0 ? { in: inNodeReprs(this.inputs._all), out: outNodeReprs(this.outputs._all) } : { id: inNodeReprs(this.inputs._all) } : numOutputs !== 0 ? { id: outNodeReprs(this.outputs._all) } : {};
    }
    get anchoredDrawables() {
      return this._anchoredDrawables;
    }
    // only called by Drawable when setting/clearing anchor
    addAnchoredDrawable(drawable) {
      this._anchoredDrawables.push(drawable);
    }
    // only called by Drawable when setting/clearing anchor
    removeAnchoredDrawable(drawable) {
      this._anchoredDrawables = this._anchoredDrawables.filter((d) => d !== drawable);
    }
    get unrotatedWidth() {
      return this._width;
    }
    get unrotatedHeight() {
      return this._height;
    }
    toStringDetails() {
      const maybeName = this._name;
      const name2 = maybeName !== void 0 ? `name='${maybeName}', ` : "";
      return name2 + String(this.value);
    }
    get state() {
      return this._state;
    }
    get allowsForcedOutputs() {
      return true;
    }
    get alwaysDrawMultiOutNodes() {
      return false;
    }
    *allNodes() {
      for (const node of this.inputs._all) {
        yield node;
      }
      for (const node of this.outputs._all) {
        yield node;
      }
    }
    *allNodeGroups() {
      for (const group2 of this.inputGroups.values()) {
        yield group2;
      }
      for (const group2 of this.outputGroups.values()) {
        yield group2;
      }
    }
    get value() {
      return this._value;
    }
    doSetValue(newValue, forcePropagate = false) {
      const oldValue = this._value;
      if (forcePropagate || !deepArrayEquals(newValue, oldValue)) {
        this._value = newValue;
        this.requestRedraw({ why: "value changed", invalidateTests: true });
        this.requestPropagate();
      }
    }
    recalcValue(forcePropagate) {
      this.doSetValue(this.doRecalcValue(), forcePropagate);
    }
    propagateCurrentValue() {
      this.propagateValue(this._value);
    }
    propagateValue(__newValue) {
    }
    inputValues(nodes) {
      return nodes.map((node) => node.value);
    }
    outputValues(nodes, values, reverse = false) {
      const num = nodes.length;
      if (values.length !== num) {
        throw new Error(`outputValues: expected ${num} values, got ${values.length}`);
      }
      for (let i2 = 0; i2 < num; i2++) {
        const j = reverse ? num - i2 - 1 : i2;
        nodes[i2].value = values[j];
      }
    }
    setNeedsRecalc(forcePropagate = false) {
      this.parent.recalcMgr.enqueueForRecalc(this, forcePropagate);
    }
    requestPropagate() {
      this.parent.recalcMgr.enqueueForPropagate(this);
    }
    updateNodePositions() {
      for (const node of this.allNodes()) {
        node.updatePositionFromParent();
      }
    }
    bounds(honorRotation = false) {
      return new DrawingRect(this, honorRotation);
    }
    draw(g, drawParams) {
      super.draw(g, drawParams);
      if (this._state === 3 /* INVALID */) {
        g.fillStyle = "rgba(255, 0, 0, 0.3)";
        const bounds = this.bounds(true);
        g.fill(bounds.outline(g, 5));
      }
    }
    doDraw(g, ctx) {
      this.doDrawDefault(g, ctx);
    }
    doDrawDefault(g, ctx, opts_) {
      var _a, _b, _c;
      const bounds = this.bounds();
      const opts = typeof opts_ !== "function" ? opts_ : { drawLabels: opts_ };
      g.fillStyle = (_a = opts == null ? void 0 : opts.background) != null ? _a : COLOR_BACKGROUND;
      const outline = bounds.outline(g);
      g.fill(outline);
      for (const node of this.allNodes()) {
        this.drawWireLineTo(g, node, bounds);
      }
      const drawLabels = !((_b = opts == null ? void 0 : opts.skipLabels) != null ? _b : false);
      if (drawLabels) {
        for (const group2 of this.allNodeGroups()) {
          if (!group2.hasNameOverrides) {
            this.drawGroupBox(g, group2, bounds);
          }
        }
      }
      (_c = opts == null ? void 0 : opts.drawInside) == null ? void 0 : _c.call(opts, bounds);
      g.lineWidth = 3;
      g.strokeStyle = ctx.borderColor;
      g.stroke(outline);
      ctx.inNonTransformedFrame((ctx2) => {
        var _a2, _b2, _c2;
        if (((_a2 = opts == null ? void 0 : opts.componentName) == null ? void 0 : _a2[0]) !== void 0) {
          const [name2, onRight, value] = opts.componentName;
          const val = isNumber(value) || isString(value) ? value : value();
          drawComponentName(g, ctx2, name2, val, this, onRight);
        }
        if (drawLabels) {
          const labelSize = (_b2 = opts == null ? void 0 : opts.labelSize) != null ? _b2 : 11;
          g.fillStyle = COLOR_COMPONENT_INNER_LABELS;
          g.textAlign = "center";
          g.font = `bold ${labelSize}px sans-serif`;
          for (const group2 of this.allNodeGroups()) {
            if (!group2.hasNameOverrides) {
              this.drawGroupLabel(ctx2, group2, bounds);
            }
          }
          g.font = `${labelSize}px sans-serif`;
          for (const node of this.allNodes()) {
            if (node.group === void 0 || node.group.hasNameOverrides) {
              this.drawNodeLabel(ctx2, node, bounds);
            }
          }
        }
        (_c2 = opts == null ? void 0 : opts.drawLabels) == null ? void 0 : _c2.call(opts, ctx2, bounds);
      });
    }
    drawWireLineTo(g, node, bounds) {
      var _a;
      if (node.isClock) {
        drawClockInput(g, bounds.left, node, (_a = this["_trigger"]) != null ? _a : EdgeTrigger.rising);
        return;
      }
      drawWireLineToComponent(g, node);
    }
    drawGroupBox(g, group2, bounds) {
      if (!shouldDrawLeadsTo(group2.nodes)) {
        return;
      }
      const groupWidth = Orientation.isVertical(Orientation.add(this.orient, group2.orient)) ? 8 : 6;
      const first = group2.nodes[0];
      const last = group2.nodes[group2.nodes.length - 1];
      const beforeAfterMargin = 2;
      g.beginPath();
      switch (group2.orient) {
        case "e":
          g.rect(bounds.right - groupWidth, first.posYInParentTransform - beforeAfterMargin, groupWidth, last.posYInParentTransform - first.posYInParentTransform + 2 * beforeAfterMargin);
          break;
        case "w":
          g.rect(bounds.left, first.posYInParentTransform - beforeAfterMargin, groupWidth, last.posYInParentTransform - first.posYInParentTransform + 2 * beforeAfterMargin);
          break;
        case "n":
          g.rect(last.posXInParentTransform - beforeAfterMargin, bounds.top, first.posXInParentTransform - last.posXInParentTransform + 2 * beforeAfterMargin, groupWidth);
          break;
        case "s":
          g.rect(last.posXInParentTransform - beforeAfterMargin, bounds.bottom - groupWidth, first.posXInParentTransform - last.posXInParentTransform + 2 * beforeAfterMargin, groupWidth);
          break;
      }
      g.fillStyle = COLOR_GROUP_SPAN;
      g.fill();
    }
    drawNodeLabel(ctx, node, bounds) {
      if (!node.isClock && !isTrivialNodeName(node.shortName)) {
        drawLabel(ctx, this.orient, node.shortName, node.orient, ...this.anchorFor(node, bounds, 1), node);
      }
    }
    drawGroupLabel(ctx, group2, bounds) {
      if (!isTrivialNodeName(group2.name)) {
        drawLabel(ctx, this.orient, group2.name, group2.orient, ...this.anchorFor(group2, bounds, 1), group2.nodes);
      }
    }
    anchorFor(elem, bounds, offset2) {
      switch (elem.orient) {
        case "e":
          return [bounds.right + offset2, elem.posYInParentTransform];
        case "w":
          return [bounds.left - offset2, elem.posYInParentTransform];
        case "n":
          return [elem.posXInParentTransform, bounds.top - offset2];
        case "s":
          return [elem.posXInParentTransform, bounds.bottom + offset2];
      }
    }
    replaceWithComponent(newComp) {
      var _a, _b;
      const saveWires = /* @__PURE__ */ __name((nodes, getWires) => {
        const savedWires = /* @__PURE__ */ new Map();
        for (const node of nodes) {
          const wires = getWires(node);
          if (wires === null) {
            continue;
          }
          const group2 = node.group;
          const keyName = group2 === void 0 ? node.shortName : `${group2.name}[${group2.nodes.indexOf(node)}]`;
          savedWires.set(keyName, wires);
        }
        return savedWires;
      }, "saveWires");
      const savedWiresIn = saveWires(this.inputs._all, (node) => node.incomingWire);
      const savedWiresOut = saveWires(this.outputs._all, (node) => node.outgoingWires);
      const restoreNodes = /* @__PURE__ */ __name((savedWires, nodes, setWires) => {
        for (const node of nodes) {
          const group2 = node.group;
          if (group2 === void 0) {
            let wires = savedWires.get(node.shortName);
            if (wires === void 0) {
              wires = savedWires.get(node.shortName + "[0]");
            }
            if (wires !== void 0) {
              setWires(wires, node);
            }
          } else {
            const i2 = group2.nodes.indexOf(node);
            let wires = savedWires.get(`${group2.name}[${i2}]`);
            if (wires === void 0 && i2 === 0) {
              wires = savedWires.get(group2.name);
            }
            if (wires !== void 0) {
              setWires(wires, node);
            }
          }
        }
      }, "restoreNodes");
      restoreNodes(savedWiresIn, newComp.inputs._all, (wire, node) => {
        wire.setEndNode(node);
      });
      const now = this.parent.editor.timeline.logicalTime();
      restoreNodes(savedWiresOut, newComp.outputs._all, (wires, node) => {
        for (const wire of [...wires]) {
          wire.setStartNode(node, now);
        }
      });
      const componentList = this.parent.components;
      const deleted = componentList.tryDelete(this);
      if (!deleted) {
        console.warn("Could not delete old component");
      }
      newComp.setPosition(this.posX, this.posY, false);
      newComp.setSpawned();
      const ref = this.ref;
      if (ref !== void 0 && !componentList.looksLikeAutoGeneratedId(this)) {
        componentList.changeIdOf(newComp, ref);
      }
      (_a = this.parent.ifEditing) == null ? void 0 : _a.undoMgr.takeSnapshot();
      (_b = this.parent.ifEditing) == null ? void 0 : _b.redrawMgr.requestRedraw({ why: "component replaced", component: newComp, invalidateMask: true, invalidateTests: true });
      return newComp;
    }
    makeClone(setSpawning) {
      const repr = this.toNodelessJSON();
      const newComp = this.def.makeFromJSON(this.parent, repr);
      if (newComp === void 0) {
        console.warn("Could not create component clone");
      } else {
        if (setSpawning) {
          newComp.setSpawning();
        }
      }
      return newComp;
    }
    mouseDown(e) {
      if (this.parent.mode >= 2 /* CONNECT */ && !e.shiftKey) {
        const eventMgr = this.parent.editor.eventMgr;
        let elems;
        if (eventMgr.currentSelection !== void 0 && (elems = eventMgr.currentSelection.previouslySelectedElements).size > 0 && !elems.has(this)) {
          eventMgr.currentSelection = void 0;
        }
      }
      return super.mouseDown(e);
    }
    mouseUp(e) {
      var _a;
      let wasSpawning = false;
      if (this._state === 0 /* SPAWNING */) {
        this._state = 1 /* SPAWNED */;
        wasSpawning = true;
      }
      const wasMoving = super.mouseUp(e).isChange;
      if (wasSpawning || wasMoving) {
        const newLinks = this.parent.nodeMgr.tryConnectNodesOf(this);
        if (newLinks.length > 0) {
          this.autoConnected(newLinks);
        }
        (_a = this.parent.ifEditing) == null ? void 0 : _a.setDirty("moved component");
        return InteractionResult.SimpleChange;
      }
      const linkMgr = this.parent.editor.linkMgr;
      if (linkMgr.isSettingAnchor) {
        return linkMgr.stopSettingAnchorOn(this);
      }
      return InteractionResult.NoChange;
    }
    autoConnected(__newLinks) {
    }
    updateSelfPositionIfNeeded(x, y, snapToGrid, e) {
      if (this._state === 0 /* SPAWNING */) {
        return this.trySetPosition(x, y, snapToGrid);
      }
      return super.updateSelfPositionIfNeeded(x, y, snapToGrid, e);
    }
    positionChanged(delta) {
      this.updateNodePositions();
      for (const anchored of this._anchoredDrawables) {
        anchored.setPosition(anchored.posX + delta[0], anchored.posY + delta[1], false);
      }
    }
    mouseClicked(e) {
      if (this.parent.mode >= 2 /* CONNECT */ && e.shiftKey) {
        this.parent.editor.eventMgr.toggleSelect(this);
        return InteractionResult.SimpleChange;
      }
      return InteractionResult.NoChange;
    }
    mouseDoubleClicked(e) {
      if (this.parent.mode >= 2 /* CONNECT */ && e.metaKey && this.canRotate()) {
        const doChange = /* @__PURE__ */ __name(() => {
          this.doSetOrient(Orientation.nextClockwise(this.orient));
          return true;
        }, "doChange");
        doChange();
        return InteractionResult.RepeatableChange(doChange);
      }
      return InteractionResult.NoChange;
    }
    doSetOrient(orient) {
      super.doSetOrient(orient);
      this.updateNodePositions();
    }
    destroy() {
      this._state = 2 /* DEAD */;
      for (const node of this.allNodes()) {
        node.destroy();
      }
    }
    cursorWhenMouseover(e) {
      var _a, _b;
      const mode = this.parent.mode;
      if (((_a = e == null ? void 0 : e.ctrlKey) != null ? _a : false) && mode >= 2 /* CONNECT */) {
        return "context-menu";
      }
      if (((_b = e == null ? void 0 : e.altKey) != null ? _b : false) && mode >= 3 /* DESIGN */) {
        return "copy";
      }
      if (!this.lockPos && mode >= 2 /* CONNECT */) {
        return "grab";
      }
      return void 0;
    }
    makeContextMenu() {
      const menuItems = [];
      const baseItems = this.makeBaseContextMenu(this.parent.editor);
      const specificItems = this.makeComponentSpecificContextMenuItems();
      let lastWasSep = true;
      function addItemsAt(placement, items, insertSep = false) {
        if (insertSep) {
          if (!lastWasSep) {
            menuItems.push(MenuData.sep());
          }
          lastWasSep = true;
        }
        for (const [pl, it] of items) {
          if (pl === placement) {
            menuItems.push(it);
            lastWasSep = it._tag === "sep";
          }
        }
      }
      __name(addItemsAt, "addItemsAt");
      addItemsAt("start", specificItems);
      addItemsAt("start", baseItems);
      addItemsAt("mid", baseItems, true);
      addItemsAt("mid", specificItems);
      addItemsAt("end", baseItems, true);
      addItemsAt("end", specificItems);
      return menuItems;
    }
    makeBaseContextMenu(editor) {
      const s = S.Components.Generic.contextMenu;
      const nonEmptySelectionInMainEditor = !editor.eventMgr.currentSelectionEmpty() && this.parent.isMainEditor();
      const makeNewComponentItems = !nonEmptySelectionInMainEditor || !UIPermissions.canModifyCustomComponents(this.parent) ? [] : [
        ["start", MenuData.item("newcomponent", s.MakeNewComponent, () => {
          var _a;
          const result = editor.factory.tryMakeNewCustomComponent(editor);
          if (isString(result)) {
            if (result.length > 0) {
              window.alert(s.MakeNewComponentFailed + " " + result);
            }
          } else {
            (_a = editor.options.showOnly) == null ? void 0 : _a.push(result.id);
            editor.updateCustomComponentButtons();
          }
        })]
      ];
      const makeNewTestCaseItems = !nonEmptySelectionInMainEditor || !UIPermissions.canModifyTestCases(this.parent) ? [] : [
        ["start", MenuData.item("testcase", s.MakeNewTestCase, () => {
          const result = editor.factory.tryMakeNewTestCase(editor);
          if (isString(result)) {
            if (result.length > 0) {
              window.alert(s.MakeNewTestCaseFailed + " " + result);
            }
            return;
          }
          this.parent.editor.addTestCases(result);
        })],
        ["start", MenuData.item("testcase", s.MakeAllTestCases, () => __async(this, null, function* () {
          const result = yield editor.factory.tryMakeAllTestCases(editor);
          if (isString(result)) {
            if (result.length > 0) {
              window.alert(s.MakeNewTestCaseFailed + " " + result);
            }
            return;
          }
          this.parent.editor.addTestCases(result);
        }))]
      ];
      if (makeNewComponentItems.length > 0 || makeNewTestCaseItems.length > 0) {
        makeNewTestCaseItems.push(["start", MenuData.sep()]);
      }
      const setRefItems = editor.mode < 4 /* FULL */ ? [] : [
        ["end", this.makeSetIdContextMenuItem()],
        ["end", MenuData.sep()]
      ];
      const resetItem = this.state !== 3 /* INVALID */ ? [] : [
        ["end", MenuData.item("reset", s.Reset, () => {
          this._state = 1 /* SPAWNED */;
          this.setNeedsRecalc(true);
        })]
      ];
      const deleteItem = MenuData.item("trash", s.Delete, () => {
        const deleted = this.parent.components.tryDelete(this);
        if (deleted) {
          this.requestRedraw({ why: "deleted component", invalidateMask: true, invalidateTests: true });
          return InteractionResult.SimpleChange;
        }
        return InteractionResult.NoChange;
      }, "\u232B", true);
      return [
        ["start", MenuData.sep()],
        ...makeNewComponentItems,
        ...makeNewTestCaseItems,
        ...this.makeOrientationAndPosMenuItems(),
        ...setRefItems,
        ...resetItem,
        ["end", deleteItem]
      ];
    }
    makeComponentSpecificContextMenuItems() {
      return [];
    }
    makeForceOutputsContextMenuItem(withSepBefore = false) {
      const numOutputs = this.outputs._all.length;
      if (numOutputs === 0 || this.parent.mode < 4 /* FULL */) {
        return [];
      }
      const s = S.Components.Generic.contextMenu;
      function makeOutputItems(out) {
        const currentForceValue = out.forceValue;
        const items2 = [void 0, Unknown, true, false, HighImpedance].map((newForceValue) => MenuData.item(
          currentForceValue === newForceValue ? "check" : "none",
          (() => {
            switch (newForceValue) {
              case void 0:
                return s.NormalOutput;
              case Unknown:
                return s.ForceAsUnknown;
              case true:
                return s.ForceAs1;
              case false:
                return s.ForceAs0;
              case HighImpedance:
                return s.ForceAsZ;
            }
          })(),
          () => {
            out.forceValue = newForceValue;
          }
        ));
        items2.splice(1, 0, MenuData.sep());
        return items2;
      }
      __name(makeOutputItems, "makeOutputItems");
      const footerItems = [
        MenuData.sep(),
        MenuData.text(s.ForceOutputDesc)
      ];
      const items = [];
      if (withSepBefore) {
        items.push(["mid", MenuData.sep()]);
      }
      if (numOutputs === 1) {
        items.push(["mid", MenuData.submenu("force", s.ForceOutputSingle, [
          ...makeOutputItems(this.outputs._all[0]),
          ...footerItems
        ])]);
      } else {
        items.push(["mid", MenuData.submenu("force", s.ForceOutputMultiple, [
          ...this.outputs._all.map((out) => {
            const icon = out.forceValue !== void 0 ? "force" : "none";
            return MenuData.submenu(
              icon,
              s.Output + " " + out.fullName,
              makeOutputItems(out)
            );
          }),
          ...footerItems
        ])]);
      }
      return items;
    }
    makeSetNameContextMenuItem(currentName, handler) {
      const s = S.Components.Generic.contextMenu;
      const caption = currentName === void 0 ? s.SetName : s.ChangeName;
      return MenuData.item("pen", caption, () => this.runSetNameDialog(currentName, handler), "\u21A9\uFE0E");
    }
    runSetNameDialog(currentName, handler) {
      const currentDisplayName = currentName === void 0 || isString(currentName) ? currentName : import_json52.default.stringify(currentName);
      const promptReturnValue = window.prompt(S.Components.Generic.contextMenu.SetNamePrompt, currentDisplayName);
      if (promptReturnValue !== null) {
        let newName;
        if (promptReturnValue.length === 0) {
          newName = void 0;
        } else {
          try {
            const parsedValue = import_json52.default.parse(promptReturnValue);
            if (isDynamicName(parsedValue)) {
              newName = parsedValue;
            } else {
              newName = promptReturnValue;
            }
          } catch (e) {
            newName = promptReturnValue;
          }
        }
        handler(newName);
      }
    }
    runSetFontDialog(currentFont, defaultIfEmpty, callback) {
      const s = S.Components.Generic.contextMenu;
      const promptReturnValue = window.prompt(s.SetFontPrompt[0] + defaultIfEmpty + s.SetFontPrompt[1], currentFont === defaultIfEmpty ? "" : currentFont);
      if (promptReturnValue !== null) {
        const newFont = promptReturnValue.length === 0 ? defaultIfEmpty : promptReturnValue;
        callback(newFont);
      }
    }
  };
  __name(ComponentBase, "ComponentBase");
  var ParametrizedComponentBase = class extends ComponentBase {
    constructor(parent, [instance, def], saved) {
      super(parent, instance, saved);
      this._defP = def;
    }
    makeChangeParamsContextMenuItem(icon, [caption, itemCaption], currentValue, fieldName, values) {
      const makeChangeValueItem = /* @__PURE__ */ __name((val) => {
        const isCurrent = currentValue === val;
        const icon2 = isCurrent ? "check" : "none";
        const action = isCurrent ? () => void 0 : () => {
          this.replaceWithNewParams({ [fieldName]: val });
        };
        return MenuData.item(icon2, itemCaption.expand({ val }), action);
      }, "makeChangeValueItem");
      if (values === void 0) {
        values = this._defP.paramDefs[fieldName].range;
      }
      return ["mid", MenuData.submenu(icon, caption, values.map(makeChangeValueItem))];
    }
    makeChangeBooleanParamsContextMenuItem(caption, currentValue, fieldName) {
      const icon = currentValue ? "check" : "none";
      return ["mid", MenuData.item(icon, caption, () => {
        this.replaceWithNewParams({ [fieldName]: !currentValue });
      })];
    }
    replaceWithNewParams(newParams) {
      const currentRepr = this.toNodelessJSON();
      const newRepr = __spreadValues(__spreadValues({}, currentRepr), newParams);
      const newComp = this._defP.makeFromJSON(this.parent, newRepr);
      if (newComp === void 0) {
        console.warn("Could not create component variant");
        return void 0;
      }
      return this.replaceWithComponent(newComp);
    }
    keyDown(e) {
      if (e.key === "+") {
        this.tryChangeParam(0, true);
      } else if (e.key === "-") {
        this.tryChangeParam(0, false);
      } else if (e.key === "*") {
        this.tryChangeParam(1, true);
      } else if (e.key === "/") {
        this.tryChangeParam(1, false);
      } else {
        super.keyDown(e);
      }
    }
    tryChangeParam(paramIndex, increase) {
      const params = Object.keys(this._defP.defaultParams);
      const numParams = params.length;
      if (paramIndex >= numParams) {
        return;
      }
      const paramName = params[paramIndex];
      let currentParamValue = this.toJSON()[paramName];
      const paramDef = this._defP.paramDefs[paramName];
      if (currentParamValue === void 0) {
        currentParamValue = paramDef.defaultValue;
      }
      let newParamValue;
      if (isNumber(currentParamValue)) {
        newParamValue = paramDef.nextValue(currentParamValue, increase);
        if (newParamValue === void 0 || newParamValue === currentParamValue) {
          return;
        }
      } else if (isBoolean(currentParamValue)) {
        newParamValue = !currentParamValue;
      }
      if (newParamValue === void 0) {
        return;
      }
      const newComp = this.replaceWithNewParams({ [paramName]: newParamValue });
      if (newComp !== void 0) {
        this.parent.editor.eventMgr.setCurrentMouseOverComp(newComp);
      }
    }
  };
  __name(ParametrizedComponentBase, "ParametrizedComponentBase");
  function group(orient, nodes) {
    return FixedArrayMap(nodes, ([x, y, name2, opts]) => [x, y, orient, name2, opts]);
  }
  __name(group, "group");
  function groupVertical(orient, x, yCenter, num, spacing, opts) {
    const spacing_ = spacing != null ? spacing : useCompact(num) ? 1 : 2;
    const span2 = (num - 1) * spacing_;
    const yTop = yCenter - span2 / 2;
    return group(
      orient,
      ArrayFillUsing((i2) => [x, yTop + i2 * spacing_, void 0, opts], num)
    );
  }
  __name(groupVertical, "groupVertical");
  function groupVerticalMulti(orient, x, yCenter, numOuter, numInner) {
    const innerSpacing = useCompact(numInner === 1 ? numOuter : numInner) ? 1 : 2;
    const groupSpacing = numInner === 1 ? innerSpacing : innerSpacing * 2;
    const groupOffset = (numInner - 1) * innerSpacing + groupSpacing;
    const span2 = numOuter * (numInner - 1) * innerSpacing + (numOuter - 1) * groupSpacing;
    const yTop = yCenter - span2 / 2;
    return ArrayFillUsing((g) => group(
      orient,
      ArrayFillUsing((i2) => [x, yTop + g * groupOffset + i2 * innerSpacing], numInner)
    ), numOuter);
  }
  __name(groupVerticalMulti, "groupVerticalMulti");
  function groupHorizontal(orient, xCenter, y, num, spacing, opts) {
    const spacing_ = spacing != null ? spacing : useCompact(num) ? 1 : 2;
    const span2 = (num - 1) * spacing_;
    const xRight = xCenter + span2 / 2;
    return group(
      orient,
      ArrayFillUsing((i2) => [xRight - i2 * spacing_, y, void 0, opts], num)
    );
  }
  __name(groupHorizontal, "groupHorizontal");
  function makeComponentRepr(type7, hasIn, hasOut, props) {
    return t5.intersection([t5.type(__spreadValues({
      type: t5.string
    }, props)), ComponentRepr(hasIn, hasOut)], type7);
  }
  __name(makeComponentRepr, "makeComponentRepr");
  var ComponentDef = class {
    constructor(type7, idPrefix, aults, size, _buttonProps, _initialValue, makeNodes, repr) {
      this.type = type7;
      this.idPrefix = idPrefix;
      this.aults = aults;
      this.size = size;
      this._buttonProps = _buttonProps;
      this._initialValue = _initialValue;
      this.impl = void 0;
      const nodes = makeNodes(size, aults);
      this.nodeRecs = nodes;
      const hasIn = "ins" in nodes;
      const hasOut = "outs" in nodes;
      this.repr = makeComponentRepr(type7, hasIn, hasOut, repr != null ? repr : {});
    }
    isValid() {
      return this.impl !== void 0;
    }
    initialValue(saved) {
      return this._initialValue(saved, this.aults);
    }
    button(visual, options) {
      return __spreadValues({
        type: this.type,
        visual,
        width: this._buttonProps.imgWidth
      }, options);
    }
    make(parent) {
      const comp = new this.impl(parent);
      parent.components.add(comp);
      return comp;
    }
    makeFromJSON(parent, data2) {
      var _a;
      const validated = validateJson(data2, this.repr, (_a = this.impl.name) != null ? _a : "component");
      if (validated === void 0) {
        return void 0;
      }
      const comp = new this.impl(parent, validated);
      parent.components.add(comp);
      return comp;
    }
  };
  __name(ComponentDef, "ComponentDef");
  function defineComponent(type7, { idPrefix, button: button2, repr, valueDefaults, size, makeNodes, initialValue }) {
    return new ComponentDef(type7, idPrefix, valueDefaults, size, button2, initialValue != null ? initialValue : () => void 0, makeNodes, repr);
  }
  __name(defineComponent, "defineComponent");
  function defineAbstractComponent(items) {
    return __spreadProps(__spreadValues({}, items), {
      aults: items.valueDefaults
    });
  }
  __name(defineAbstractComponent, "defineAbstractComponent");
  var ParamDef = class {
    constructor(defaultValue, range, isAllowed) {
      this.defaultValue = defaultValue;
      this.range = range;
      this.isAllowed = isAllowed;
    }
    validate(n, context) {
      if (this.isAllowed(n)) {
        return n;
      } else {
        console.warn(`Using default value ${this.defaultValue} for ${context} instead of invalid value ${n}; allowed values are: ${this.range.join(", ")}`);
        return this.defaultValue;
      }
    }
    nextValue(value, increase) {
      const i2 = this.range.indexOf(value);
      if (i2 === -1) {
        return this.defaultValue;
      }
      const j = i2 + (increase ? 1 : -1);
      if (j < 0 || j >= this.range.length) {
        return void 0;
      }
      return this.range[j];
    }
  };
  __name(ParamDef, "ParamDef");
  function param(defaultValue, range) {
    if (range === void 0) {
      return new ParamDef(defaultValue, [], () => true);
    }
    return new ParamDef(defaultValue, range, (val) => range.includes(val));
  }
  __name(param, "param");
  function paramBool() {
    return new ParamDef(false, [false, true], isBoolean);
  }
  __name(paramBool, "paramBool");
  function paramDefaults(defs) {
    return Object.fromEntries(Object.entries(defs).map(([k, v]) => [k, v.defaultValue]));
  }
  __name(paramDefaults, "paramDefaults");
  var ParametrizedComponentDef = class {
    constructor(type7, idPrefix, hasIn, hasOut, variantName, _buttonProps, repr, valueDefaults, paramDefs, size, _makeNodes, _initialValue, _validateParams) {
      this.type = type7;
      this.idPrefix = idPrefix;
      this.variantName = variantName;
      this._buttonProps = _buttonProps;
      this.paramDefs = paramDefs;
      this.size = size;
      this._makeNodes = _makeNodes;
      this._initialValue = _initialValue;
      this._validateParams = _validateParams;
      this.impl = void 0;
      this.defaultParams = paramDefaults(paramDefs);
      this.aults = __spreadValues(__spreadValues({}, valueDefaults), this.defaultParams);
      this.repr = makeComponentRepr(type7, hasIn, hasOut, repr != null ? repr : {});
    }
    isValid() {
      return this.impl !== void 0;
    }
    with(params) {
      const size = this.size(params);
      const nodes = this._makeNodes(__spreadValues(__spreadValues({}, size), params), this.aults);
      return [{
        type: this.type,
        idPrefix: this.idPrefix,
        size,
        nodeRecs: nodes,
        initialValue: (saved) => this._initialValue(saved, params),
        makeFromJSON: this.makeFromJSON.bind(this)
      }, this];
    }
    button(params, visual, options) {
      return __spreadValues({
        type: this.type,
        params: defParams(this, params),
        visual,
        width: this._buttonProps.imgWidth
      }, options);
    }
    make(parent, params) {
      const fullParams = params === void 0 ? this.defaultParams : mergeWhereDefined(this.defaultParams, params);
      const resolvedParams = this.doValidate(fullParams, void 0);
      const comp = new this.impl(parent, resolvedParams);
      parent.components.add(comp);
      return comp;
    }
    makeFromJSON(parent, data2) {
      var _a;
      const validated = validateJson(data2, this.repr, (_a = this.impl.name) != null ? _a : "component");
      if (validated === void 0) {
        return void 0;
      }
      const fullParams = mergeWhereDefined(this.defaultParams, validated);
      const resolvedParams = this.doValidate(fullParams, validated.type);
      const comp = new this.impl(parent, resolvedParams, validated);
      parent.components.add(comp);
      return comp;
    }
    doValidate(fullParams, jsonType) {
      var _a, _b;
      const className = (_b = (_a = this.impl) == null ? void 0 : _a.name) != null ? _b : "component";
      fullParams = Object.fromEntries(Object.entries(this.paramDefs).map(([paramName, paramDef]) => {
        var _a2;
        const paramValue = (_a2 = fullParams[paramName]) != null ? _a2 : paramDef.defaultValue;
        if (paramName === "type") {
          return [paramName, paramValue];
        } else {
          const validatedValue = paramDef.validate(paramValue, `${className}.${paramName}`);
          return [paramName, validatedValue];
        }
      }));
      return this._validateParams(fullParams, jsonType, this.paramDefs);
    }
  };
  __name(ParametrizedComponentDef, "ParametrizedComponentDef");
  function defineParametrizedComponent(type7, hasIn, hasOut, { variantName, idPrefix, button: button2, repr, valueDefaults, params, validateParams, size, makeNodes, initialValue }) {
    return new ParametrizedComponentDef(type7, idPrefix, hasIn, hasOut, variantName, button2, repr, valueDefaults, params, size, makeNodes, initialValue, validateParams != null ? validateParams : (params2) => params2);
  }
  __name(defineParametrizedComponent, "defineParametrizedComponent");
  function defParams(def, params) {
    return brand()({ def, params });
  }
  __name(defParams, "defParams");
  function defineAbstractParametrizedComponent(items) {
    return items;
  }
  __name(defineAbstractParametrizedComponent, "defineAbstractParametrizedComponent");

  // simulator/src/drawutils.ts
  var GRID_STEP = 10;
  var WIRE_WIDTH = 8;
  var WIRE_WIDTH_HALF_SQUARED = __pow(WIRE_WIDTH / 2, 2);
  var WAYPOINT_DIAMETER = 8;
  var WAYPOINT_HIT_RANGE = WAYPOINT_DIAMETER + 5;
  function pxToGrid(x) {
    return Math.round(x / GRID_STEP);
  }
  __name(pxToGrid, "pxToGrid");
  function clampZoom(zoom) {
    return Math.max(0.1, Math.min(10, zoom / 100));
  }
  __name(clampZoom, "clampZoom");
  function distSquared(x0, y0, x1, y1) {
    const dx = x1 - x0;
    const dy = y1 - y0;
    return dx * dx + dy * dy;
  }
  __name(distSquared, "distSquared");
  function inRect(centerX, centerY, width, height, pointX, pointY) {
    const w2 = width / 2;
    const h2 = height / 2;
    return pointX >= centerX - w2 && pointX < centerX + w2 && pointY >= centerY - h2 && pointY < centerY + h2;
  }
  __name(inRect, "inRect");
  var DrawingRect = class {
    constructor(comp, honorRotation) {
      this.width = comp.unrotatedWidth;
      this.height = comp.unrotatedHeight;
      const swapDims = honorRotation && Orientation.isVertical(comp.orient);
      if (swapDims) {
        [this.width, this.height] = [this.height, this.width];
      }
      this.top = comp.posY - this.height / 2;
      this.left = comp.posX - this.width / 2;
      this.bottom = this.top + this.height;
      this.right = this.left + this.width;
    }
    outline(g, margin = 0) {
      const path = g.createPath();
      path.rect(this.left - margin, this.top - margin, this.width + margin * 2, this.height + margin * 2);
      return path;
    }
  };
  __name(DrawingRect, "DrawingRect");
  var DrawZIndex = {
    Background: 0,
    Normal: 1,
    Overlay: 2
  };
  var COLOR_TRANSPARENT = "rgba(0,0,0,0)";
  var USER_COLORS = {
    COLOR_BACKGROUND: void 0
  };
  var COLOR_BACKGROUND;
  var COLOR_OFF_BACKGROUND;
  var COLOR_BACKGROUND_UNUSED_REGION;
  var COLOR_BACKGROUND_INVALID;
  var COLOR_BORDER;
  var COLOR_GRID_LINES;
  var COLOR_GRID_LINES_GUIDES;
  var COLOR_LABEL_OFF;
  var COLOR_LABEL_ON;
  var COLORCOMP_COMPONENT_BORDER;
  var COLOR_COMPONENT_BORDER;
  var COLOR_COMPONENT_INNER_LABELS;
  var COLOR_COMPONENT_ID;
  var COLOR_GROUP_SPAN;
  var COLOR_WIRE_BORDER;
  var COLOR_MOUSE_OVER;
  var COLOR_MOUSE_OVER_NORMAL;
  var COLOR_MOUSE_OVER_DANGER;
  var COLOR_NODE_MOUSE_OVER;
  var COLORCOMPS_FULL;
  var COLOR_FULL;
  var COLOR_FULL_ALT;
  var COLOR_DARK_RED;
  var COLORCOMPS_EMPTY;
  var COLOR_EMPTY;
  var COLOR_EMPTY_ALT;
  var COLOR_UNKNOWN;
  var COLOR_UNKNOWN_ALT;
  var COLOR_HIGH_IMPEDANCE;
  var COLOR_ANCHOR_IN;
  var COLOR_ANCHOR_OUT;
  var COLOR_ANCHOR_NEW;
  var COLOR_GATE_NAMES;
  var COLOR_LED_ON;
  var COLOR_WIRE;
  var COLOR_RECTANGLE_BACKGROUND;
  var COLOR_RECTANGLE_BORDER;
  var PATTERN_STRIPED_GRAY;
  var OPACITY_HIDDEN_ITEMS = 0.3;
  var _currentModeIsDark = false;
  doSetColors(_currentModeIsDark);
  function setDarkMode(darkMode, force) {
    if (force || darkMode !== _currentModeIsDark) {
      doSetColors(darkMode);
      for (const editor of LogicEditor.allConnectedEditors) {
        editor.wrapHandler(() => {
          editor.setDark(darkMode);
          editor.editTools.redrawMgr.requestRedraw({ why: "dark/light mode switch" });
        })();
      }
    }
  }
  __name(setDarkMode, "setDarkMode");
  function isDarkMode() {
    return _currentModeIsDark;
  }
  __name(isDarkMode, "isDarkMode");
  function doSetColors(darkMode) {
    var _a;
    if (!darkMode) {
      COLOR_BACKGROUND = ColorString2(255);
      COLOR_OFF_BACKGROUND = ColorString2(223);
      COLOR_BACKGROUND_INVALID = ColorString2([255, 187, 187]);
      COLOR_BACKGROUND_UNUSED_REGION = ColorString2(238);
      COLOR_BORDER = ColorString2(200);
      COLOR_GRID_LINES = ColorString2(240);
      COLOR_GRID_LINES_GUIDES = ColorString2(215);
      COLOR_LABEL_OFF = ColorString2(255);
      COLOR_LABEL_ON = ColorString2(0);
      COLORCOMP_COMPONENT_BORDER = 0;
      COLOR_COMPONENT_INNER_LABELS = ColorString2(170);
      COLOR_COMPONENT_ID = ColorString2([50, 50, 250]);
      COLOR_GROUP_SPAN = ColorString2([128, 128, 128, 0.13]);
      COLOR_WIRE_BORDER = ColorString2(80);
      COLOR_MOUSE_OVER_NORMAL = ColorString2([0, 123, 255]);
      COLOR_MOUSE_OVER_DANGER = ColorString2([194, 34, 14]);
      COLOR_NODE_MOUSE_OVER = ColorString2([128, 128, 128, 0.5]);
      COLORCOMPS_FULL = [255, 193, 7];
      COLOR_DARK_RED = ColorString2([180, 0, 0]);
      COLORCOMPS_EMPTY = [52, 58, 64];
      COLOR_UNKNOWN = ColorString2([152, 158, 164]);
      COLOR_HIGH_IMPEDANCE = ColorString2([137, 114, 35]);
      COLOR_GATE_NAMES = ColorString2([190, 190, 190]);
      COLOR_LED_ON = {
        green: ColorString2([20, 232, 20]),
        red: ColorString2([232, 20, 20]),
        yellow: ColorString2([232, 232, 20])
      };
      COLOR_WIRE = {
        black: COLOR_WIRE_BORDER,
        red: ColorString2([206, 63, 57]),
        blue: ColorString2([77, 102, 153]),
        yellow: ColorString2([245, 209, 63]),
        green: ColorString2([87, 136, 97]),
        white: ColorString2([230, 217, 199])
      };
      PATTERN_STRIPED_GRAY = createStripedPattern(COLOR_BACKGROUND, "rgba(128,128,128,0.2)");
    } else {
      COLOR_BACKGROUND = (_a = USER_COLORS.COLOR_BACKGROUND) != null ? _a : ColorString2(30);
      COLOR_OFF_BACKGROUND = ColorString2(60);
      COLOR_BACKGROUND_INVALID = ColorString2([168, 20, 20]);
      COLOR_BACKGROUND_UNUSED_REGION = ColorString2(55);
      COLOR_BORDER = ColorString2(85);
      COLOR_GRID_LINES = ColorString2(30);
      COLOR_GRID_LINES_GUIDES = ColorString2(45);
      COLOR_LABEL_OFF = ColorString2(185);
      COLOR_LABEL_ON = COLOR_BACKGROUND;
      COLORCOMP_COMPONENT_BORDER = 220;
      COLOR_COMPONENT_INNER_LABELS = ColorString2(139);
      COLOR_COMPONENT_ID = ColorString2([0, 0, 150]);
      COLOR_GROUP_SPAN = ColorString2([128, 128, 128, 0.13]);
      COLOR_WIRE_BORDER = ColorString2(175);
      COLOR_MOUSE_OVER_NORMAL = ColorString2([0, 123, 255]);
      COLOR_MOUSE_OVER_DANGER = ColorString2([194, 34, 14]);
      COLOR_NODE_MOUSE_OVER = ColorString2([128, 128, 128, 0.5]);
      COLORCOMPS_FULL = [255, 193, 7];
      COLOR_DARK_RED = ColorString2([180, 0, 0]);
      COLORCOMPS_EMPTY = [80, 89, 99];
      COLOR_UNKNOWN = ColorString2([108, 106, 98]);
      COLOR_HIGH_IMPEDANCE = ColorString2([103, 84, 23]);
      COLOR_GATE_NAMES = ColorString2([95, 95, 95]);
      COLOR_LED_ON = {
        green: ColorString2([11, 144, 11]),
        red: ColorString2([144, 11, 11]),
        yellow: ColorString2([144, 144, 11])
      };
      COLOR_WIRE = {
        black: COLOR_WIRE_BORDER,
        red: ColorString2([206, 63, 57]),
        // TODO update these colors below
        blue: ColorString2([77, 102, 153]),
        yellow: ColorString2([245, 209, 63]),
        green: ColorString2([87, 136, 97]),
        white: ColorString2([230, 217, 199])
      };
      PATTERN_STRIPED_GRAY = createStripedPattern(COLOR_BACKGROUND, "rgba(128,128,128,0.4)");
    }
    COLOR_RECTANGLE_BACKGROUND = {
      yellow: ColorString2([230, 230, 0, 0.2]),
      blue: ColorString2([54, 54, 255, 0.2]),
      green: ColorString2([54, 255, 54, 0.2]),
      red: ColorString2([255, 54, 54, 0.2]),
      grey: ColorString2([120, 120, 120, 0.2]),
      turquoise: ColorString2([0, 210, 210, 0.2])
    };
    COLOR_RECTANGLE_BORDER = {
      yellow: ColorString2([196, 196, 0, 0.5]),
      blue: ColorString2([115, 115, 255, 0.5]),
      green: ColorString2([0, 167, 0, 0.5]),
      red: ColorString2([214, 0, 0, 0.5]),
      grey: ColorString2([35, 35, 35, 0.5]),
      turquoise: ColorString2([0, 162, 162, 0.5])
    };
    COLOR_COMPONENT_BORDER = ColorString2(COLORCOMP_COMPONENT_BORDER);
    setColorMouseOverIsDanger(false);
    COLOR_FULL = ColorString2(COLORCOMPS_FULL);
    COLOR_EMPTY = ColorString2(COLORCOMPS_EMPTY);
    COLOR_FULL_ALT = ligherColor(COLOR_FULL, 40);
    COLOR_EMPTY_ALT = ligherColor(COLOR_EMPTY, 80);
    COLOR_UNKNOWN_ALT = ligherColor(COLOR_UNKNOWN, 50);
    COLOR_ANCHOR_IN = ColorString2([200, 100, 100, 0.5]);
    COLOR_ANCHOR_OUT = ColorString2([100, 100, 200, 0.5]);
    COLOR_ANCHOR_NEW = ColorString2([100, 100, 100, 0.5]);
    _currentModeIsDark = darkMode;
  }
  __name(doSetColors, "doSetColors");
  function createStripedPattern(background, stripeColor) {
    if (!InBrowser) {
      return null;
    }
    const canvas2 = document.createElement("canvas");
    const step = 4;
    canvas2.width = 2 * step;
    canvas2.height = 6 * step;
    const g = canvas2.getContext("2d");
    g.fillStyle = background;
    g.fillRect(0, 0, canvas2.width, canvas2.height);
    g.fillStyle = stripeColor;
    g.beginPath();
    g.moveTo(step, 0);
    g.lineTo(canvas2.width, 0);
    g.lineTo(0, canvas2.height);
    g.lineTo(0, 3 * step);
    g.closePath();
    g.moveTo(step, canvas2.height);
    g.lineTo(canvas2.width, canvas2.height);
    g.lineTo(canvas2.width, 3 * step);
    g.closePath();
    g.fill();
    const pattern = g.createPattern(canvas2, "repeat");
    if (pattern === null) {
      console.warn("Failed to create pattern");
    }
    return pattern;
  }
  __name(createStripedPattern, "createStripedPattern");
  function setColorMouseOverIsDanger(mouseOverIsDanger) {
    COLOR_MOUSE_OVER = mouseOverIsDanger ? COLOR_MOUSE_OVER_DANGER : COLOR_MOUSE_OVER_NORMAL;
  }
  __name(setColorMouseOverIsDanger, "setColorMouseOverIsDanger");
  function ColorString2(input2) {
    if (isArray(input2)) {
      if (input2.length === 3) {
        return `rgb(${input2[0]},${input2[1]},${input2[2]})`;
      }
      return `rgba(${input2[0]},${input2[1]},${input2[2]},${input2[3]})`;
    }
    return `rgb(${input2},${input2},${input2})`;
  }
  __name(ColorString2, "ColorString");
  function colorCompsRGB(c) {
    const PREFIX = "rgb(";
    if (c.startsWith(PREFIX)) {
      c = c.substring(PREFIX.length);
    }
    const SUFFIX = ")";
    if (c.endsWith(SUFFIX)) {
      c = c.substring(0, c.length - SUFFIX.length);
    }
    const comps = c.split(",").map((compStr) => parseInt(compStr));
    return FixedArrayAssert(comps, 3);
  }
  __name(colorCompsRGB, "colorCompsRGB");
  function ligherColor(col, offset2) {
    const components = colorCompsRGB(col);
    const newComponents = FixedArrayAssert(components.map((c) => Math.min(255, c + offset2)), 3);
    return ColorString2(newComponents);
  }
  __name(ligherColor, "ligherColor");
  function colorForLogicValue(value) {
    return isUnknown(value) ? COLOR_UNKNOWN : isHighImpedance(value) ? COLOR_HIGH_IMPEDANCE : value ? COLOR_FULL : COLOR_EMPTY;
  }
  __name(colorForLogicValue, "colorForLogicValue");
  function colorsForLogicValue(value) {
    return isUnknown(value) ? [COLOR_UNKNOWN, COLOR_UNKNOWN_ALT] : isHighImpedance(value) ? [
      COLOR_HIGH_IMPEDANCE,
      COLOR_HIGH_IMPEDANCE
      /* not alt because High-Z is not animated*/
    ] : value ? [COLOR_FULL, COLOR_FULL_ALT] : [COLOR_EMPTY, COLOR_EMPTY_ALT];
  }
  __name(colorsForLogicValue, "colorsForLogicValue");
  function colorForFraction(fraction) {
    const c = [
      (COLORCOMPS_FULL[0] - COLORCOMPS_EMPTY[0]) * fraction + COLORCOMPS_EMPTY[0],
      (COLORCOMPS_FULL[1] - COLORCOMPS_EMPTY[1]) * fraction + COLORCOMPS_EMPTY[1],
      (COLORCOMPS_FULL[2] - COLORCOMPS_EMPTY[2]) * fraction + COLORCOMPS_EMPTY[2]
    ];
    return ColorString2(c);
  }
  __name(colorForFraction, "colorForFraction");
  function parseColorToRGBA(col) {
    const canvas2 = document.createElement("canvas");
    canvas2.width = canvas2.height = 1;
    const ctx = canvas2.getContext("2d");
    ctx.clearRect(0, 0, 1, 1);
    ctx.fillStyle = "#000";
    ctx.fillStyle = col;
    const computed = ctx.fillStyle;
    ctx.fillStyle = "#fff";
    ctx.fillStyle = col;
    if (computed !== ctx.fillStyle) {
      return void 0;
    }
    ctx.fillRect(0, 0, 1, 1);
    return FixedArrayAssert([...ctx.getImageData(0, 0, 1, 1).data], 4);
  }
  __name(parseColorToRGBA, "parseColorToRGBA");
  var FONT_LABEL_DEFAULT = "18px sans-serif";
  var _cachedAscents = /* @__PURE__ */ new Map();
  function fontAscentHalf(g) {
    const font = g.font;
    let halfAscent = _cachedAscents.get(font);
    if (halfAscent === void 0) {
      halfAscent = Math.ceil(g.measureText("0").actualBoundingBoxAscent - 1) / 2;
      _cachedAscents.set(font, halfAscent);
    }
    return halfAscent;
  }
  __name(fontAscentHalf, "fontAscentHalf");
  var TextVAlign = {
    bottom: 0,
    middle: 1,
    top: 2
  };
  function strokeTextVAlign(g, valign, text, x, y) {
    g.strokeText(text, x, y + valign * fontAscentHalf(g));
  }
  __name(strokeTextVAlign, "strokeTextVAlign");
  function fillTextVAlign(g, valign, text, x, y) {
    g.fillText(text, x, y + valign * fontAscentHalf(g));
  }
  __name(fillTextVAlign, "fillTextVAlign");
  function useCompact(numNodes) {
    return numNodes >= 5;
  }
  __name(useCompact, "useCompact");
  var trivialNameMatcher = /^(In|Out|in|out)\d*$/;
  function isTrivialNodeName(name2) {
    return name2 === void 0 || trivialNameMatcher.test(name2);
  }
  __name(isTrivialNodeName, "isTrivialNodeName");
  function triangle(g, x0, y0, x1, y1, x2, y2) {
    g.moveTo(x0, y0);
    g.lineTo(x1, y1);
    g.lineTo(x2, y2);
    g.closePath();
  }
  __name(triangle, "triangle");
  function circle(g, cx, cy, d) {
    const r = d / 2;
    g.ellipse(cx, cy, r, r, 0, 0, 2 * Math.PI);
  }
  __name(circle, "circle");
  function strokeSingleLine(g, x0, y0, x1, y1) {
    g.beginPath();
    g.moveTo(x0, y0);
    g.lineTo(x1, y1);
    g.stroke();
  }
  __name(strokeSingleLine, "strokeSingleLine");
  function shouldDrawLeadsTo(nodes) {
    return nodes.map(whatToDrawForNode).some((x) => x.drawLead);
  }
  __name(shouldDrawLeadsTo, "shouldDrawLeadsTo");
  function whatToDrawForNode(node) {
    const editor = node.parent.editor;
    const wires = node.connectedWires;
    const connected = wires.length > 0;
    if (editor.mode <= 1 /* TRYOUT */ && !connected && !editor.options.showDisconnectedPins) {
      return { drawLabel: false, drawLead: false, drawTriangle: false, drawHiddenMark: false };
    }
    const drawHiddenMark = connected && wires.some((w) => w.isHidden);
    return { drawLabel: true, drawLead: !connected || drawHiddenMark, drawTriangle: node.hasTriangle, drawHiddenMark };
  }
  __name(whatToDrawForNode, "whatToDrawForNode");
  function shouldDrawNodeLabel(nodeOrArray) {
    if (isArray(nodeOrArray)) {
      return nodeOrArray.map(whatToDrawForNode).some((x) => x.drawLabel);
    }
    const node = nodeOrArray;
    return whatToDrawForNode(node).drawLabel;
  }
  __name(shouldDrawNodeLabel, "shouldDrawNodeLabel");
  function drawWireLineToComponent(g, node) {
    const { drawLead, drawTriangle, drawHiddenMark } = whatToDrawForNode(node);
    const [x1, y1, x0, y0] = node.drawCoordsInParentTransform;
    if (drawLead) {
      const neutral = node.parent.editor.options.hideWireColors;
      drawStraightWireLine(g, x0, y0, x1, y1, node.value, node.color, neutral, void 0);
    }
    if (drawTriangle) {
      g.strokeStyle = COLOR_COMPONENT_BORDER;
      g.fillStyle = COLOR_COMPONENT_BORDER;
      g.beginPath();
      if (x0 === x1) {
        const pointsDown = node.isOutput() && y1 <= y0 || !node.isOutput() && y0 <= y1;
        if (pointsDown) {
          const shift = node.isOutput() ? 1 : 0;
          triangle(
            g,
            x1 - 3,
            y1 - 2 + shift,
            x1 + 3,
            y1 - 2 + shift,
            x1,
            y1 + 1 + shift
          );
        } else {
          const shift = node.isOutput() ? -3 : -4;
          triangle(
            g,
            x1 - 3,
            y1 - 2 - shift,
            x1 + 3,
            y1 - 2 - shift,
            x1,
            y1 - 5 - shift
          );
        }
      } else if (y0 === y1) {
        const shift = node.isOutput() ? 1 : 0;
        const pointsRight = node.isOutput() && x1 <= x0 || !node.isOutput() && x0 <= x1;
        if (pointsRight) {
          triangle(
            g,
            x1 - 2 + shift,
            y1 - 3,
            x1 - 2 + shift,
            y1 + 3,
            x1 + 1 + shift,
            y1
          );
        } else {
          triangle(
            g,
            x1 + 2 - shift,
            y1 - 3,
            x1 + 2 - shift,
            y1 + 3,
            x1 - 1 - shift,
            y1
          );
        }
      } else {
        console.log(`ERROR  wireLineToComponent cannot draw triangle as line is not vertical or horizontal between (${x0}, ${y0}) and (${x1}, ${y1})`);
      }
      g.lineWidth = 2;
      g.fill();
      g.stroke();
    }
    if (drawHiddenMark) {
      g.lineWidth = 2;
      g.strokeStyle = COLOR_WIRE[node.color];
      g.beginPath();
      if (Orientation.isVertical(node.orient)) {
        g.moveTo(x0 + 5, y0 + 1.5);
        g.lineTo(x0 - 5, y0 - 1.5);
      } else {
        g.moveTo(x0 + 1.5, y0 - 5);
        g.lineTo(x0 - 1.5, y0 + 5);
      }
      g.stroke();
    }
  }
  __name(drawWireLineToComponent, "drawWireLineToComponent");
  function drawStraightWireLine(g, x0, y0, x1, y1, value, color, neutral, timeFraction) {
    g.beginPath();
    g.moveTo(x0, y0);
    g.lineTo(x1, y1);
    strokeWireOutlineAndSingleValue(g, value, color, neutral, timeFraction);
  }
  __name(drawStraightWireLine, "drawStraightWireLine");
  function strokeWireOutlineAndSingleValue(g, value, color, neutral, timeFraction) {
    strokeWireOutline(g, color, false);
    strokeWireValue(g, value, void 0, neutral, timeFraction);
  }
  __name(strokeWireOutlineAndSingleValue, "strokeWireOutlineAndSingleValue");
  function strokeWireOutline(g, color, isMouseOver) {
    const oldLineCap = g.lineCap;
    g.lineCap = "butt";
    const mainStrokeWidth = WIRE_WIDTH / 2;
    if (isMouseOver) {
      g.lineWidth = mainStrokeWidth + 2;
      g.strokeStyle = COLOR_MOUSE_OVER;
    } else {
      g.lineWidth = mainStrokeWidth;
      g.strokeStyle = COLOR_WIRE[color];
    }
    g.stroke();
    g.lineCap = oldLineCap;
  }
  __name(strokeWireOutline, "strokeWireOutline");
  function strokeWireValue(g, value, lengthToDrawAndTotal, neutral, timeFraction) {
    const oldLineCap = g.lineCap;
    g.lineCap = "butt";
    g.lineWidth = WIRE_WIDTH / 2 - 2;
    const [baseColor, altColor] = neutral ? [COLOR_UNKNOWN, COLOR_UNKNOWN_ALT] : colorsForLogicValue(value);
    g.strokeStyle = baseColor;
    const animationDashSize = 20;
    if (lengthToDrawAndTotal !== void 0) {
      const [lengthToDraw, totalLength] = lengthToDrawAndTotal;
      g.setLineDash([lengthToDraw, totalLength]);
      g.stroke();
      g.setLineDash([]);
    } else {
      if (timeFraction === void 0) {
        g.stroke();
      } else {
        g.setLineDash([animationDashSize, animationDashSize]);
        g.lineDashOffset = -timeFraction * animationDashSize * 2;
        g.stroke();
        g.strokeStyle = altColor;
        g.lineDashOffset += animationDashSize;
        g.stroke();
        g.lineDashOffset = 0;
        g.setLineDash([]);
      }
    }
    g.lineCap = oldLineCap;
  }
  __name(strokeWireValue, "strokeWireValue");
  function isOverWaypoint(x, y, waypointX, waypointY) {
    return distSquared(x, y, waypointX, waypointY) < __pow(WAYPOINT_HIT_RANGE / 2, 2);
  }
  __name(isOverWaypoint, "isOverWaypoint");
  function drawWaypoint(g, ctx, x, y, style2, value, isMouseOver, neutral, showForced, showForcedWarning, parentOrientIsVertical) {
    const [circleColor, thickness] = showForced ? [COLOR_DARK_RED, 3] : [COLOR_WIRE_BORDER, 1];
    g.strokeStyle = circleColor;
    g.lineWidth = thickness;
    g.fillStyle = style2 === 1 /* IN_DISCONNECTED */ ? COLOR_BACKGROUND : neutral ? COLOR_UNKNOWN : colorForLogicValue(value);
    g.beginPath();
    circle(g, x, y, WAYPOINT_DIAMETER);
    g.fill();
    g.stroke();
    if (isMouseOver) {
      g.fillStyle = COLOR_NODE_MOUSE_OVER;
      g.beginPath();
      circle(g, x, y, WAYPOINT_DIAMETER * 2);
      g.fill();
      g.stroke();
    }
    if (showForcedWarning) {
      g.textAlign = "center";
      g.fillStyle = circleColor;
      g.font = "bold 14px sans-serif";
      ctx.inNonTransformedFrame((ctx2) => {
        fillTextVAlign(g, TextVAlign.middle, "!!", ...ctx2.rotatePoint(
          x + (parentOrientIsVertical ? 13 : 0),
          y + (parentOrientIsVertical ? 0 : -13)
        ));
      });
    }
  }
  __name(drawWaypoint, "drawWaypoint");
  function drawClockInput(g, left2, clockNode, trigger) {
    const clockY = clockNode.posYInParentTransform;
    g.strokeStyle = COLOR_COMPONENT_BORDER;
    g.lineWidth = 2;
    g.beginPath();
    g.moveTo(left2 + 1, clockY - 4);
    g.lineTo(left2 + 9, clockY);
    g.lineTo(left2 + 1, clockY + 4);
    g.stroke();
    if (trigger === EdgeTrigger.falling) {
      g.fillStyle = COLOR_COMPONENT_BORDER;
      g.closePath();
      g.fill();
    }
    drawWireLineToComponent(g, clockNode);
  }
  __name(drawClockInput, "drawClockInput");
  function drawLabel(ctx, compOrient, text, anchor, x, y, referenceNode) {
    if (text === void 0) {
      return;
    }
    if (referenceNode === void 0) {
      if (!isNumber(x)) {
        referenceNode = x;
      } else if (!isNumber(y)) {
        referenceNode = y;
      }
    }
    let showLabel = true;
    if (referenceNode !== void 0) {
      showLabel = shouldDrawNodeLabel(referenceNode);
    }
    if (!showLabel) {
      return;
    }
    const [halign, valign, dx, dy] = (() => {
      if (anchor === void 0) {
        return ["center", TextVAlign.middle, 0, 0];
      }
      const rotatedAnchor = Orientation.add(compOrient, anchor);
      switch (rotatedAnchor) {
        case "e":
          return ["right", TextVAlign.middle, -3, 0];
        case "w":
          return ["left", TextVAlign.middle, 3, 0];
        case "n":
          return ["center", TextVAlign.top, 0, 4];
        case "s":
          return ["center", TextVAlign.bottom, 0, -4];
      }
    })();
    const xx = isNumber(x) ? x : (isNodeArray(x) ? x.group : x).posXInParentTransform;
    const yy = isNumber(y) ? y : (isNodeArray(y) ? y.group : y).posYInParentTransform;
    const [finalX, finalY] = ctx.rotatePoint(xx, yy);
    const g = ctx.g;
    g.textAlign = halign;
    fillTextVAlign(g, valign, text, finalX + dx, finalY + dy);
  }
  __name(drawLabel, "drawLabel");
  function drawValueTextCentered(g, value, comp, opts) {
    drawValueText(g, value, comp.posX, comp.posY, opts);
  }
  __name(drawValueTextCentered, "drawValueTextCentered");
  function drawValueText(g, value, x, y, opts) {
    var _a;
    let spec = "";
    let label2 = "";
    const small = (_a = opts == null ? void 0 : opts.small) != null ? _a : false;
    const fillStyle = opts == null ? void 0 : opts.fillStyle;
    const sizeStrBig = small ? "12" : "18";
    const sizeStrSmall = small ? "10" : "16";
    if (isUnknown(value)) {
      g.fillStyle = fillStyle != null ? fillStyle : COLOR_LABEL_OFF;
      spec = "bold " + sizeStrBig;
      label2 = "?";
    } else if (isHighImpedance(value)) {
      g.fillStyle = fillStyle != null ? fillStyle : COLOR_LABEL_OFF;
      spec = sizeStrSmall;
      label2 = "Z";
    } else if (value) {
      g.fillStyle = fillStyle != null ? fillStyle : COLOR_LABEL_ON;
      spec = "bold " + sizeStrBig;
      label2 = "1";
    } else {
      g.fillStyle = fillStyle != null ? fillStyle : COLOR_LABEL_OFF;
      spec = sizeStrBig;
      label2 = "0";
    }
    g.font = `${spec}px sans-serif`;
    g.textAlign = "center";
    fillTextVAlign(g, TextVAlign.middle, label2, x, y);
  }
  __name(drawValueText, "drawValueText");
  var INPUT_OUTPUT_DIAMETER = 26;
  var NAME_POSITION_SETTINGS = {
    right: ["start", TextVAlign.middle, 7],
    left: ["end", TextVAlign.middle, 9],
    top: ["center", TextVAlign.bottom, 5],
    bottom: ["center", TextVAlign.top, 5]
  };
  function textSettingsForName(onRight, orient) {
    if (onRight) {
      switch (orient) {
        case "e":
          return NAME_POSITION_SETTINGS.right;
        case "w":
          return NAME_POSITION_SETTINGS.left;
        case "n":
          return NAME_POSITION_SETTINGS.top;
        case "s":
          return NAME_POSITION_SETTINGS.bottom;
      }
    } else {
      switch (orient) {
        case "e":
          return NAME_POSITION_SETTINGS.left;
        case "w":
          return NAME_POSITION_SETTINGS.right;
        case "n":
          return NAME_POSITION_SETTINGS.bottom;
        case "s":
          return NAME_POSITION_SETTINGS.top;
      }
    }
  }
  __name(textSettingsForName, "textSettingsForName");
  function drawComponentName(g, ctx, name2, value, comp, onRight) {
    if (name2 === void 0) {
      return;
    }
    let displayName;
    if (isString(name2)) {
      displayName = name2;
    } else {
      if (value in name2) {
        displayName = `${name2[value]}`;
      } else if ("default" in name2) {
        displayName = `${name2.default}`;
      } else if (isUnknown(value)) {
        displayName = Unknown;
      } else {
        displayName = void 0;
      }
    }
    if (displayName === void 0) {
      return;
    }
    const [hAlign, vAlign, deltaX] = textSettingsForName(onRight, comp.orient);
    g.fillStyle = COLOR_COMPONENT_BORDER;
    g.font = "italic 18px sans-serif";
    const point = ctx.rotatePoint(comp.posX + (onRight ? 1 : -1) * (comp.unrotatedWidth / 2 + deltaX), comp.posY);
    g.textAlign = hAlign;
    fillTextVAlign(g, vAlign, displayName, ...point);
  }
  __name(drawComponentName, "drawComponentName");
  function drawAnchorsAroundComponent(g, comp, includeTo) {
    const anchor = comp.anchor;
    if (anchor !== void 0) {
      const color = includeTo ? COLOR_ANCHOR_IN : COLOR_ANCHOR_NEW;
      drawAnchorTo(g, comp.posX, comp.posY, anchor.posX, anchor.posY, [anchor.width, anchor.height], color, void 0);
    }
    if (includeTo) {
      drawAllTo(comp);
    }
    function drawAllTo(drawable) {
      if (!(drawable instanceof ComponentBase)) {
        return;
      }
      for (const anchoredComp of drawable.anchoredDrawables) {
        if (anchoredComp instanceof Waypoint) {
          continue;
        }
        drawAnchorTo(g, anchoredComp.posX, anchoredComp.posY, drawable.posX, drawable.posY, [drawable.width, drawable.height], COLOR_ANCHOR_OUT, comp);
        drawAllTo(anchoredComp);
      }
    }
    __name(drawAllTo, "drawAllTo");
  }
  __name(drawAnchorsAroundComponent, "drawAnchorsAroundComponent");
  function drawAnchorTo(g, sX, sY, tX, tY, distOrDim, color, whileDraggingComp) {
    const ds = 0;
    const wl = 3;
    const wh = 8;
    const h = 20;
    const [dt, [tWidth, tHeight]] = isNumber(distOrDim) ? [distOrDim, [0, 0]] : [10, distOrDim];
    if (Math.abs(sX - tX) < tWidth / 2 && Math.abs(sY - tY) < tHeight / 2) {
      return;
    }
    if (whileDraggingComp !== void 0) {
      const c = whileDraggingComp;
      if (sX >= c.posX - c.width / 2 && sX <= c.posX + c.width / 2 && sY >= c.posY - c.height / 2 && sY <= c.posY + c.height / 2) {
        return;
      }
    }
    let dirX = tX - sX;
    let dirY = tY - sY;
    const magn = Math.sqrt(dirX * dirX + dirY * dirY);
    if (magn < 20) {
      return;
    }
    dirX /= magn;
    dirY /= magn;
    const perpX = -dirY;
    const perpY = dirX;
    sX += ds * dirX;
    sY += ds * dirY;
    const st = [sX + wl * perpX, sY + wl * perpY];
    const sb = [sX - wl * perpX, sY - wl * perpY];
    tX -= dt * dirX;
    tY -= dt * dirY;
    const th2 = [tX, tY];
    tX -= h * dirX;
    tY -= h * dirY;
    const mt = [tX + wl * perpX, tY + wl * perpY];
    const at = [tX + wh * perpX, tY + wh * perpY];
    const mb = [tX - wl * perpX, tY - wl * perpY];
    const ab = [tX - wh * perpX, tY - wh * perpY];
    g.fillStyle = color;
    g.beginPath();
    g.moveTo(st[0], st[1]);
    g.lineTo(mt[0], mt[1]);
    g.lineTo(at[0], at[1]);
    g.lineTo(th2[0], th2[1]);
    g.lineTo(ab[0], ab[1]);
    g.lineTo(mb[0], mb[1]);
    g.lineTo(sb[0], sb[1]);
    g.closePath();
    g.fill();
  }
  __name(drawAnchorTo, "drawAnchorTo");
  function bezierPoint(t38, coords) {
    const u = 1 - t38;
    const f1 = __pow(u, 3);
    const f2 = 3 * __pow(u, 2) * t38;
    const f3 = 3 * u * __pow(t38, 2);
    const f4 = __pow(t38, 3);
    const x = f1 * coords[0] + f2 * coords[4] + f3 * coords[6] + f4 * coords[2];
    const y = f1 * coords[1] + f2 * coords[5] + f3 * coords[7] + f4 * coords[3];
    return [x, y];
  }
  __name(bezierPoint, "bezierPoint");
  function bezierExtrema(coords, forY) {
    const di = Number(forY);
    const start2 = coords[0 + di];
    const end2 = coords[2 + di];
    const c1 = coords[4 + di];
    const c2 = coords[6 + di];
    const a2 = -3 * start2 + 9 * c1 - 9 * c2 + 3 * end2;
    const b2 = 6 * start2 - 12 * c1 + 6 * c2;
    const c = -3 * start2 + 3 * c1;
    const roots = [];
    let r;
    if (Math.abs(a2) < 1e-6) {
      if (Math.abs(b2) > 1e-6 && (r = -c / b2) > 0 && r < 1) {
        roots.push(r);
      }
    } else {
      const discriminant = __pow(b2, 2) - 4 * a2 * c;
      if (discriminant >= 0) {
        const sqrtD = Math.sqrt(discriminant);
        r = (-b2 - sqrtD) / (2 * a2);
        if (r > 0 && r < 1) {
          roots.push(r);
        }
        r = (-b2 + sqrtD) / (2 * a2);
        if (r > 0 && r < 1) {
          roots.push(r);
        }
      }
    }
    return roots;
  }
  __name(bezierExtrema, "bezierExtrema");
  function bezierBoundingBox(coords, margin) {
    const xExtrema = bezierExtrema(coords, false);
    const yExtrema = bezierExtrema(coords, true);
    const ts = [0, 1, ...xExtrema, ...yExtrema];
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    for (const t38 of ts) {
      const [x, y] = bezierPoint(t38, coords);
      minX = Math.min(minX, x);
      maxX = Math.max(maxX, x);
      minY = Math.min(minY, y);
      maxY = Math.max(maxY, y);
    }
    return [minX - margin, minY - margin, maxX + margin, maxY + margin];
  }
  __name(bezierBoundingBox, "bezierBoundingBox");
  function isPointOnStraightWire(x, y, coords) {
    const [x1, y1, x2, y2] = coords;
    const length2 = __pow(x2 - x1, 2) + __pow(y2 - y1, 2);
    if (length2 === 0) {
      return x === x1 && y === y1;
    }
    const t38 = ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / length2;
    if (t38 < 0 || t38 > 1) {
      return false;
    }
    const closestX = x1 + t38 * (x2 - x1);
    const closestY = y1 + t38 * (y2 - y1);
    const dist2 = __pow(x - closestX, 2) + __pow(y - closestY, 2);
    return dist2 <= WIRE_WIDTH_HALF_SQUARED;
  }
  __name(isPointOnStraightWire, "isPointOnStraightWire");
  function makeBezierCoords(coords) {
    const [startX, startY, endX, endY] = coords;
    const endpointDist = Math.sqrt(__pow(endX - startX, 2) + __pow(endY - startY, 2));
    const numPoints = Math.max(3, Math.ceil(endpointDist / WIRE_WIDTH * 1.25));
    const tStepSize = 1 / numPoints;
    const boundingBox = bezierBoundingBox(coords, WIRE_WIDTH / 2);
    const bezierMEta = { tStepSize, boundingBox };
    return [...coords, bezierMEta];
  }
  __name(makeBezierCoords, "makeBezierCoords");
  function isPointOnBezierWire(x, y, coords) {
    const bezierMeta = coords[8];
    const [left2, top2, right2, bottom2] = bezierMeta.boundingBox;
    if (x < left2 || x > right2 || y < top2 || y > bottom2) {
      return false;
    }
    const stepSize = bezierMeta.tStepSize;
    for (let t38 = 0; t38 <= 1; t38 += stepSize) {
      const [wx, wy] = bezierPoint(t38, coords);
      const dist2 = __pow(wx - x, 2) + __pow(wy - y, 2);
      if (dist2 <= WIRE_WIDTH_HALF_SQUARED) {
        return true;
      }
    }
    return false;
  }
  __name(isPointOnBezierWire, "isPointOnBezierWire");
  function displayValuesFromArray(values, mostSignificantFirst) {
    let binaryStringRep = "";
    let hasUnset = false;
    const add = mostSignificantFirst ? (v) => binaryStringRep = binaryStringRep + v : (v) => binaryStringRep = v + binaryStringRep;
    for (const value2 of values) {
      if (isUnknown(value2) || isHighImpedance(value2)) {
        hasUnset = true;
        add(value2);
      } else {
        add(+value2);
      }
    }
    const value = hasUnset ? Unknown : parseInt(binaryStringRep, 2);
    return [binaryStringRep, value];
  }
  __name(displayValuesFromArray, "displayValuesFromArray");
  function formatWithRadix(value, radix, numBits, withPrefix = true) {
    if (isUnknown(value)) {
      return Unknown;
    }
    if (radix === -10) {
      const asBinStr = (value >>> 0).toString(2).padStart(numBits, "0");
      if (asBinStr[0] === "1") {
        const rest = parseInt(asBinStr.substring(1), 2);
        return "\u2013" + String(-(-Math.pow(2, numBits - 1) + rest));
      } else {
        return String(value);
      }
    } else {
      const padWidth = radix === 10 ? 1 : Math.ceil(Math.log(Math.pow(2, numBits)) / Math.log(radix));
      const caption = value.toString(radix).toUpperCase().padStart(padWidth, "0");
      const prefix = !withPrefix ? "" : (() => {
        switch (radix) {
          case 16:
            return "0x";
          case 8:
            return "0o";
          case 2:
            return "0b";
          default:
            return "";
        }
      })();
      return prefix + caption;
    }
  }
  __name(formatWithRadix, "formatWithRadix");

  // simulator/src/components/Passthrough.ts
  var t6 = __toESM(require_lib());
  var Slant = {
    none: "none",
    up: "up",
    down: "down"
  };
  var PassthroughDef = defineParametrizedComponent("pass", true, true, {
    variantName: ({ bits }) => `pass-${bits}`,
    idPrefix: "pass",
    button: { imgWidth: 32 },
    repr: {
      bits: typeOrUndefined(t6.number),
      slant: typeOrUndefined(t6.keyof(Slant))
    },
    valueDefaults: {
      slant: Slant.none
    },
    params: {
      bits: param(1, [1, 2, 3, 4, 8, 16])
    },
    validateParams: ({ bits }) => ({
      numBits: bits
    }),
    size: ({ numBits }) => ({
      gridWidth: 2,
      gridHeight: useCompact(numBits) ? numBits : 2 * numBits
    }),
    makeNodes: ({ numBits }) => ({
      ins: {
        In: groupVertical("w", -1, 0, numBits, void 0, { leadLength: 10 })
      },
      outs: {
        Out: groupVertical("e", 1, 0, numBits, void 0, { leadLength: 10 })
      }
    }),
    initialValue: (saved, { numBits }) => ArrayFillWith(false, numBits)
  });
  var Passthrough = class extends ParametrizedComponentBase {
    constructor(parent, params, saved) {
      var _a;
      super(parent, PassthroughDef.with(params), saved);
      this.numBits = params.numBits;
      this._hShift = [0, 0];
      this._slant = (_a = saved == null ? void 0 : saved.slant) != null ? _a : PassthroughDef.aults.slant;
      this.updateNodeOffsets();
    }
    toJSON() {
      return __spreadProps(__spreadValues({}, this.toJSONBase()), {
        bits: this.numBits === PassthroughDef.aults.bits ? void 0 : this.numBits,
        slant: this._slant === PassthroughDef.aults.slant ? void 0 : this._slant
      });
    }
    destroy() {
      var _a;
      const savedWireEnds = [];
      for (let i2 = 0; i2 < this.numBits; i2++) {
        const nodeOut = (_a = this.inputs.In[i2].incomingWire) == null ? void 0 : _a.startNode;
        if (nodeOut === void 0 || !(nodeOut instanceof NodeOut)) {
          continue;
        }
        const nodeIns = [];
        for (const wire of this.outputs.Out[i2].outgoingWires) {
          const endNode = wire.endNode;
          if (endNode !== null) {
            nodeIns.push([endNode, wire.style]);
          }
        }
        if (nodeIns.length > 0) {
          savedWireEnds.push([nodeOut, nodeIns]);
        }
      }
      super.destroy();
      if (savedWireEnds.length > 0) {
        const linkMgr = this.parent.linkMgr;
        for (const [nodeOut, nodeIns] of savedWireEnds) {
          for (const [nodeIn, style2] of nodeIns) {
            const wire = linkMgr.addWire(nodeOut, nodeIn, false);
            if (wire === void 0) {
              console.error("Failed to add wire back");
              continue;
            }
            if (style2 !== void 0) {
              wire.doSetStyle(style2);
            }
          }
        }
      }
    }
    get alwaysDrawMultiOutNodes() {
      return true;
    }
    doRecalcValue() {
      return this.inputValues(this.inputs.In);
    }
    propagateValue(newValue) {
      this.outputValues(this.outputs.Out, newValue);
    }
    isOver(x, y) {
      if (this._slant === Slant.none) {
        return super.isOver(x, y);
      }
      let yPosWithNoHOffset = 0;
      let f = 0;
      switch (this._slant) {
        case Slant.up:
          yPosWithNoHOffset = this.inputs.In[0].posY;
          f = -1;
          break;
        case Slant.down:
          yPosWithNoHOffset = this.inputs.In[this.numBits - 1].posY;
          f = 1;
          break;
      }
      const deltaX = (y - yPosWithNoHOffset) * f;
      return super.isOver(x + deltaX, y);
    }
    makeTooltip() {
      return tooltipContent(void 0, mods(
        div(S.Components.Passthrough.tooltip)
      ));
    }
    doDraw(g, ctx) {
      const width = 3;
      const height = this.unrotatedHeight;
      const top2 = this.posY - height / 2;
      const bottom2 = top2 + height;
      const mouseoverMargin = 4;
      const [topShift, bottomShift] = this._hShift;
      for (const input2 of this.inputs._all) {
        drawWireLineToComponent(g, input2);
      }
      for (const output of this.outputs._all) {
        drawWireLineToComponent(g, output);
      }
      g.beginPath();
      g.moveTo(this.posX + topShift, top2);
      g.lineTo(this.posX + bottomShift, bottom2);
      if (ctx.isMouseOver) {
        g.lineWidth = width + mouseoverMargin * 2;
        g.strokeStyle = COLOR_NODE_MOUSE_OVER;
        g.stroke();
        g.strokeStyle = COLOR_COMPONENT_BORDER;
      } else {
        g.strokeStyle = COLOR_UNKNOWN;
      }
      if (this.parent.mode >= 2 /* CONNECT */) {
        g.lineWidth = width;
        g.stroke();
      }
    }
    makeComponentSpecificContextMenuItems() {
      if (this.numBits === 1) {
        return [];
      }
      const s = S.Components.Passthrough.contextMenu;
      const makeItemSetSlant = /* @__PURE__ */ __name((desc, slant) => {
        const isCurrent = this._slant === slant;
        const icon = isCurrent ? "check" : "none";
        const action = isCurrent ? () => void 0 : () => this.doSetSlant(slant);
        return MenuData.item(icon, desc, action);
      }, "makeItemSetSlant");
      return [
        ["mid", MenuData.submenu("slanted", s.Slant, [
          makeItemSetSlant(s.SlantNone, Slant.none),
          MenuData.sep(),
          makeItemSetSlant(s.SlantRight, Slant.down),
          makeItemSetSlant(s.SlantLeft, Slant.up)
        ])],
        ["mid", MenuData.sep()],
        this.makeChangeParamsContextMenuItem("inputs", S.Components.Generic.contextMenu.ParamNumBits, this.numBits, "bits")
      ];
    }
    doSetSlant(slant) {
      this._slant = slant;
      this.updateNodeOffsets();
      this.requestRedraw({ why: "slant changed", invalidateMask: true });
    }
    updateNodeOffsets() {
      const n = this.numBits;
      switch (this._slant) {
        case "none":
          for (let i2 = 0; i2 < n; i2++) {
            this.inputs.In[i2].gridOffsetX = -1;
            this.outputs.Out[i2].gridOffsetX = 1;
          }
          this._hShift = [0, 0];
          break;
        case "down": {
          const f = n > 4 ? 1 : 2;
          for (let i2 = 0; i2 < n; i2++) {
            const shift = f * (n - 1 - i2);
            this.inputs.In[i2].gridOffsetX = -1 + shift;
            this.outputs.Out[i2].gridOffsetX = 1 + shift;
          }
          this._hShift = [f * (n - 0.5) * GRID_STEP, -f * GRID_STEP / 2];
          break;
        }
        case "up": {
          const f = n > 4 ? 1 : 2;
          for (let i2 = 0; i2 < n; i2++) {
            const shift = f * i2;
            this.inputs.In[i2].gridOffsetX = -1 + shift;
            this.outputs.Out[i2].gridOffsetX = 1 + shift;
          }
          this._hShift = [-f * GRID_STEP / 2, f * (n - 0.5) * GRID_STEP];
          break;
        }
      }
    }
  };
  __name(Passthrough, "Passthrough");
  PassthroughDef.impl = Passthrough;

  // simulator/src/components/WirePath.ts
  var WirePath = class {
    constructor(parts) {
      this.parts = parts;
      this._length = void 0;
    }
    get length() {
      if (this._length === void 0) {
        const helperElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
        helperElement.setAttributeNS(null, "d", buildPathDesc(this.parts));
        this._length = helperElement.getTotalLength();
      }
      return this._length;
    }
    draw(g) {
      g.beginPath();
      const start2 = this.parts[0];
      g.moveTo(start2[0], start2[1]);
      for (const part of this.parts) {
        if (part.length === 4) {
          g.lineTo(part[2], part[3]);
        } else {
          g.bezierCurveTo(part[4], part[5], part[6], part[7], part[2], part[3]);
        }
      }
    }
    drawBezierDebug(g) {
      g.strokeStyle = "red";
      g.lineWidth = 1;
      for (const part of this.parts) {
        if (part.length === 4) {
          continue;
        }
        const bezierMeta = part[8];
        const [left2, top2, right2, bottom2] = bezierMeta.boundingBox;
        g.strokeRect(left2, top2, right2 - left2, bottom2 - top2);
        const stepSize = bezierMeta.tStepSize;
        for (let t38 = 0; t38 <= 1; t38 += stepSize) {
          const [x, y] = bezierPoint(t38, part);
          g.beginPath();
          circle(g, x, y, WIRE_WIDTH);
          g.stroke();
        }
      }
    }
    isOver(x, y) {
      return this.partIndexIfMouseover(x, y) !== void 0;
    }
    partIndexIfMouseover(x, y) {
      for (let i2 = 0; i2 < this.parts.length - 1; i2++) {
        const part = this.parts[i2];
        if (part.length === 4) {
          if (isPointOnStraightWire(x, y, part)) {
            return i2;
          }
        } else {
          if (isPointOnBezierWire(x, y, part)) {
            return i2;
          }
        }
      }
      return void 0;
    }
  };
  __name(WirePath, "WirePath");
  function buildPathDesc(parts) {
    const start2 = parts[0];
    const pathDescParts = [`M${start2[0]} ${start2[1]}`];
    for (const part of parts) {
      if (part.length === 4) {
        pathDescParts.push(`L${part[2]} ${part[3]}`);
      } else {
        pathDescParts.push(`C${part[4]} ${part[5]},${part[6]} ${part[7]},${part[2]} ${part[3]}`);
      }
    }
    return pathDescParts.join(" ");
  }
  __name(buildPathDesc, "buildPathDesc");

  // simulator/src/components/Wire.ts
  var Waypoint = class extends DrawableWithDraggablePosition {
    constructor(wire, saved) {
      super(wire.parent, Waypoint.toSuperRepr(saved));
      this.wire = wire;
    }
    static get Repr() {
      return t7.union([
        // alternatives with more fields first
        t7.tuple([t7.number, t7.number, t7.keyof(Orientations_), typeOrNull(t7.string), t7.partial({
          lockPos: t7.boolean
        })]),
        t7.tuple([t7.number, t7.number, t7.keyof(Orientations_), t7.string]),
        t7.tuple([t7.number, t7.number, t7.keyof(Orientations_)]),
        t7.tuple([t7.number, t7.number])
      ], "Wire");
    }
    static toSuperRepr(saved) {
      if (saved === void 0) {
        return void 0;
      }
      const [posX, posY, orient, anchor, options] = saved;
      return {
        pos: [posX, posY],
        anchor: anchor === null ? void 0 : anchor,
        lockPos: options == null ? void 0 : options.lockPos,
        orient,
        ref: void 0
      };
    }
    toJSON() {
      var _a;
      const anchor = (_a = this.anchor) == null ? void 0 : _a.ref;
      if (this.lockPos) {
        return [this.posX, this.posY, this.orient, anchor != null ? anchor : null, {
          lockPos: this.lockPos
        }];
      }
      if (anchor !== void 0) {
        return [this.posX, this.posY, this.orient, anchor];
      }
      if (this.orient !== Orientation.default) {
        return [this.posX, this.posY, this.orient];
      }
      return [this.posX, this.posY];
    }
    doSetOrient(newOrient) {
      super.doSetOrient(newOrient);
      this.wire.invalidateWirePath();
    }
    get unrotatedWidth() {
      return WAYPOINT_DIAMETER;
    }
    get unrotatedHeight() {
      return WAYPOINT_DIAMETER;
    }
    isOver(x, y) {
      return this.parent.mode >= 2 /* CONNECT */ && isOverWaypoint(x, y, this.posX, this.posY);
    }
    positionChanged(__delta) {
      this.wire.invalidateWirePath();
    }
    cursorWhenMouseover(e) {
      var _a;
      const mode = this.parent.mode;
      if (((_a = e == null ? void 0 : e.ctrlKey) != null ? _a : false) && mode >= 2 /* CONNECT */) {
        return "context-menu";
      }
      if (!this.lockPos && mode >= 2 /* CONNECT */) {
        return "grab";
      }
      return void 0;
    }
    getPrevAndNextAnchors() {
      var _a;
      const waypoints = this.wire.waypoints;
      const index = waypoints.indexOf(this);
      const prev = index > 0 ? waypoints[index - 1] : this.wire.startNode;
      const next = index < waypoints.length - 1 ? waypoints[index + 1] : (_a = this.wire.endNode) != null ? _a : this.wire.startNode;
      return [prev, next];
    }
    removeFromParent() {
      this.wire.removeWaypoint(this);
    }
    doDraw(g, ctx) {
      if (this.parent.mode < 2 /* CONNECT */) {
        return;
      }
      if (this.wire.behavesHidden) {
        return;
      }
      g.globalAlpha = this.wire.isHidden ? OPACITY_HIDDEN_ITEMS : 1;
      const neutral = this.parent.editor.options.hideWireColors;
      drawWaypoint(g, ctx, this.posX, this.posY, 5 /* WAYPOINT */, this.wire.startNode.value, ctx.isMouseOver, neutral, false, false, false);
      g.globalAlpha = 1;
    }
    makeContextMenu() {
      return [
        ...this.makeOrientationAndPosMenuItems().map((it) => it[1]),
        MenuData.sep(),
        MenuData.item("trash", S.Components.Generic.contextMenu.Delete, () => {
          this.removeFromParent();
        }, "\u232B", true)
      ];
    }
  };
  __name(Waypoint, "Waypoint");
  var WireStyles = {
    auto: "auto",
    straight: "straight",
    hv: "hv",
    vh: "vh",
    bezier: "bezier"
  };
  var Wire = class extends Drawable {
    constructor(startNode, endNode) {
      const parent = startNode.parent;
      super(parent);
      this._waypoints = [];
      this._wirePath = void 0;
      this._style = void 0;
      this._isHidden = false;
      this._propagatingValues = [];
      this._waypointBeingDragged = void 0;
      this.customPropagationDelay = void 0;
      this.ribbon = void 0;
      this._startNode = startNode;
      this._endNode = endNode;
      const longAgo = Number.MIN_SAFE_INTEGER / 2;
      this._propagatingValues.push([startNode.value, longAgo]);
      this.setStartNode(startNode);
      this.setEndNode(endNode);
    }
    static get Repr() {
      const simpleRepr = t7.tuple([t7.number, t7.number]);
      const fullRepr = t7.tuple([
        t7.number,
        t7.number,
        // include an object specifying additional properties
        t7.type({
          ref: typeOrUndefined(t7.string),
          via: typeOrUndefined(t7.array(Waypoint.Repr)),
          propagationDelay: typeOrUndefined(t7.number),
          style: typeOrUndefined(t7.keyof(WireStyles)),
          hidden: typeOrUndefined(t7.boolean)
        })
      ]);
      return t7.union([fullRepr, simpleRepr], "Wire");
    }
    // called immediately after construction by Serialization
    setOptions(wireOptions, componentsByRef) {
      this.doSetValidatedId(wireOptions.ref);
      if (wireOptions.via !== void 0) {
        this.setWaypoints(wireOptions.via, componentsByRef);
      }
      if (wireOptions.propagationDelay !== void 0) {
        this.customPropagationDelay = wireOptions.propagationDelay;
      }
      if (wireOptions.style !== void 0) {
        this.doSetStyle(wireOptions.style);
      }
      if (wireOptions.hidden !== void 0) {
        this.doSetHidden(wireOptions.hidden);
      }
    }
    toJSON() {
      const endID = this._endNode.id;
      if (this._waypoints.length === 0 && this.customPropagationDelay === void 0 && this.ref === void 0 && this.style === void 0 && !this.isHidden) {
        return [this._startNode.id, endID];
      } else {
        const waypoints = this._waypoints.map((w) => w.toJSON());
        return [this._startNode.id, endID, {
          ref: this.ref,
          via: waypoints.length === 0 ? void 0 : waypoints,
          propagationDelay: this.customPropagationDelay,
          style: this.style,
          hidden: this.isHidden === false ? void 0 : this.isHidden
        }];
      }
    }
    get startNode() {
      return this._startNode;
    }
    get endNode() {
      return this._endNode;
    }
    isInRect(__rect) {
      return false;
    }
    get waypoints() {
      return this._waypoints;
    }
    setWaypoints(reprs, componentsByRef) {
      this._waypoints = reprs.map((repr) => {
        const wp = new Waypoint(this, repr);
        const anchorRef = repr[3];
        if (isString(anchorRef)) {
          const anchor = componentsByRef[anchorRef];
          if (anchor !== void 0) {
            wp.anchor = anchor;
          } else {
            console.warn(`Couldn't find anchor '${anchorRef}' for waypoint of wire between ${this._startNode.component.ref} and ${this._endNode.component.ref}`);
          }
        }
        return wp;
      });
    }
    get wirePath() {
      var _a;
      if (this._wirePath === void 0) {
        let [startX, startY, prevX, prevY, prevProlong] = this.startNode.drawCoords;
        const [endLeadX, endLeadY, endNodeX, endNodeY, endNodeProlong] = this.endNode.drawCoords;
        const lastWaypointData = { posX: endNodeX, posY: endNodeY, orient: endNodeProlong };
        const allWaypoints = [...this._waypoints, lastWaypointData];
        const pathParts = [[startX, startY, prevX, prevY]];
        const wireStyle = (_a = this.style) != null ? _a : this.startNode.parent.editor.options.wireStyle;
        for (const waypoint of allWaypoints) {
          const nextX = waypoint.posX;
          const nextY = waypoint.posY;
          const deltaX = nextX - prevX;
          const deltaY = nextY - prevY;
          const nextProlong = waypoint.orient;
          let c1x, c1y, c2x, c2y;
          if (wireStyle === WireStyles.straight || wireStyle === WireStyles.auto && (prevX === nextX || prevY === nextY)) {
            pathParts.push([prevX, prevY, nextX, nextY]);
          } else if (wireStyle === WireStyles.hv) {
            if (prevX !== nextX) {
              pathParts.push([prevX, prevY, nextX, prevY]);
            }
            if (prevY !== nextY) {
              pathParts.push([nextX, prevY, nextX, nextY]);
            }
          } else if (wireStyle === WireStyles.vh) {
            if (prevY !== nextY) {
              pathParts.push([prevX, prevY, prevX, nextY]);
            }
            if (prevX !== nextX) {
              pathParts.push([prevX, nextY, nextX, nextY]);
            }
          } else {
            const bezierAnchorPointDistX = Math.max(25, Math.abs(deltaX) / 3);
            const bezierAnchorPointDistY = Math.max(25, Math.abs(deltaY) / 3);
            [c1x, c1y] = bezierAnchorForWire(prevProlong, prevX, prevY, bezierAnchorPointDistX, bezierAnchorPointDistY);
            [c2x, c2y] = bezierAnchorForWire(nextProlong, nextX, nextY, bezierAnchorPointDistX, bezierAnchorPointDistY);
            pathParts.push(makeBezierCoords([prevX, prevY, nextX, nextY, c1x, c1y, c2x, c2y]));
          }
          prevX = nextX;
          prevY = nextY;
          prevProlong = Orientation.invert(nextProlong);
        }
        pathParts.push([prevX, prevY, endLeadX, endLeadY]);
        this._wirePath = new WirePath(pathParts);
      }
      return this._wirePath;
    }
    invalidateWirePath() {
      this._wirePath = void 0;
    }
    get style() {
      return this._style;
    }
    doSetStyle(style2) {
      this._style = style2;
      this.invalidateWirePath();
      this.requestRedraw({ why: "style changed", invalidateMask: true });
    }
    get isHidden() {
      return this._isHidden;
    }
    get behavesHidden() {
      return this._isHidden && !this.parent.editor.options.showHiddenWires;
    }
    doSetHidden(hidden) {
      this._isHidden = hidden;
      this.requestRedraw({ why: "hidden changed", invalidateMask: true });
    }
    setStartNode(startNode, now) {
      if (this._startNode !== void 0) {
        this._startNode.removeOutgoingWire(this);
      }
      this._startNode = startNode;
      startNode.addOutgoingWire(this);
      if (now !== void 0) {
        this.propagateNewValue(this._startNode.value, now);
      }
      this.invalidateWirePath();
    }
    setEndNode(endNode) {
      if (this._endNode !== void 0) {
        this._endNode.incomingWire = null;
      }
      this._endNode = endNode;
      if (endNode.incomingWire !== null && endNode.incomingWire !== void 0) {
        console.warn(`Unexpectedly replacing existing incoming wire on node ${this._endNode.id}`);
      }
      endNode.incomingWire = this;
      endNode.value = this._startNode.value;
      endNode.doSetColor(this._startNode.color);
      this.invalidateWirePath();
    }
    propagateNewValue(newValue, logicalTime) {
      var _a;
      if (this._propagatingValues[this._propagatingValues.length - 1][0] !== newValue) {
        this._propagatingValues.push([newValue, logicalTime]);
      }
      const propagationDelay = (_a = this.customPropagationDelay) != null ? _a : this.parent.editor.options.propagationDelay;
      if (propagationDelay === 0) {
        this.endNode.value = newValue;
        this._propagatingValues.splice(0, this._propagatingValues.length - 1);
      } else {
        const desc = S.Components.Wire.timeline.PropagatingValue.expand({ val: toLogicValueRepr(newValue) });
        this.parent.editor.timeline.scheduleAt(logicalTime + propagationDelay, () => {
          this.endNode.value = newValue;
        }, desc, false);
      }
    }
    destroy() {
      if (Node2.isOutput(this._startNode)) {
        this._startNode.removeOutgoingWire(this);
      }
      if (this._endNode !== null) {
        this._endNode.incomingWire = null;
      }
    }
    get isAlive() {
      return this.startNode.isAlive && this.endNode.isAlive;
    }
    addPassthroughFrom(e) {
      const parent = this.parent;
      const [x, y] = parent.editor.offsetXYForContextMenu(e, true);
      const endNode = this.endNode;
      const passthrough = PassthroughDef.make(parent, { bits: 1 });
      passthrough.setSpawned();
      passthrough.setPosition(x, y, false);
      passthrough.anchor = this.startNode.component;
      this.setEndNode(passthrough.inputs.In[0]);
      const newWire = parent.linkMgr.addWire(passthrough.outputs.Out[0], endNode, false);
      if (newWire === void 0) {
        console.warn("Couldn't create new wire");
        return;
      }
      newWire.doSetStyle(this.style);
      return passthrough;
    }
    addWaypointFrom(e) {
      const [x, y] = this.parent.editor.offsetXYForContextMenu(e, false);
      return this.addWaypointWith(x, y);
    }
    addWaypointWith(x, y) {
      const wirePath = this.wirePath;
      let partIndex = wirePath.partIndexIfMouseover(x, y);
      if (partIndex === void 0) {
        console.warn(`Couldn't find waypoint to insert at for (${x}, ${y})`);
        partIndex = 1;
      }
      const [startX, startY, endX, endY] = wirePath.parts[partIndex];
      const deltaX = endX - startX;
      const deltaY = endY - startY;
      let orient;
      if (Math.abs(deltaX) >= Math.abs(deltaY)) {
        if (endX >= startX) {
          orient = "e";
        } else {
          orient = "w";
        }
      } else {
        if (endY >= startY) {
          orient = "s";
        } else {
          orient = "n";
        }
      }
      const waypoint = new Waypoint(this, [x, y, orient]);
      waypoint.anchor = this.startNode.component;
      this._waypoints.splice(partIndex - 1, 0, waypoint);
      this.invalidateWirePath();
      return waypoint;
    }
    removeWaypoint(waypoint) {
      const i2 = this._waypoints.indexOf(waypoint);
      if (i2 !== -1) {
        this._waypoints.splice(i2, 1);
        this.invalidateWirePath();
        this.requestRedraw({ why: "waypoint deleted", invalidateMask: true });
      }
    }
    prunePropagatingValues(now, propagationDelay) {
      let removeBefore = 0;
      for (let i2 = 1; i2 < this._propagatingValues.length; i2++) {
        if (now >= this._propagatingValues[i2][1] + propagationDelay) {
          removeBefore = i2;
        } else {
          break;
        }
      }
      if (removeBefore > 0) {
        this._propagatingValues.splice(0, removeBefore);
      }
      return this._propagatingValues[0][0];
    }
    doDraw(g, ctx) {
      var _a, _b, _c;
      const isAnimating = this._propagatingValues.length > 1;
      const options = this.parent.editor.options;
      const propagationDelay = (_a = this.customPropagationDelay) != null ? _a : options.propagationDelay;
      const neutral = options.hideWireColors;
      const drawTime = ctx.drawParams.drawTime;
      this.prunePropagatingValues(drawTime, propagationDelay);
      if (this.behavesHidden) {
        return;
      }
      g.globalAlpha = this._isHidden ? OPACITY_HIDDEN_ITEMS : 1;
      const wirePath = this.wirePath;
      wirePath.draw(g);
      const drawParams = ctx.drawParams;
      if (drawParams.highlightColor !== void 0 && ((_c = (_b = drawParams.highlightedItems) == null ? void 0 : _b.wires.includes(this)) != null ? _c : false)) {
        g.lineWidth = 15;
        g.shadowColor = drawParams.highlightColor;
        g.shadowBlur = 20;
        g.shadowOffsetX = 0;
        g.shadowOffsetY = 0;
        g.strokeStyle = g.shadowColor;
        g.stroke();
        g.shadowBlur = 0;
      }
      const color = this._startNode.color;
      strokeWireOutline(g, color, ctx.isMouseOver);
      if (this._propagatingValues.length === 1) {
        const [value, timeSet] = this._propagatingValues[0];
        const frac = Math.min(1, (drawTime - timeSet) / propagationDelay);
        if (frac < 1) {
          console.warn(`Propagating value not fully propagated but drawn as such (frac=${frac} < 1.0, drawTime=${drawTime}, timeSet=${timeSet}, propagationDelay=${propagationDelay})`);
        }
        strokeWireValue(g, value, void 0, neutral, drawParams.drawTimeAnimationFraction);
      } else {
        const totalLength = wirePath.length;
        for (const [value, timeSet] of this._propagatingValues) {
          const frac = Math.min(1, (drawTime - timeSet) / propagationDelay);
          const lengthToDraw = totalLength * frac;
          strokeWireValue(g, value, [lengthToDraw, totalLength], neutral, drawParams.drawTimeAnimationFraction);
        }
      }
      g.globalAlpha = 1;
      if (isAnimating && !this.parent.editor.timeline.isPaused) {
        this.requestRedraw({ why: "propagating value", isPropagation: true });
      }
    }
    isOver(x, y) {
      if (this.parent.mode < 2 /* CONNECT */ || !this.startNode.isAlive || !this.endNode.isAlive || this.behavesHidden) {
        return false;
      }
      return this.wirePath.isOver(x, y);
    }
    mouseDown(e) {
      if (e.altKey && this.parent.mode >= 3 /* DESIGN */) {
        const passthrough = this.addPassthroughFrom(e);
        if (passthrough !== void 0) {
          return passthrough.outputs.Out[0].mouseDown(e);
        }
      }
      return super.mouseDown(e);
    }
    mouseDragged(e) {
      if (this._waypointBeingDragged !== void 0) {
        this._waypointBeingDragged.mouseDragged(e);
      } else {
        if (this.parent.editor.eventMgr.currentSelectionEmpty()) {
          const waypoint = this.addWaypointFrom(e);
          this._waypointBeingDragged = waypoint;
          waypoint.mouseDown(e);
          waypoint.mouseDragged(e);
        }
      }
    }
    mouseUp(e) {
      if (this._waypointBeingDragged !== void 0) {
        this._waypointBeingDragged.mouseUp(e);
        this._waypointBeingDragged = void 0;
        return InteractionResult.SimpleChange;
      }
      return InteractionResult.NoChange;
    }
    makeContextMenu() {
      const s = S.Components.Wire.contextMenu;
      const currentPropDelayStr = this.customPropagationDelay === void 0 ? "" : ` (${this.customPropagationDelay} ms)`;
      const makeItemUseColor = /* @__PURE__ */ __name((desc, color) => {
        const isCurrent = this._startNode.color === color;
        const icon = isCurrent ? "check" : "none";
        const action = isCurrent ? () => void 0 : () => this._startNode.doSetColor(color);
        const cssColor = COLOR_WIRE[color];
        return MenuData.item(icon, span(title(desc), style(`display: inline-block; width: 140px; height: ${WIRE_WIDTH}px; background-color: ${cssColor}; margin-right: 8px`)), action);
      }, "makeItemUseColor");
      const makeItemDisplayStyle = /* @__PURE__ */ __name((desc, style2) => {
        const isCurrent = this.style === style2;
        const icon = isCurrent ? "check" : "none";
        const action = isCurrent ? () => void 0 : () => this.doSetStyle(style2);
        return MenuData.item(icon, desc, action);
      }, "makeItemDisplayStyle");
      const hiddenMenuItem = MenuData.item(this.isHidden ? "check" : "none", s.HiddenWire, () => {
        this.doSetHidden(!this.isHidden);
      });
      const setWireOptionsItems = this.parent.mode < 3 /* DESIGN */ ? [] : [
        MenuData.sep(),
        MenuData.item("timer", s.CustomPropagationDelay.expand({ current: currentPropDelayStr }), (__itemEvent) => {
          const currentStr = this.customPropagationDelay === void 0 ? "" : String(this.customPropagationDelay);
          const defaultDelay = String(this.parent.editor.options.propagationDelay);
          const message = s.CustomPropagationDelayDesc.expand({ current: defaultDelay });
          const newValueStr = prompt(message, currentStr);
          if (newValueStr !== null) {
            if (newValueStr === "") {
              this.customPropagationDelay = void 0;
            } else {
              const asInt = parseInt(newValueStr);
              if (!isNaN(asInt)) {
                this.customPropagationDelay = asInt;
              }
            }
          }
        }),
        MenuData.submenu("palette", s.WireColor, [
          makeItemUseColor(s.WireColorBlack, WireColor.black),
          makeItemUseColor(s.WireColorRed, WireColor.red),
          makeItemUseColor(s.WireColorBlue, WireColor.blue),
          makeItemUseColor(s.WireColorYellow, WireColor.yellow),
          makeItemUseColor(s.WireColorGreen, WireColor.green),
          makeItemUseColor(s.WireColorWhite, WireColor.white)
        ]),
        MenuData.submenu("wirestyle", s.WireStyle, [
          makeItemDisplayStyle(s.WireStyleDefault, void 0),
          MenuData.sep(),
          makeItemDisplayStyle(s.WireStyleAuto, WireStyles.auto),
          makeItemDisplayStyle(s.WireStyleStraight, WireStyles.straight),
          makeItemDisplayStyle(s.WireStyleSquareHV, WireStyles.hv),
          makeItemDisplayStyle(s.WireStyleSquareVH, WireStyles.vh),
          makeItemDisplayStyle(s.WireStyleCurved, WireStyles.bezier)
        ]),
        MenuData.sep(),
        hiddenMenuItem
      ];
      const setRefItems = this.parent.mode < 4 /* FULL */ ? [] : [
        MenuData.sep(),
        this.makeSetIdContextMenuItem()
      ];
      return [
        MenuData.item("add", s.AddMiddlePoint, (__itemEvent, contextEvent) => {
          this.addWaypointFrom(contextEvent);
        }),
        MenuData.item("add", s.AddPassthrough, (__itemEvent, contextEvent) => {
          this.addPassthroughFrom(contextEvent);
        }),
        ...setWireOptionsItems,
        ...setRefItems,
        MenuData.sep(),
        MenuData.item("trash", S.Components.Generic.contextMenu.Delete, () => {
          return this.parent.linkMgr.deleteWire(this);
        }, "\u232B", true)
      ];
    }
  };
  __name(Wire, "Wire");
  var Ribbon = class extends Drawable {
    // private _startNodes: NodeOut[] = []
    // private _endNodes: NodeIn[] = []
    constructor(parent, startNodeGroup, endNodeGroup) {
      super(parent);
      this.startNodeGroup = startNodeGroup;
      this.endNodeGroup = endNodeGroup;
      this._startGroupStartIndex = Number.MAX_SAFE_INTEGER;
      this._startGroupEndIndex = Number.MIN_SAFE_INTEGER;
      this._endGroupStartIndex = Number.MAX_SAFE_INTEGER;
      this._endGroupEndIndex = Number.MIN_SAFE_INTEGER;
      this._coveredWires = [];
    }
    isEmpty() {
      return this._coveredWires.length === 0;
    }
    addCoveredWire(wire, newNodeGroupStartIndex, newNodeGroupEndIndex) {
      this._coveredWires.push(wire);
      this.updateIndices(newNodeGroupStartIndex, newNodeGroupEndIndex);
    }
    wireWasDeleted(__wire) {
    }
    updateIndices(newNodeGroupStartIndex, newNodeGroupEndIndex) {
      this._startGroupStartIndex = Math.min(this._startGroupStartIndex, newNodeGroupStartIndex);
      this._startGroupEndIndex = Math.max(this._startGroupEndIndex, newNodeGroupStartIndex);
      this._endGroupStartIndex = Math.min(this._endGroupStartIndex, newNodeGroupEndIndex);
      this._endGroupEndIndex = Math.max(this._endGroupEndIndex, newNodeGroupEndIndex);
    }
    doDraw(g, ctx) {
      const [[startX, startY], startOrient] = this.drawRibbonEnd(g, ctx, this.startNodeGroup, this._startGroupStartIndex, this._startGroupEndIndex);
      const [[endX, endY], endOrient] = this.drawRibbonEnd(g, ctx, this.endNodeGroup, this._endGroupStartIndex, this._endGroupEndIndex);
      const deltaX = endX - startX;
      const deltaY = endY - startY;
      const bezierAnchorPointDistX = Math.max(25, Math.abs(deltaX) / 3);
      const bezierAnchorPointDistY = Math.max(25, Math.abs(deltaY) / 3);
      const [anchor1X, anchor1Y] = bezierAnchorForWire(Orientation.invert(startOrient), startX, startY, bezierAnchorPointDistX, bezierAnchorPointDistY);
      const [anchor2X, anchor2Y] = bezierAnchorForWire(Orientation.invert(endOrient), endX, endY, bezierAnchorPointDistX, bezierAnchorPointDistY);
      const b2 = new Bezier(startX, startY, anchor1X, anchor1Y, anchor2X, anchor2Y, endX, endY);
      const values = [];
      for (let i2 = this._startGroupStartIndex; i2 <= this._startGroupEndIndex; i2++) {
        values.push(this.startNodeGroup.nodes[i2].value);
      }
      this.strokeWireBezier(g, b2, values, WireColor.black, ctx.isMouseOver, false);
    }
    strokeWireBezier(g, b2, values, color, isMouseOver, neutral) {
      const numWires = values.length;
      const WIRE_MARGIN_OUTER = numWires === 1 ? 1 : numWires <= 4 || numWires > 8 ? 2 : 3;
      const WIRE_MARGIN_INNER = 1;
      const WIRE_WIDTH2 = numWires <= 8 ? 2 : 1;
      if (numWires === 0) {
        return;
      }
      const totalWidth = 2 * WIRE_MARGIN_OUTER + numWires * WIRE_WIDTH2 + (numWires - 1) * WIRE_MARGIN_INNER;
      const addBezierToPath = /* @__PURE__ */ __name((b3) => {
        const [p0, a0, a1, p1] = b3.points;
        g.moveTo(p0.x, p0.y);
        g.bezierCurveTo(a0.x, a0.y, a1.x, a1.y, p1.x, p1.y);
      }, "addBezierToPath");
      const drawBezier = /* @__PURE__ */ __name((b3) => {
        g.beginPath();
        addBezierToPath(b3);
        g.stroke();
      }, "drawBezier");
      const drawBeziers = /* @__PURE__ */ __name((bs) => {
        if (isArray(bs)) {
          g.beginPath();
          for (const bb of bs) {
            addBezierToPath(bb);
          }
          g.stroke();
        }
      }, "drawBeziers");
      const oldLineCap = g.lineCap;
      g.lineCap = "butt";
      if (isMouseOver) {
        g.lineWidth = totalWidth + 2;
        g.strokeStyle = COLOR_MOUSE_OVER;
        drawBezier(b2);
        g.lineWidth = totalWidth - 2 * WIRE_MARGIN_OUTER;
      } else {
        g.lineWidth = totalWidth;
      }
      g.strokeStyle = COLOR_WIRE[color];
      drawBezier(b2);
      g.lineWidth = WIRE_WIDTH2;
      let dist = -((numWires - 1) / 2) * (WIRE_WIDTH2 + WIRE_MARGIN_INNER);
      for (const value of values) {
        g.strokeStyle = neutral ? COLOR_UNKNOWN : colorForLogicValue(value);
        const b1 = b2.offset(dist);
        drawBeziers(b1);
        dist += WIRE_WIDTH2 + WIRE_MARGIN_INNER;
      }
      g.lineCap = oldLineCap;
    }
    drawRibbonEnd(g, ctx, nodeGroup, startIndex, endIndex) {
      const nodes = nodeGroup.nodes;
      const orient = nodes[startIndex].orient;
      const numNodes = endIndex - startIndex + 1;
      let minX = Number.POSITIVE_INFINITY;
      let minY = Number.POSITIVE_INFINITY;
      let maxX = Number.NEGATIVE_INFINITY;
      let maxY = Number.NEGATIVE_INFINITY;
      let sumX = 0;
      let sumY = 0;
      for (let i2 = startIndex; i2 <= endIndex; i2++) {
        const node = nodes[i2];
        const x = node.posX;
        const y = node.posY;
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
        sumX += x;
        sumY += y;
      }
      const [[startX, startY], [endX, endY], mid] = (() => {
        switch (orient) {
          case "e":
            return [[maxX, minY], [maxX, maxY], [maxX, sumY / numNodes]];
          case "w":
            return [[minX, minY], [minX, maxY], [minX, sumY / numNodes]];
          case "s":
            return [[minX, minY], [maxX, minY], [sumX / numNodes, minY]];
          case "n":
            return [[minX, maxY], [maxX, maxY], [sumX / numNodes, maxY]];
        }
      })();
      drawStraightWireLine(g, startX, startY, endX, endY, "Z", "black", true, ctx.drawParams.drawTimeAnimationFraction);
      return [mid, orient];
    }
    isOver(__x, __y) {
      return false;
    }
    isInRect(__rect) {
      return false;
    }
  };
  __name(Ribbon, "Ribbon");
  var LinkManager = class {
    constructor(parent) {
      // wires and ribbons
      this._wires = [];
      this._ribbons = [];
      this._wireBeingAddedFrom = void 0;
      // anchors
      this._anchorBeingSetFrom = void 0;
      this.parent = parent;
    }
    get wires() {
      return this._wires;
    }
    get ribbons() {
      return this._ribbons;
    }
    get isAddingWire() {
      return this._wireBeingAddedFrom !== void 0;
    }
    get isSettingAnchor() {
      return this._anchorBeingSetFrom !== void 0;
    }
    draw(g, drawParams) {
      this.removeDeadWires();
      const useRibbons = this.parent.editor.options.groupParallelWires;
      if (useRibbons) {
        for (const ribbon of this._ribbons) {
          ribbon.draw(g, drawParams);
        }
      }
      for (const wire of this._wires) {
        if (useRibbons && wire.ribbon !== void 0) {
          continue;
        }
        wire.draw(g, drawParams);
        for (const waypoint of wire.waypoints) {
          waypoint.draw(g, drawParams);
        }
      }
      this.drawWireBeingAdded(g, drawParams);
      this.drawAnchorBeingSet(g);
    }
    drawWireBeingAdded(g, drawParams) {
      const nodeFrom = this._wireBeingAddedFrom;
      if (nodeFrom !== void 0) {
        const x1 = nodeFrom.posX;
        const y1 = nodeFrom.posY;
        const editor = this.parent.editor;
        const zoomFactor = editor.options.zoom / 100;
        const x2 = editor.mouseX / zoomFactor;
        const y2 = editor.mouseY / zoomFactor;
        g.beginPath();
        g.moveTo(x1, y1);
        if (this.parent.editor.options.wireStyle === WireStyles.straight) {
          g.lineTo(x2, y2);
        } else {
          const deltaX = x2 - x1;
          const deltaY = y2 - y1;
          const bezierAnchorPointDistX = Math.max(25, Math.abs(deltaX) / 3);
          const bezierAnchorPointDistY = Math.max(25, Math.abs(deltaY) / 3);
          const outgoingOrient = Orientation.add(nodeFrom.component.orient, nodeFrom.orient);
          const [a1x, a1y] = bezierAnchorForWire(Orientation.invert(outgoingOrient), x1, y1, bezierAnchorPointDistX, bezierAnchorPointDistY);
          const [a2x, a2y] = bezierAnchorForWire(outgoingOrient, x2, y2, bezierAnchorPointDistX, bezierAnchorPointDistY);
          g.bezierCurveTo(a1x, a1y, a2x, a2y, x2, y2);
        }
        strokeWireOutlineAndSingleValue(g, nodeFrom.value, nodeFrom.color, false, drawParams.drawTimeAnimationFraction);
      }
    }
    drawAnchorBeingSet(g) {
      const drawable = this._anchorBeingSetFrom;
      if (drawable !== void 0) {
        const x1 = drawable.posX;
        const y1 = drawable.posY;
        const editor = this.parent.editor;
        const zoomFactor = editor.options.zoom / 100;
        const x2 = editor.mouseX / zoomFactor;
        const y2 = editor.mouseY / zoomFactor;
        drawAnchorTo(g, x1, y1, x2, y2, 6, COLOR_ANCHOR_NEW, void 0);
      }
    }
    removeDeadWires() {
      let i2 = 0;
      while (i2 < this._wires.length) {
        const wire = this._wires[i2];
        if (!wire.isAlive) {
          wire.destroy();
          this._wires.splice(i2, 1);
        } else {
          i2++;
        }
      }
    }
    addWire(startNode, endNode, tryOffset) {
      var _a, _b, _c;
      if (!startNode.acceptsMoreConnections || !endNode.acceptsMoreConnections) {
        return void 0;
      }
      const wire = new Wire(startNode, endNode);
      this._wires.push(wire);
      if (tryOffset) {
        this.offsetWireIfNecessary(wire);
      }
      this.tryMergeWire(wire);
      (_a = this.parent.ifEditing) == null ? void 0 : _a.setToolCursor(null);
      (_b = this.parent.ifEditing) == null ? void 0 : _b.setDirty("added wire");
      (_c = this.parent.ifEditing) == null ? void 0 : _c.redrawMgr.requestRedraw({ why: "wire added", invalidateMask: true, invalidateTests: true });
      return wire;
    }
    startSettingAnchorFrom(drawable) {
      var _a;
      if (this._anchorBeingSetFrom !== void 0) {
        console.warn("LinkManager.startSettingAnchorFrom: already setting anchor from a drawable");
      }
      this._anchorBeingSetFrom = drawable;
      (_a = this.parent.ifEditing) == null ? void 0 : _a.setToolCursor("alias");
    }
    stopSettingAnchorOn(comp) {
      const anchorBeingSetFrom = this._anchorBeingSetFrom;
      if (anchorBeingSetFrom) {
        return this.trySetAnchor(anchorBeingSetFrom, comp);
      }
      return InteractionResult.NoChange;
    }
    trySetAnchor(from, to) {
      this.tryCancelSetAnchor();
      if (to.ref === void 0) {
        console.warn("LinkManager.stopSettingAnchorOn: component has no ref");
      }
      if (to !== from) {
        let forbidden = false;
        let current = to;
        while (current.anchor !== void 0) {
          current = current.anchor;
          if (current === from) {
            forbidden = true;
            break;
          }
        }
        if (forbidden) {
          this.parent.editor.showMessage(S.Messages.CircularAnchorsForbidden);
        } else {
          from.anchor = to;
          this.parent.editor.showMessage(S.Messages.AnchorAdded);
          return InteractionResult.SimpleChange;
        }
      }
      return InteractionResult.NoChange;
    }
    tryCancelSetAnchor() {
      var _a;
      this._anchorBeingSetFrom = void 0;
      (_a = this.parent.ifEditing) == null ? void 0 : _a.setToolCursor(null);
    }
    startDraggingWireFrom(node) {
      var _a;
      if (this._wireBeingAddedFrom !== void 0) {
        console.warn("LinkManager.startDraggingFrom: already dragging from a node");
      }
      if (!node.acceptsMoreConnections) {
        return;
      }
      this._wireBeingAddedFrom = node;
      (_a = this.parent.ifEditing) == null ? void 0 : _a.setToolCursor("crosshair");
    }
    stopDraggingWireOn(newNode) {
      const nodes = this.getOutInNodesForNewWire(newNode);
      this._wireBeingAddedFrom = void 0;
      if (nodes === void 0) {
        return void 0;
      }
      return this.addWire(nodes[0], nodes[1], true);
    }
    isValidNodeToConnect(node) {
      return this.getOutInNodesForNewWire(node) !== void 0;
    }
    getOutInNodesForNewWire(newNode) {
      var _a, _b;
      const otherNode = this._wireBeingAddedFrom;
      if (otherNode === void 0) {
        return void 0;
      }
      if (newNode === otherNode) {
        return void 0;
      }
      if (otherNode.isOutput()) {
        if (newNode.isOutput() || !newNode.acceptsMoreConnections) {
          return void 0;
        } else {
          return [otherNode, newNode];
        }
      } else {
        if (newNode.isOutput()) {
          return [newNode, otherNode];
        } else {
          let otherStartNode = (_a = newNode.incomingWire) == null ? void 0 : _a.startNode;
          if (otherStartNode !== void 0 && otherNode.acceptsMoreConnections) {
            return [otherStartNode, otherNode];
          }
          otherStartNode = (_b = otherNode.incomingWire) == null ? void 0 : _b.startNode;
          if (otherStartNode !== void 0 && newNode.acceptsMoreConnections) {
            return [otherStartNode, newNode];
          }
          return void 0;
        }
      }
    }
    tryCancelWireOrAnchor() {
      var _a, _b;
      if (this._wireBeingAddedFrom !== void 0) {
        this._wireBeingAddedFrom = void 0;
        (_a = this.parent.ifEditing) == null ? void 0 : _a.setToolCursor(null);
        return true;
      }
      if (this._anchorBeingSetFrom !== void 0) {
        this._anchorBeingSetFrom = void 0;
        (_b = this.parent.ifEditing) == null ? void 0 : _b.setToolCursor(null);
        return true;
      }
      return false;
    }
    offsetWireIfNecessary(wire) {
      const startNode = wire.startNode;
      const endNode = wire.endNode;
      const comp = startNode.component;
      if (comp !== endNode.component) {
        return;
      }
      const dx2 = (endNode.posX - startNode.posX) / 2;
      const dy2 = (endNode.posY - startNode.posY) / 2;
      const midpointX = startNode.posX + dx2;
      const midpointY = startNode.posY + dy2;
      if (!comp.isOver(midpointX, midpointY)) {
        return;
      }
      const addToX = dx2 > dy2;
      const dir = addToX ? startNode.posX < endNode.posX ? 1 : startNode.posX > endNode.posX ? -1 : startNode.posX < comp.posX ? -1 : 1 : startNode.posY < endNode.posY ? 1 : startNode.posY > endNode.posY ? -1 : startNode.posY < comp.posY ? -1 : 1;
      const calcOffsetFromDim = /* @__PURE__ */ __name((dim) => {
        return dir * (dim / 2 + 2 * GRID_STEP);
      }, "calcOffsetFromDim");
      const isVertical = Orientation.isVertical(comp.orient);
      const waypointX = midpointX + (addToX ? calcOffsetFromDim(isVertical ? comp.unrotatedHeight : comp.unrotatedWidth) : 0);
      const waypointY = midpointY + (addToX ? 0 : calcOffsetFromDim(isVertical ? comp.unrotatedWidth : comp.unrotatedHeight));
      const waypoint = wire.addWaypointWith(waypointX, waypointY);
      waypoint.anchor = comp;
    }
    tryMergeWire(wire) {
      const startNode = wire.startNode;
      const endNode = wire.endNode;
      const startGroup = startNode.group;
      const endGroup = endNode.group;
      if (startGroup === void 0 || endGroup === void 0) {
        return;
      }
      const findWire = /* @__PURE__ */ __name((group1, i1, group2, i2) => {
        if (i1 < 0 || i2 < 0 || i1 >= group1.nodes.length || i2 >= group2.nodes.length) {
          return void 0;
        }
        return group1.nodes[i1].findWireTo(group2.nodes[i2]);
      }, "findWire");
      const indexStart = startGroup.nodes.indexOf(startNode);
      const indexEnd = endGroup.nodes.indexOf(endNode);
      const wireBefore = findWire(startGroup, indexStart - 1, endGroup, indexEnd - 1);
      if (wireBefore !== void 0) {
        let ribbon = wireBefore.ribbon;
        if (ribbon === void 0) {
          ribbon = new Ribbon(startNode.parent, startGroup, endGroup);
          this._ribbons.push(ribbon);
          wireBefore.ribbon = ribbon;
          ribbon.addCoveredWire(wireBefore, indexStart - 1, indexEnd - 1);
        }
        ribbon.addCoveredWire(wire, indexStart, indexEnd);
        wire.ribbon = ribbon;
      }
    }
    deleteWire(wire) {
      const oldStartNode = wire.startNode;
      const oldEndNode = wire.endNode;
      const deleted = this.doDeleteWire(wire);
      if (!deleted) {
        return InteractionResult.NoChange;
      }
      return tryMakeRepeatableNodeAction(oldStartNode, oldEndNode, (startNode, endNode) => {
        const wire2 = endNode.incomingWire;
        if (wire2 === null || wire2.startNode !== startNode) {
          return false;
        }
        return this.doDeleteWire(wire2);
      });
    }
    doDeleteWire(wire) {
      var _a;
      wire.destroy();
      const ribbon = wire.ribbon;
      if (ribbon !== void 0) {
        ribbon.wireWasDeleted(wire);
        if (ribbon.isEmpty()) {
          this._ribbons.splice(this._ribbons.indexOf(ribbon), 1);
        }
      }
      this._wires.splice(this._wires.indexOf(wire), 1);
      (_a = this.parent.ifEditing) == null ? void 0 : _a.redrawMgr.requestRedraw({ why: "wire deleted", invalidateMask: true, invalidateTests: true });
      return true;
    }
    invalidateAllWirePaths() {
      for (const wire of this._wires) {
        wire.invalidateWirePath();
      }
    }
    clearAll() {
      var _a;
      for (const wire of this._wires) {
        wire.destroy();
      }
      this._wires.length = 0;
      (_a = this.parent.ifEditing) == null ? void 0 : _a.redrawMgr.requestRedraw({ why: "all wires deleted", invalidateMask: true, invalidateTests: true });
    }
  };
  __name(LinkManager, "LinkManager");
  function bezierAnchorForWire(wireProlongDirection, x, y, distX, distY) {
    switch (wireProlongDirection) {
      case "e":
        return [x - distX, y];
      case "w":
        return [x + distX, y];
      case "s":
        return [x, y - distY];
      case "n":
        return [x, y + distY];
    }
  }
  __name(bezierAnchorForWire, "bezierAnchorForWire");

  // simulator/src/Serialization.ts
  var _Serialization = class {
    // Top-level
    saveCircuitToFile(editor) {
      const jsonStr = this.stringifyObject(this.buildCircuitObject(editor), false);
      const blob = new Blob([jsonStr], { type: "application/json5" });
      const filename = editor.documentDisplayName + ".json";
      (0, import_file_saver.saveAs)(blob, filename);
    }
    saveLibraryToFile(editor) {
      const jsonStr = this.stringifyObject(this.buildLibraryObject(editor), false);
      const blob = new Blob([jsonStr], { type: "application/json5" });
      const filename = editor.documentDisplayName + "-lib.json";
      (0, import_file_saver.saveAs)(blob, filename);
    }
    loadCircuitOrLibrary(editor, content, opts) {
      let parsed;
      if (!isString(content)) {
        parsed = content;
      } else {
        try {
          parsed = JSONParseObject(content);
        } catch (err) {
          console.error(err);
          return "can't load this JSON - error \u201C" + err + `\u201D, length = ${content.length}, JSON:
` + content;
        }
      }
      const isLib = parsed.type === "lib";
      if (isLib) {
        return this.doLoadLibrary(editor, parsed);
      } else {
        return this.loadCircuit(editor, parsed, opts);
      }
    }
    pasteComponents(parent, content) {
      let parsed;
      try {
        parsed = JSONParseObject(content);
      } catch (err) {
        console.error(err);
        return "can't load this JSON - error \u201C" + err + `\u201D, length = ${content.length}, JSON:
` + content;
      }
      let offsetPos = void 0;
      if (isArray(parsed.pos)) {
        const editor = parent.editor;
        const ceil10 = /* @__PURE__ */ __name((x) => Math.ceil(x / 10) * 10, "ceil10");
        offsetPos = [ceil10(editor.mouseX - parsed.pos[0]), ceil10(editor.mouseY - parsed.pos[1])];
      }
      const compReprs = parsed.components;
      if (!isArray(compReprs) && !isRecord(compReprs)) {
        return "invalid JSON: 'components' must be an array or an object";
      }
      const { nodeMapping, components, componentsByRef } = this.makeComponents(parent, compReprs, offsetPos);
      this.makeWires(parent, parsed.wires, nodeMapping, componentsByRef, false);
      return components;
    }
    // Private
    doLoadLibrary(editor, parsed) {
      migrateData(parsed);
      const numLoaded = editor.factory.tryLoadCustomDefsFrom(parsed.defs);
      editor.updateCustomComponentButtons();
      editor.showMessage(S.Messages.LoadedDefinitions.expand({ n: numLoaded }));
      return void 0;
    }
    loadCircuit(parent, parsed_, opts) {
      var _a, _b, _c, _d;
      const componentList = parent.components;
      const parsed = __spreadValues({}, parsed_);
      try {
        if (!((_a = opts == null ? void 0 : opts.skipMigration) != null ? _a : false)) {
          migrateData(parsed);
        }
      } catch (err) {
        console.error(err);
        return "can't migrate JSON - error \u201C" + err + `\u201D, JSON:
` + stringifySmart(parsed, { maxLength: 120 });
      }
      delete parsed.v;
      if (parent.isMainEditor()) {
        parent.factory.clearCustomDefs();
        parent.factory.tryLoadCustomDefsFrom(parsed.defs);
        delete parsed.defs;
      }
      for (const elem of componentList.all()) {
        elem.destroy();
      }
      componentList.clearAll();
      parent.linkMgr.clearAll();
      parent.nodeMgr.clearAll();
      if (parent.isMainEditor()) {
        parent.timeline.reset();
      }
      const compReprs = parsed.components;
      const { nodeMapping, componentsByRef } = this.makeComponents(parent, compReprs, void 0);
      delete parsed.components;
      const immediateWirePropagation = (_b = opts == null ? void 0 : opts.immediateWirePropagation) != null ? _b : false;
      this.makeWires(parent, parsed.wires, nodeMapping, componentsByRef, immediateWirePropagation);
      delete parsed.wires;
      if (isArray(parsed.tests)) {
        const testSuiteReprs = validateJson(parsed.tests, TestSuite.ReprArray, "tests");
        if (testSuiteReprs !== void 0) {
          const testSuites = testSuiteReprs.map((ts) => new TestSuite([ts, componentList]));
          parent.testSuites.set(testSuites);
          (_c = parent.ifEditing) == null ? void 0 : _c.testsPalette.update();
        }
      }
      delete parsed.tests;
      if (parent.isMainEditor()) {
        if (parsed.userdata !== void 0) {
          if (typeof parent.userdata === "object" && typeof parsed.userdata === "object") {
            parent.userdata = __spreadValues(__spreadValues({}, parsed.userdata), parent.userdata);
          } else {
          }
          delete parsed.userdata;
        }
        parent.setPartialOptions(parsed.opts);
        delete parsed.opts;
        const isUndoRedoAction = (_d = opts == null ? void 0 : opts.isUndoRedoAction) != null ? _d : false;
        if (!isUndoRedoAction) {
          parent.editor.editTools.undoMgr.takeSnapshot();
        }
        parent.updateCustomComponentButtons();
        const scratch = parsed.scratch;
        let customComp_;
        if (scratch !== void 0 && isRecord(scratch) && isString(scratch.id) && (customComp_ = parent.components.get(scratch.id)) !== void 0) {
          delete scratch.id;
          const customComp = customComp_;
          const error = this.loadCircuitForCustomComponent(customComp, scratch);
          if (error !== void 0) {
            console.error("Error loading scratch space: " + error);
          } else {
            parent.setEditorRoot(customComp);
          }
        }
        delete parsed.scratch;
      }
      const unhandledData = keysOf(parsed);
      if (unhandledData.length !== 0) {
        console.warn("Unloaded data fields: " + unhandledData.join(", "));
      }
      return void 0;
    }
    loadCircuitForCustomComponent(customComp, parsed) {
      const error = this.loadCircuit(customComp, parsed, { immediateWirePropagation: true, skipMigration: true });
      if (error !== void 0) {
        return error;
      }
      customComp.circuitDidLoad();
      return void 0;
    }
    makeComponents(parent, compReprs, offsetPos) {
      const components = [];
      const componentsByRef = {};
      const anchorsToSet = [];
      const add = /* @__PURE__ */ __name((c, repr) => {
        if (c !== void 0) {
          components.push(c);
          if (c.ref !== void 0) {
            componentsByRef[c.ref] = c;
          }
          let anchor;
          if (isRecord(repr) && "anchor" in repr && isString(anchor = repr.anchor)) {
            anchorsToSet.push([c, anchor]);
          }
        }
      }, "add");
      const nodeMapping = parent.nodeMgr.recordMappingWhile(() => {
        const factory = parent.editor.factory;
        if (isArray(compReprs)) {
          for (const compRepr of compReprs) {
            add(factory.makeFromJSON(parent, compRepr, offsetPos), compRepr);
          }
        } else if (isRecord(compReprs)) {
          for (const [id, compRepr] of Object.entries(compReprs)) {
            if (isRecord(compRepr)) {
              compRepr.ref = id;
              add(factory.makeFromJSON(parent, compRepr, offsetPos), compRepr);
            } else {
              console.error(`Invalid non-object component repr: '${compRepr}'`);
            }
          }
        }
      });
      for (const [comp, anchorRef] of anchorsToSet) {
        const anchor = componentsByRef[anchorRef];
        if (anchor !== void 0) {
          comp.anchor = anchor;
        } else {
          console.warn(`Anchor '${anchorRef}' not found for component '${comp.ref}'`);
        }
      }
      return { nodeMapping, components, componentsByRef };
    }
    makeWires(parent, wires, nodeMapping, componentsByRef, immediateWirePropagation) {
      const linkMgr = parent.linkMgr;
      const nodeMgr = parent.nodeMgr;
      const recalcMgr = parent.recalcMgr;
      recalcMgr.recalcAndPropagateIfNeeded();
      for (const obj of isArray(wires) ? wires : []) {
        const wireData = validateJson(obj, Wire.Repr, "wire");
        if (wireData === void 0) {
          return;
        }
        const [nodeID1, nodeID2, wireOptions] = wireData;
        const node1 = nodeMgr.findNode(nodeID1, nodeMapping);
        const node2 = nodeMgr.findNode(nodeID2, nodeMapping);
        if (node1 !== void 0 && node2 !== void 0 && node1.isOutput() && !node2.isOutput()) {
          const completedWire = linkMgr.addWire(node1, node2, false);
          if (completedWire !== void 0) {
            if (wireOptions !== void 0) {
              completedWire.setOptions(wireOptions, componentsByRef);
            }
            if (immediateWirePropagation) {
              completedWire.customPropagationDelay = 0;
            }
          }
          recalcMgr.recalcAndPropagateIfNeeded();
        }
      }
    }
    buildCircuitObject(editor) {
      var _a;
      const dataObject = {
        v: CurrentFormatVersion,
        opts: editor.nonDefaultOptions(),
        defs: editor.factory.customDefReprs(),
        scratch: void 0,
        userdata: editor.userdata
      };
      const editorRoot = editor.editorRoot;
      if (!(editorRoot instanceof LogicEditor)) {
        const customComp = editorRoot;
        const scratch = {
          id: (_a = customComp.ref) != null ? _a : "n/a"
        };
        this.buildReprsInto(scratch, editorRoot.components.all(), editorRoot.linkMgr.wires, editorRoot.testSuites.suites);
        dataObject.scratch = scratch;
      }
      this.buildReprsInto(dataObject, editor.components.all(), editor.linkMgr.wires, editor.testSuites.suites);
      return dataObject;
    }
    buildLibraryObject(editor) {
      return {
        v: CurrentFormatVersion,
        defs: editor.factory.customDefReprs(),
        type: "lib"
      };
    }
    buildComponentsAndWireObject(components, testSuites, sourcePos) {
      const dataObject = {};
      if (sourcePos !== void 0) {
        dataObject.pos = sourcePos;
      }
      const wires = [];
      for (const comp of components) {
        for (const nodeIn of comp.inputs._all) {
          const wire = nodeIn.incomingWire;
          if (wire !== null && components.includes(wire.startNode.component)) {
            wires.push(wire);
          }
        }
      }
      this.buildReprsInto(dataObject, components, wires, testSuites);
      return dataObject;
    }
    buildReprsInto(dataObject, components, wires, testSuites) {
      for (const comp of components) {
        if (dataObject.components === void 0) {
          dataObject.components = {};
        }
        const id = comp.ref;
        if (id === void 0) {
          console.error("Skipping component with no id: " + comp);
          continue;
        }
        if (dataObject.components[id] !== void 0) {
          console.error("Skipping component with duplicate id: " + comp);
        }
        const compRepr = comp.toJSON();
        dataObject.components[id] = compRepr;
      }
      if (wires.length !== 0) {
        dataObject.wires = wires.map((w) => w.toJSON());
      }
      if (testSuites.length !== 0) {
        dataObject.tests = testSuites.map((ts) => ts.toJSON());
      }
    }
    removeShowOnlyFrom(dataObject) {
      if (dataObject.opts !== void 0) {
        const showOnly = dataObject.opts.showOnly;
        delete dataObject.opts.showOnly;
        if (Object.keys(dataObject.opts).length === 0) {
          delete dataObject.opts;
        }
        if (isArray(showOnly) && showOnly.every(isString)) {
          return showOnly;
        }
      }
      return void 0;
    }
    stringifyObject(_dataObject, compact) {
      if (compact) {
        return import_json53.default.stringify(_dataObject);
      }
      const dataObject = __spreadValues({}, _dataObject);
      const parts = [];
      stringifyCompactReprTo(parts, dataObject, "v");
      stringifyCompactReprTo(parts, dataObject, "type");
      stringifyCompactReprTo(parts, dataObject, "opts");
      stringifyCompactReprTo(parts, dataObject, "userdata");
      stringifyCompactReprTo(parts, dataObject, "pos");
      const defs = dataObject.defs;
      if (defs !== void 0 && isArray(defs)) {
        const defparts = [];
        for (const def of defs) {
          const circuit = def.circuit;
          delete def.circuit;
          let subpart = stringifySmart(def, { maxLength: Infinity });
          def.circuit = circuit;
          const compparts = [];
          stringifyComponentWiresTestsReprsTo(compparts, __spreadValues({}, circuit), 3, true);
          const circuitRepr = compparts.length === 0 ? "{}" : "{\n      " + compparts.join(",\n      ") + "\n    }";
          subpart = subpart.slice(0, subpart.length - 1) + `, circuit: ` + circuitRepr + "}";
          defparts.push(subpart);
        }
        parts.push(`defs: [
    ` + defparts.join(",\n    ") + "\n  ]");
      }
      delete dataObject.defs;
      const scratch = dataObject.scratch;
      if (scratch !== void 0) {
        const scratchparts = [];
        scratchparts.push(`id: ${stringifySmart(scratch.id)}`);
        stringifyComponentWiresTestsReprsTo(scratchparts, __spreadValues({}, scratch), 2, false);
        parts.push(`scratch: {
    ` + scratchparts.join(",\n    ") + "\n  }");
      }
      delete dataObject.scratch;
      stringifyComponentWiresTestsReprsTo(parts, dataObject, 1, false);
      const unprocessedFields = keysOf(dataObject);
      if (unprocessedFields.length !== 0) {
        console.error("ERROR: unprocessed fields in stringified JSON: " + unprocessedFields.join(", "));
      }
      return "{ // JSON5\n  " + parts.join(",\n  ") + "\n}";
    }
  };
  __name(_Serialization, "_Serialization");
  var Serialization = new _Serialization();
  function stringifyCompactReprTo(parts, container, key) {
    const value = container[key];
    if (value !== void 0) {
      parts.push(`${stringifyKey(key)}: ${stringifySmart(value, { maxLength: Infinity })}`);
    }
    delete container[key];
  }
  __name(stringifyCompactReprTo, "stringifyCompactReprTo");
  function stringifyComponentWiresTestsReprsTo(parts, container, outerLevel, noWireDelay) {
    const outerIndent = "  ".repeat(outerLevel);
    const innerIndent = outerIndent + "  ";
    let entries;
    const comps = container.components;
    if (comps !== void 0) {
      if (isArray(comps) && comps.length !== 0) {
        const subparts = [];
        for (const compRepr of comps) {
          subparts.push(stringifySmart(compRepr, { maxLength: Infinity }));
        }
        parts.push(`components: [
${innerIndent}` + subparts.join(`,
${innerIndent}`) + `,
${outerIndent}]`);
      } else if ((entries = Object.entries(comps)).length !== 0) {
        const subparts = [];
        for (const [id, compRepr] of entries) {
          delete compRepr.ref;
          subparts.push(`${stringifyKey(id)}: ${stringifySmart(compRepr, { maxLength: Infinity })}`);
        }
        parts.push(`components: {
${innerIndent}` + subparts.join(`,
${innerIndent}`) + `,
${outerIndent}}`);
      }
    }
    delete container.components;
    if (noWireDelay && container.wires !== void 0) {
      for (const wire of container.wires) {
        const wireOpts = wire[2];
        if (wireOpts !== void 0) {
          delete wireOpts.propagationDelay;
          if (allValuesUndefined(wireOpts)) {
            wire.splice(2, 1);
          }
        }
      }
    }
    stringifyCompactReprTo(parts, container, "wires");
    const tests = container.tests;
    if (tests !== void 0 && tests.length !== 0) {
      const innerIndent2 = innerIndent + "  ";
      const subparts = [];
      for (const testSuiteRepr of tests) {
        const Cases = "cases";
        const testCases = testSuiteRepr[Cases];
        const testCasesReprStrs = testCases.map((testCase) => stringifySmart(testCase, { maxLength: Infinity })).filter((s) => s.length !== 0);
        testSuiteRepr.cases = void 0;
        const baseSuiteRepr = stringifySmart(testSuiteRepr, { maxLength: Infinity }).slice(1, -1);
        const sep = baseSuiteRepr.length === 0 ? "" : ", ";
        testSuiteRepr.cases = testCases;
        const casesRepr = testCasesReprStrs.length === 0 ? `${Cases}: []` : `${Cases}: [
${innerIndent2}` + testCasesReprStrs.join(`,
${innerIndent2}`) + `,
${innerIndent}]`;
        subparts.push(`{${baseSuiteRepr}${sep}${casesRepr}}`);
      }
      parts.push(`tests: [
${innerIndent}` + subparts.join(`
${innerIndent}`) + `
${outerIndent}]`);
    }
    delete container.tests;
  }
  __name(stringifyComponentWiresTestsReprsTo, "stringifyComponentWiresTestsReprsTo");
  function allValuesUndefined(obj) {
    for (const value of Object.values(obj)) {
      if (value !== void 0) {
        return false;
      }
    }
    return true;
  }
  __name(allValuesUndefined, "allValuesUndefined");
  var stringOrChar = /("([^\\"]|\\.)*")|[:,]/g;
  function stringifySmart(passedObj, options) {
    var _a, _b;
    options != null ? options : options = {};
    const indent = JSON.stringify([1], void 0, (_a = options.indent) != null ? _a : 2).slice(2, -3);
    const maxLength = indent === "" ? Infinity : (_b = options.maxLength) != null ? _b : 80;
    let replacer = options.replacer;
    return (/* @__PURE__ */ __name(function _stringify(obj, currentIndent, reserved) {
      if (obj !== void 0 && typeof obj.toJSON === "function") {
        obj = obj.toJSON();
      }
      const string12 = import_json53.default.stringify(obj, replacer);
      if (string12 === void 0) {
        return string12;
      }
      let length = maxLength - currentIndent.length - reserved;
      if (string12.length <= length) {
        const prettified = string12.replace(
          stringOrChar,
          function(match, stringLiteral) {
            return stringLiteral != null ? stringLiteral : match + " ";
          }
        );
        if (prettified.length <= length) {
          return prettified;
        }
      }
      if (replacer !== null) {
        obj = import_json53.default.parse(string12);
        replacer = void 0;
      }
      if (typeof obj === "object" && obj !== null) {
        const nextIndent = currentIndent + indent;
        const items = [];
        let index = 0;
        let start2;
        let end2;
        if (Array.isArray(obj)) {
          start2 = "[";
          end2 = "]";
          length = obj.length;
          for (; index < length; index++) {
            items.push(
              _stringify(obj[index], nextIndent, index === length - 1 ? 0 : 1) || "null"
            );
          }
        } else {
          start2 = "{";
          end2 = "}";
          const keys = Object.keys(obj);
          length = keys.length;
          for (; index < length; index++) {
            const key = keys[index];
            const keyPart = stringifyKey(key) + ": ";
            const value = _stringify(
              obj[key],
              nextIndent,
              keyPart.length + (index === length - 1 ? 0 : 1)
            );
            if (value !== void 0) {
              items.push(keyPart + value);
            }
          }
        }
        if (items.length > 0) {
          return [start2, indent + items.join(",\n" + nextIndent), end2].join(
            "\n" + currentIndent
          );
        }
      }
      return string12;
    }, "_stringify"))(passedObj, "", 0);
  }
  __name(stringifySmart, "stringifySmart");
  function stringifyKey(key) {
    if (key.length === 0) {
      return quoteString(key);
    }
    const firstChar = String.fromCodePoint(key.codePointAt(0));
    if (!json5util.isIdStartChar(firstChar)) {
      return quoteString(key);
    }
    for (let i2 = firstChar.length; i2 < key.length; i2++) {
      if (!json5util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i2)))) {
        return quoteString(key);
      }
    }
    return key;
  }
  __name(stringifyKey, "stringifyKey");
  var replacements = {
    "'": "\\'",
    '"': '\\"',
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\v": "\\v",
    "\0": "\\0",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };
  function quoteString(value) {
    const quotes = {
      "'": 0.1,
      '"': 0.2
    };
    let product = "";
    for (let i2 = 0; i2 < value.length; i2++) {
      const c = value[i2];
      switch (c) {
        case "'":
        case '"':
          quotes[c]++;
          product += c;
          continue;
        case "\0":
          if (json5util.isDigit(value[i2 + 1])) {
            product += "\\x00";
            continue;
          }
      }
      if (replacements[c] !== void 0) {
        product += replacements[c];
        continue;
      }
      if (c < " ") {
        const hexString = c.charCodeAt(0).toString(16);
        product += "\\x" + ("00" + hexString).substring(hexString.length);
        continue;
      }
      product += c;
    }
    const quoteChar = keysOf(quotes).reduce(function(a2, b2) {
      return quotes[a2] < quotes[b2] ? a2 : b2;
    });
    product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);
    return quoteChar + product + quoteChar;
  }
  __name(quoteString, "quoteString");

  // simulator/src/components/ALU.ts
  var t9 = __toESM(require_lib());

  // simulator/src/components/GateTypes.ts
  var t8 = __toESM(require_lib());
  var Gate1Types = RichStringEnum.withProps()({
    not: {
      out: ([in_]) => in_ === false ? true : in_ === true ? false : Unknown,
      includeInContextMenu: true,
      includeInPoseAs: true,
      fullShortDesc: () => S.Components.Gate.not
    },
    buf: {
      out: ([in_]) => in_ === true ? true : in_ === false ? false : Unknown,
      includeInContextMenu: true,
      includeInPoseAs: true,
      fullShortDesc: () => S.Components.Gate.buf
    }
  });
  var Gate1TypeRepr = t8.keyof(Gate1Types.props);
  var Gate2toNTypes = RichStringEnum.withProps()({
    and: {
      out: logicAnd,
      includeInContextMenu: true,
      includeInPoseAs: true,
      fullShortDesc: () => S.Components.Gate.and
    },
    or: {
      out: logicOr,
      includeInContextMenu: true,
      includeInPoseAs: true,
      fullShortDesc: () => S.Components.Gate.or
    },
    xor: {
      out: logicXor,
      includeInContextMenu: true,
      includeInPoseAs: true,
      fullShortDesc: () => S.Components.Gate.xor
    },
    nand: {
      out: (ins) => LogicValue.invert(logicAnd(ins)),
      includeInContextMenu: true,
      includeInPoseAs: true,
      fullShortDesc: () => S.Components.Gate.nand
    },
    nor: {
      out: (ins) => LogicValue.invert(logicOr(ins)),
      includeInContextMenu: true,
      includeInPoseAs: true,
      fullShortDesc: () => S.Components.Gate.nor
    },
    xnor: {
      out: (ins) => LogicValue.invert(logicXor(ins)),
      includeInContextMenu: true,
      includeInPoseAs: true,
      fullShortDesc: () => S.Components.Gate.xnor
    }
  });
  var Gate2toNTypeRepr = t8.keyof(Gate2toNTypes.props);
  var Gate2OnlyTypes = RichStringEnum.withProps()({
    // less common gates
    imply: {
      out: (ins) => logicImply(ins[0], ins[1]),
      includeInContextMenu: true,
      includeInPoseAs: true,
      fullShortDesc: () => S.Components.Gate.imply
    },
    rimply: {
      out: (ins) => logicImply(ins[1], ins[0]),
      includeInContextMenu: false,
      includeInPoseAs: true,
      fullShortDesc: () => S.Components.Gate.rimply
    },
    nimply: {
      out: (ins) => LogicValue.invert(logicImply(ins[0], ins[1])),
      includeInContextMenu: true,
      includeInPoseAs: true,
      fullShortDesc: () => S.Components.Gate.nimply
    },
    rnimply: {
      out: (ins) => LogicValue.invert(logicImply(ins[1], ins[0])),
      includeInContextMenu: false,
      includeInPoseAs: true,
      fullShortDesc: () => S.Components.Gate.rnimply
    },
    // observing only one input
    txa: {
      out: (ins) => ins[0],
      includeInContextMenu: true,
      includeInPoseAs: false,
      fullShortDesc: () => S.Components.Gate.txa
    },
    txb: {
      out: (ins) => ins[1],
      includeInContextMenu: false,
      includeInPoseAs: false,
      fullShortDesc: () => S.Components.Gate.txb
    },
    txna: {
      out: (ins) => LogicValue.invert(ins[0]),
      includeInContextMenu: false,
      includeInPoseAs: false,
      fullShortDesc: () => S.Components.Gate.txna
    },
    txnb: {
      out: (ins) => LogicValue.invert(ins[1]),
      includeInContextMenu: false,
      includeInPoseAs: false,
      fullShortDesc: () => S.Components.Gate.txnb
    }
  });
  var Gate2OnlyTypeRepr = t8.keyof(Gate2OnlyTypes.props);
  var GateNTypes = RichStringEnum.withProps()(__spreadValues(__spreadValues({}, Gate2toNTypes.props), Gate2OnlyTypes.props));
  var GateNTypeRepr = t8.union([
    Gate2toNTypeRepr,
    Gate2OnlyTypeRepr
  ]);
  function logicAnd(ins) {
    if (ins.includes(false)) {
      return false;
    }
    if (ins.includes(Unknown) || ins.includes(HighImpedance)) {
      return Unknown;
    }
    return true;
  }
  __name(logicAnd, "logicAnd");
  function logicOr(ins) {
    if (ins.includes(true)) {
      return true;
    }
    if (ins.includes(Unknown) || ins.includes(HighImpedance)) {
      return Unknown;
    }
    return false;
  }
  __name(logicOr, "logicOr");
  function logicXor(ins) {
    let count = 0;
    for (const in1 of ins) {
      if (in1 === true) {
        count++;
      } else if (in1 === Unknown || in1 === HighImpedance) {
        return Unknown;
      }
    }
    return count % 2 === 1;
  }
  __name(logicXor, "logicXor");
  function logicImply(in0, in1) {
    return logicOr([LogicValue.invert(in0), in1]);
  }
  __name(logicImply, "logicImply");

  // simulator/src/components/ALU.ts
  var ALUDef = defineParametrizedComponent("alu", true, true, {
    variantName: ({ bits, ext }) => `alu-${bits}${ext ? "e" : ""}`,
    idPrefix: "alu",
    button: { imgWidth: 50 },
    repr: {
      bits: typeOrUndefined(t9.number),
      ext: typeOrUndefined(t9.boolean),
      showOp: typeOrUndefined(t9.boolean)
    },
    valueDefaults: {
      showOp: true
    },
    params: {
      bits: param(4, [2, 4, 8, 16]),
      ext: paramBool()
      // has the extended opcode
    },
    validateParams: ({ bits, ext }) => ({
      numBits: bits,
      usesExtendedOpcode: ext
    }),
    size: ({ numBits }) => ({
      gridWidth: 7,
      gridHeight: 19 + Math.max(0, numBits - 8) * 2
    }),
    makeNodes: ({ numBits, usesExtendedOpcode, gridWidth, gridHeight }) => {
      const inputCenterY = 5 + Math.max(0, (numBits - 8) / 2);
      const outputX = gridWidth / 2 + 1;
      const bottom2 = (gridHeight + 1) / 2;
      const top2 = -bottom2;
      const topGroupBits = usesExtendedOpcode ? 5 : 3;
      const topGroup = groupHorizontal("n", 0, top2, topGroupBits, void 0, { leadLength: 20 });
      const cin = topGroup.pop();
      const opMode = topGroup.pop();
      return {
        ins: {
          A: groupVertical("w", -outputX, -inputCenterY, numBits),
          B: groupVertical("w", -outputX, inputCenterY, numBits),
          Op: topGroup,
          Mode: opMode,
          Cin: [cin[0], cin[1], "n", `Cin (${S.Components.ALU.InputCinDesc})`, { leadLength: 10 }]
        },
        outs: {
          S: groupVertical("e", outputX, 0, numBits),
          V: [0, bottom2, "s", "V (oVerflow)", { leadLength: 20 }],
          Z: [2, bottom2, "s", "Z (Zero)", { leadLength: 20 }],
          Cout: [-2, bottom2, "s", `Cout (${S.Components.ALU.OutputCoutDesc})`, { leadLength: 20 }]
        }
      };
    },
    initialValue: (saved, { numBits }) => {
      const false_ = false;
      return { s: ArrayFillWith(false_, numBits), v: false_, cout: false_ };
    }
  });
  var ALUOp = {
    shortName(op) {
      return S.Components.ALU[op][0];
    },
    fullName(op) {
      return S.Components.ALU[op][1];
    }
  };
  var ALUOps = [
    "A+B",
    "A-B",
    "A+1",
    "A-1",
    //0000  0001   0010   0011
    "-A",
    "B-A",
    "A*2",
    "A/2",
    //0100 0101   0110   0111
    "A|B",
    "A&B",
    "A|~B",
    "A&~B",
    //1000  1001   1010    1011
    "~A",
    "A^B",
    "A<<",
    "A>>"
    //1100 1101   1110   1111
  ];
  var ALUOpsReduced = ["A+B", "A-B", "A|B", "A&B"];
  var ALU = class extends ParametrizedComponentBase {
    constructor(parent, params, saved) {
      var _a;
      super(parent, ALUDef.with(params), saved);
      this.numBits = params.numBits;
      this.usesExtendedOpcode = params.usesExtendedOpcode;
      this._showOp = (_a = saved == null ? void 0 : saved.showOp) != null ? _a : ALUDef.aults.showOp;
    }
    toJSON() {
      return __spreadProps(__spreadValues({
        bits: this.numBits === ALUDef.aults.bits ? void 0 : this.numBits,
        ext: this.usesExtendedOpcode === ALUDef.aults.ext ? void 0 : this.usesExtendedOpcode
      }, this.toJSONBase()), {
        showOp: this._showOp !== ALUDef.aults.showOp ? this._showOp : void 0
      });
    }
    makeTooltip() {
      const op = this.op;
      const s = S.Components.ALU.tooltip;
      const opDesc = isUnknown(op) ? s.SomeUnknownOperation : s.ThisOperation + " " + ALUOp.fullName(op);
      return tooltipContent(s.title, mods(
        div(`${s.CurrentlyCarriesOut} ${opDesc}.`)
      ));
    }
    get op() {
      const opValues = this.inputValues(this.inputs.Op);
      opValues.push(this.inputs.Mode.value);
      const opIndex = displayValuesFromArray(opValues, false)[1];
      return isUnknown(opIndex) ? Unknown : (this.usesExtendedOpcode ? ALUOps : ALUOpsReduced)[opIndex];
    }
    doRecalcValue() {
      const op = this.op;
      if (isUnknown(op)) {
        return { s: ArrayFillWith(Unknown, this.numBits), v: Unknown, cout: Unknown };
      }
      const a2 = this.inputValues(this.inputs.A);
      const b2 = this.inputValues(this.inputs.B);
      const cin = this.inputs.Cin.value;
      return doALUOp(op, a2, b2, cin);
    }
    propagateValue(newValue) {
      this.outputValues(this.outputs.S, newValue.s);
      this.outputs.V.value = newValue.v;
      this.outputs.Z.value = allZeros(newValue.s);
      this.outputs.Cout.value = newValue.cout;
    }
    doDraw(g, ctx) {
      const bounds = this.bounds();
      const { left: left2, top: top2, right: right2, bottom: bottom2 } = bounds;
      const lowerTop = top2 + 2 * GRID_STEP;
      for (const input2 of this.inputs.A) {
        drawWireLineToComponent(g, input2);
      }
      for (const input2 of this.inputs.B) {
        drawWireLineToComponent(g, input2);
      }
      for (const input2 of this.inputs.Op) {
        drawWireLineToComponent(g, input2);
      }
      drawWireLineToComponent(g, this.inputs.Mode);
      drawWireLineToComponent(g, this.inputs.Cin);
      for (const output of this.outputs.S) {
        drawWireLineToComponent(g, output);
      }
      drawWireLineToComponent(g, this.outputs.Z);
      drawWireLineToComponent(g, this.outputs.V);
      drawWireLineToComponent(g, this.outputs.Cout);
      g.fillStyle = COLOR_BACKGROUND;
      g.lineWidth = 3;
      g.strokeStyle = ctx.borderColor;
      g.beginPath();
      g.moveTo(left2, top2);
      g.lineTo(right2, lowerTop);
      g.lineTo(right2, bottom2 - 2 * GRID_STEP);
      g.lineTo(left2, bottom2);
      g.lineTo(left2, this.posY + 1 * GRID_STEP);
      g.lineTo(left2 + 2 * GRID_STEP, this.posY);
      g.lineTo(left2, this.posY - 1 * GRID_STEP);
      g.closePath();
      g.fill();
      g.stroke();
      this.drawGroupBox(g, this.inputs.A.group, bounds);
      this.drawGroupBox(g, this.inputs.B.group, bounds);
      this.drawGroupBox(g, this.outputs.S.group, bounds);
      g.beginPath();
      const opGroupHeight = 8;
      const opGroupLeft = this.inputs.Mode.posXInParentTransform - 2;
      const opGroupRight = this.inputs.Op[0].posXInParentTransform + 2;
      const opGroupLeftTop = top2 + (this.usesExtendedOpcode ? 8 : 11);
      const opGroupRightTop = top2 + 18;
      g.moveTo(opGroupLeft, opGroupLeftTop);
      g.lineTo(opGroupRight, opGroupRightTop);
      g.lineTo(opGroupRight, opGroupRightTop + opGroupHeight);
      g.lineTo(opGroupLeft, opGroupLeftTop + opGroupHeight);
      g.closePath();
      g.fillStyle = COLOR_GROUP_SPAN;
      g.fill();
      ctx.inNonTransformedFrame((ctx2) => {
        g.fillStyle = COLOR_COMPONENT_INNER_LABELS;
        g.font = "11px sans-serif";
        const isVertical = Orientation.isVertical(this.orient);
        const carryHOffsetF = isVertical ? 0 : 1;
        drawLabel(ctx2, this.orient, "Z", "s", this.outputs.Z, bottom2 - 16);
        drawLabel(ctx2, this.orient, "V", "s", this.outputs.V.posXInParentTransform + carryHOffsetF * 2, bottom2 - 10, this.outputs.V);
        drawLabel(ctx2, this.orient, "Cout", "s", this.outputs.Cout.posXInParentTransform + carryHOffsetF * 4, bottom2 - 7, this.outputs.Cout);
        drawLabel(ctx2, this.orient, "Cin", "n", this.inputs.Cin.posXInParentTransform, top2 + 4, this.inputs.Cin);
        g.font = "bold 11px sans-serif";
        drawLabel(ctx2, this.orient, "Op", "n", (opGroupLeft + opGroupRight) / 2, top2 + 12, this.inputs.Op);
        g.font = "bold 12px sans-serif";
        drawLabel(ctx2, this.orient, "A", "w", left2, this.inputs.A);
        drawLabel(ctx2, this.orient, "B", "w", left2, this.inputs.B);
        drawLabel(ctx2, this.orient, "S", "e", right2, this.outputs.S);
        if (this._showOp) {
          const opName = isUnknown(this.op) ? "??" : ALUOp.shortName(this.op);
          const size = opName.length === 1 ? 25 : opName.length === 2 ? 17 : 13;
          g.font = `bold ${size}px sans-serif`;
          g.fillStyle = COLOR_COMPONENT_BORDER;
          g.textAlign = "center";
          fillTextVAlign(g, TextVAlign.middle, opName, ...ctx2.rotatePoint(this.posX + 5, this.posY));
        }
      });
    }
    doSetShowOp(showOp) {
      this._showOp = showOp;
      this.requestRedraw({ why: "show op changed" });
    }
    makeComponentSpecificContextMenuItems() {
      const s = S.Components.ALU.contextMenu;
      const icon = this._showOp ? "check" : "none";
      const toggleShowOpItem = MenuData.item(icon, s.toggleShowOp, () => {
        this.doSetShowOp(!this._showOp);
      });
      return [
        ["mid", toggleShowOpItem],
        ["mid", MenuData.sep()],
        this.makeChangeParamsContextMenuItem("inputs", S.Components.Generic.contextMenu.ParamNumBits, this.numBits, "bits"),
        this.makeChangeBooleanParamsContextMenuItem(s.ParamUseExtendedOpcode, this.usesExtendedOpcode, "ext"),
        ["mid", MenuData.sep()],
        ...this.makeForceOutputsContextMenuItem()
      ];
    }
  };
  __name(ALU, "ALU");
  ALUDef.impl = ALU;
  function allZeros(vals) {
    for (const v of vals) {
      if (isUnknown(v) || isHighImpedance(v)) {
        return Unknown;
      }
      if (v === true) {
        return false;
      }
    }
    return true;
  }
  __name(allZeros, "allZeros");
  function doALUOp(op, a2, b2, cin) {
    const numBits = a2.length;
    switch (op) {
      case "A+B":
        return doALUAdd(a2, b2, cin);
      case "A*2":
        return doALUAdd(a2, a2, cin);
      case "A+1":
        return doALUAdd(a2, [true, ...ArrayFillWith(false, numBits - 1)], cin);
      case "A/2":
        return doALUSub([...a2.slice(1), a2[numBits - 1]], ArrayFillWith(false, numBits), cin);
      case "A-1":
        return doALUSub(a2, [true, ...ArrayFillWith(false, numBits - 1)], cin);
      case "A-B":
        return doALUSub(a2, b2, cin);
      case "B-A":
        return doALUSub(b2, a2, cin);
      case "-A":
        return doALUSub(ArrayFillWith(false, numBits), a2, cin);
      default: {
        let cout = false;
        const s = (() => {
          switch (op) {
            case "A|B":
              return doALUBinOp("or", a2, b2);
            case "A&B":
              return doALUBinOp("and", a2, b2);
            case "A^B":
              return doALUBinOp("xor", a2, b2);
            case "A|~B":
              return doALUBinOp("or", a2, doALUNot(b2));
            case "A&~B":
              return doALUBinOp("and", a2, doALUNot(b2));
            case "~A":
              return doALUNot(a2);
            case "A>>":
              return [...a2.slice(1), cin];
            case "A<<":
              cout = a2[a2.length - 1];
              return [cin, ...a2.slice(0, a2.length - 1)];
          }
        })();
        return { s, v: false, cout };
      }
    }
  }
  __name(doALUOp, "doALUOp");
  function doALUAdd(a2, b2, cin) {
    const numBits = a2.length;
    const sum3bits = /* @__PURE__ */ __name((a3, b3, c) => {
      const asNumber = /* @__PURE__ */ __name((v2) => v2 === true ? 1 : 0, "asNumber");
      const numUnset = (isUnknown(a3) || isHighImpedance(a3) ? 1 : 0) + (isUnknown(b3) || isHighImpedance(a3) ? 1 : 0) + (isUnknown(c) || isHighImpedance(a3) ? 1 : 0);
      const sum = asNumber(a3) + asNumber(b3) + asNumber(c);
      if (numUnset === 0) {
        return [sum % 2 === 1, sum >= 2];
      }
      if (numUnset === 1 && sum >= 2) {
        return [Unknown, true];
      }
      return [Unknown, Unknown];
    }, "sum3bits");
    const s = ArrayFillWith(Unknown, numBits);
    const cins = ArrayFillWith(Unknown, numBits + 1);
    cins[0] = cin;
    for (let i2 = 0; i2 < numBits; i2++) {
      const [ss, cout2] = sum3bits(cins[i2], a2[i2], b2[i2]);
      s[i2] = ss;
      cins[i2 + 1] = cout2;
    }
    const cout = cins[numBits];
    const v = !isBoolean(cout) || !isBoolean(cins[numBits - 2]) ? Unknown : cout !== cins[numBits - 1];
    return { s, cout, v };
  }
  __name(doALUAdd, "doALUAdd");
  function doALUSub(a2, b2, cin) {
    const numBits = a2.length;
    const s = ArrayFillWith(Unknown, numBits);
    const toInt = /* @__PURE__ */ __name((vs) => {
      let s2 = 0;
      let col = 1;
      for (const v2 of vs) {
        if (isUnknown(v2)) {
          return void 0;
        }
        s2 += Number(v2) * col;
        col *= 2;
      }
      return s2;
    }, "toInt");
    const aInt = toInt(a2);
    const bInt = toInt(b2);
    let cout = Unknown;
    let v = Unknown;
    if (aInt !== void 0 && bInt !== void 0 && isBoolean(cin)) {
      let yInt = aInt - bInt - (cin ? 1 : 0);
      if (yInt < 0) {
        yInt += Math.pow(2, numBits);
      }
      const yBinStr = (yInt >>> 0).toString(2).padStart(numBits, "0");
      const lastIdx = numBits - 1;
      for (let i2 = 0; i2 < numBits; i2++) {
        s[i2] = yBinStr[lastIdx - i2] === "1";
      }
      cout = bInt > aInt - (cin ? 1 : 0);
      const aNeg = a2[lastIdx] === true;
      const bNeg = b2[lastIdx] === true;
      const yNeg = s[lastIdx] === true;
      v = aNeg !== bNeg && aNeg !== yNeg;
    }
    return { s, cout, v };
  }
  __name(doALUSub, "doALUSub");
  function doALUNot(a2) {
    const not = Gate1Types.props.not.out;
    return ArrayFillUsing((i2) => not([a2[i2]]), a2.length);
  }
  __name(doALUNot, "doALUNot");
  function doALUBinOp(op, a2, b2) {
    const func = Gate2toNTypes.props[op].out;
    return ArrayFillUsing((i2) => func([a2[i2], b2[i2]]), a2.length);
  }
  __name(doALUBinOp, "doALUBinOp");

  // simulator/src/components/Adder.ts
  var AdderDef = defineComponent("adder", {
    idPrefix: "adder",
    button: { imgWidth: 50 },
    valueDefaults: {},
    size: { gridWidth: 7, gridHeight: 5 },
    makeNodes: () => {
      const s = S.Components.Generic;
      return {
        ins: {
          A: [-2, -4, "n", "A", { hasTriangle: true }],
          B: [2, -4, "n", "B", { hasTriangle: true }],
          Cin: [5, 0, "e", s.InputCarryInDesc, { hasTriangle: true }]
        },
        outs: {
          S: [0, 4, "s", s.OutputSumDesc, { hasTriangle: true }],
          Cout: [-5, 0, "w", s.OutputCarryOutDesc, { hasTriangle: true }]
        }
      };
    },
    initialValue: () => ({ s: false, cout: false })
  });
  var Adder = class extends ComponentBase {
    constructor(parent, saved) {
      super(parent, AdderDef, saved);
    }
    toJSON() {
      return this.toJSONBase();
    }
    makeTooltip() {
      const s = S.Components.Adder.tooltip;
      return tooltipContent(s.title, mods(
        div(s.desc)
      ));
    }
    doRecalcValue() {
      const a2 = this.inputs.A.value;
      const b2 = this.inputs.B.value;
      const cIn = this.inputs.Cin.value;
      if (isUnknown(a2) || isUnknown(b2) || isUnknown(cIn) || isHighImpedance(a2) || isHighImpedance(b2) || isHighImpedance(cIn)) {
        return { s: Unknown, cout: Unknown };
      }
      const sum = +a2 + +b2 + +cIn;
      switch (sum) {
        case 0:
          return { s: false, cout: false };
        case 1:
          return { s: true, cout: false };
        case 2:
          return { s: false, cout: true };
        case 3:
          return { s: true, cout: true };
        default:
          console.log("ERROR: sum of adder is > 3");
          return { s: false, cout: false };
      }
    }
    propagateValue(newValue) {
      this.outputs.S.value = newValue.s;
      this.outputs.Cout.value = newValue.cout;
    }
    doDraw(g, ctx) {
      this.doDrawDefault(g, ctx, () => {
        g.fillStyle = COLOR_COMPONENT_BORDER;
        g.font = "bold 30px sans-serif";
        g.textAlign = "center";
        fillTextVAlign(g, TextVAlign.middle, "+", this.posX, this.posY - 2);
      });
    }
    makeComponentSpecificContextMenuItems() {
      return this.makeForceOutputsContextMenuItem();
    }
  };
  __name(Adder, "Adder");
  AdderDef.impl = Adder;

  // simulator/src/components/AdderArray.ts
  var t10 = __toESM(require_lib());
  var AdderArrayDef = defineParametrizedComponent("adder-array", true, true, {
    variantName: ({ bits }) => `adder-array-${bits}`,
    idPrefix: "adder",
    button: { imgWidth: 50 },
    repr: {
      bits: typeOrUndefined(t10.number)
    },
    valueDefaults: {},
    params: {
      bits: param(4, [2, 4, 8, 16])
    },
    validateParams: ({ bits }) => ({
      numBits: bits
    }),
    size: ({ numBits }) => ({
      gridWidth: 4,
      // constant
      gridHeight: ALUDef.size({ numBits, usesExtendedOpcode: false }).gridHeight
      // mimic ALU
    }),
    makeNodes: ({ numBits, gridHeight }) => {
      const inputCenterY = 5 + Math.max(0, (numBits - 8) / 2);
      const coutY = Math.floor(gridHeight / 2) + 1;
      const cinY = -coutY;
      return {
        ins: {
          A: groupVertical("w", -3, -inputCenterY, numBits),
          B: groupVertical("w", -3, inputCenterY, numBits),
          Cin: [0, cinY, "n"]
        },
        outs: {
          S: groupVertical("e", 3, 0, numBits),
          Cout: [0, coutY, "s"]
        }
      };
    },
    initialValue: (saved, { numBits }) => ({
      s: ArrayFillWith(false, numBits),
      cout: false
    })
  });
  var AdderArray = class extends ParametrizedComponentBase {
    constructor(parent, params, saved) {
      super(parent, AdderArrayDef.with(params), saved);
      this.numBits = params.numBits;
    }
    toJSON() {
      return __spreadProps(__spreadValues({}, this.toJSONBase()), {
        bits: this.numBits === AdderArrayDef.aults.bits ? void 0 : this.numBits
      });
    }
    makeTooltip() {
      const s = S.Components.AdderArray.tooltip;
      return tooltipContent(s.title.expand({ numBits: this.numBits }), mods(
        div(s.desc)
        // TODO more info
      ));
    }
    doRecalcValue() {
      const a2 = this.inputValues(this.inputs.A);
      const b2 = this.inputValues(this.inputs.B);
      const cin = this.inputs.Cin.value;
      return doALUAdd(a2, b2, cin);
    }
    propagateValue(newValue) {
      this.outputValues(this.outputs.S, newValue.s);
      this.outputs.Cout.value = newValue.cout;
    }
    doDraw(g, ctx) {
      this.doDrawDefault(g, ctx, (ctx2) => {
        g.font = `bold 25px sans-serif`;
        g.fillStyle = COLOR_COMPONENT_BORDER;
        g.textAlign = "center";
        fillTextVAlign(g, TextVAlign.middle, "+", ...ctx2.rotatePoint(this.posX - 4, this.posY - 2));
      });
    }
    makeComponentSpecificContextMenuItems() {
      return [
        this.makeChangeParamsContextMenuItem("inputs", S.Components.Generic.contextMenu.ParamNumBits, this.numBits, "bits"),
        ...this.makeForceOutputsContextMenuItem(true)
      ];
    }
  };
  __name(AdderArray, "AdderArray");
  AdderArrayDef.impl = AdderArray;

  // simulator/src/components/Clock.ts
  var t12 = __toESM(require_lib());

  // simulator/src/components/Input.ts
  var t11 = __toESM(require_lib());
  var InputBase = class extends ParametrizedComponentBase {
    constructor(parent, SubclassDef, saved) {
      var _a;
      super(parent, SubclassDef, saved);
      this._name = (_a = saved == null ? void 0 : saved.name) != null ? _a : void 0;
    }
    toJSONBase() {
      return __spreadProps(__spreadValues({}, super.toJSONBase()), {
        name: this._name
      });
    }
    isOver(x, y) {
      if (this.numBits === 1) {
        return distSquared(x, y, this.posX, this.posY) < __pow(INPUT_OUTPUT_DIAMETER / 2, 2);
      }
      return inRect(this.posX, this.posY, this.width, this.height, x, y);
    }
    get allowsForcedOutputs() {
      return false;
    }
    get name() {
      return this._name;
    }
    doRecalcValue() {
      return this.value;
    }
    propagateValue(newValue) {
      this.outputValues(this.outputs.Out, newValue);
    }
    shouldDrawBorder() {
      return true;
    }
    doDraw(g, ctx) {
      if (this.numBits === 1) {
        this.doDrawSingle(g, ctx, this.outputs.Out[0]);
      } else {
        this.doDrawMulti(g, ctx, this.outputs.Out);
      }
    }
    doDrawSingle(g, ctx, output) {
      drawWireLineToComponent(g, output);
      const displayValue = this.parent.editor.options.hideInputColors ? Unknown : output.value;
      const shouldDrawBorder = this.shouldDrawBorder();
      if (shouldDrawBorder) {
        const drawMouseOver = ctx.isMouseOver && this.parent.mode !== 0 /* STATIC */;
        if (drawMouseOver) {
          g.strokeStyle = ctx.borderColor;
          g.fillStyle = ctx.borderColor;
        } else {
          g.strokeStyle = COLOR_COMPONENT_BORDER;
          g.fillStyle = COLOR_COMPONENT_BORDER;
        }
        g.lineWidth = 3;
        g.beginPath();
        const triangleLeft = this.posX + INPUT_OUTPUT_DIAMETER / 2 - 1;
        const triangleRight = this.posX + INPUT_OUTPUT_DIAMETER / 2 + 5;
        const triangleVOffset = 6.75;
        triangle(
          g,
          triangleLeft,
          this.posY + triangleVOffset,
          triangleRight,
          this.posY,
          triangleLeft,
          this.posY - triangleVOffset
        );
        g.lineWidth = 2;
        g.fill();
        g.stroke();
        g.fillStyle = colorForLogicValue(displayValue);
        g.lineWidth = 4;
        g.beginPath();
        circle(g, this.posX, this.posY, INPUT_OUTPUT_DIAMETER);
        g.fill();
        g.stroke();
      }
      ctx.inNonTransformedFrame((ctx2) => {
        if (this._name !== void 0) {
          drawComponentName(g, ctx2, this._name, toLogicValueRepr(displayValue), this, false);
        }
        const forcedFillStyle = !shouldDrawBorder ? g.fillStyle = COLOR_COMPONENT_BORDER : void 0;
        drawValueTextCentered(g, displayValue, this, { fillStyle: forcedFillStyle });
      });
    }
    doDrawMulti(g, ctx, outputs) {
      const bounds = this.bounds();
      const { left: left2, top: top2, width } = bounds;
      const outline = bounds.outline(g);
      g.fillStyle = COLOR_BACKGROUND;
      g.fill(outline);
      for (const output of outputs) {
        drawWireLineToComponent(g, output);
      }
      const displayValues = this.parent.editor.options.hideInputColors ? ArrayFillWith(Unknown, this.numBits) : this.value;
      const drawMouseOver = ctx.isMouseOver && this.parent.mode !== 0 /* STATIC */;
      g.strokeStyle = drawMouseOver ? ctx.borderColor : COLOR_COMPONENT_BORDER;
      g.lineWidth = 1;
      const cellHeight = useCompact(this.numBits) ? GRID_STEP : 2 * GRID_STEP;
      for (let i2 = 0; i2 < this.numBits; i2++) {
        const y = top2 + i2 * cellHeight;
        g.fillStyle = colorForLogicValue(displayValues[i2]);
        g.beginPath();
        g.rect(left2, y, width, cellHeight);
        g.fill();
        g.stroke();
      }
      g.lineWidth = 3;
      g.stroke(outline);
      ctx.inNonTransformedFrame((ctx2) => {
        if (this._name !== void 0) {
          const valueString = displayValues.map(toLogicValueRepr).reverse().join("");
          drawComponentName(g, ctx2, this._name, valueString, this, false);
        }
        for (let i2 = 0; i2 < this.numBits; i2++) {
          const y = top2 + cellHeight / 2 + i2 * cellHeight;
          drawValueText(g, displayValues[i2], ...ctx2.rotatePoint(this.posX, y), { small: useCompact(this.numBits) });
        }
      });
    }
    autoConnected(newLinks) {
      if (newLinks.length !== 1) {
        return;
      }
      const [outNode, comp, inNode] = newLinks[0];
      if (inNode instanceof NodeIn) {
        if (inNode.prefersSpike) {
          this.doSetIsPushButton(true);
        }
        if (this._name === void 0 && !isTrivialNodeName(inNode.shortName)) {
          this.doSetName(inNode.shortName);
        }
      }
      if (outNode.orient !== "e") {
        return;
      }
      switch (Orientation.add(comp.orient, inNode.orient)) {
        case "w":
          return;
        case "e":
          this.doSetOrient("w");
          this.setPosition(this.posX + GRID_STEP * 6, this.posY, false);
          return;
        case "s":
          this.doSetOrient("n");
          this.setPosition(this.posX + GRID_STEP * 3, this.posY + GRID_STEP * 3, false);
          return;
        case "n":
          this.doSetOrient("s");
          this.setPosition(this.posX + GRID_STEP * 3, this.posY - GRID_STEP * 3, false);
          return;
      }
    }
    doSetIsPushButton(__isPushButton) {
    }
    doSetName(name2) {
      this._name = name2;
      this.requestRedraw({ why: "name changed" });
    }
    makeComponentSpecificContextMenuItems() {
      return [
        ["mid", this.makeSetNameContextMenuItem(this._name, this.doSetName.bind(this))]
      ];
    }
    keyDown(e) {
      if (e.key === "Enter" && !e.altKey) {
        this.runSetNameDialog(this._name, this.doSetName.bind(this));
      } else {
        super.keyDown(e);
      }
    }
  };
  __name(InputBase, "InputBase");
  var InputDef = defineParametrizedComponent(ComponentTypeInput, false, true, {
    variantName: ({ bits }) => `in-${bits}`,
    idPrefix: "in",
    button: { imgWidth: 32 },
    repr: {
      bits: typeOrUndefined(t11.number),
      val: typeOrUndefined(InputOutputValueRepr),
      isPushButton: typeOrUndefined(t11.boolean),
      isConstant: typeOrUndefined(t11.boolean),
      name: ComponentNameRepr
    },
    valueDefaults: {
      isPushButton: false,
      isConstant: false
    },
    params: {
      bits: param(1, [1, 2, 3, 4, 5, 6, 7, 8, 12, 16, 24, 32])
    },
    validateParams: ({ bits }) => ({
      numBits: bits
    }),
    size: ({ numBits }) => {
      if (numBits === 1) {
        const d = INPUT_OUTPUT_DIAMETER / GRID_STEP;
        return { gridWidth: d, gridHeight: d };
      }
      return {
        gridWidth: 2,
        gridHeight: useCompact(numBits) ? numBits : 2 * numBits
      };
    },
    makeNodes: ({ numBits }) => ({
      outs: {
        Out: groupVertical("e", numBits === 1 ? 3 : 2, 0, numBits, void 0, { hasTriangle: numBits !== 1 })
      }
    }),
    initialValue: (saved, { numBits }) => {
      return valuesFromReprForInput(saved == null ? void 0 : saved.val, numBits);
    }
  });
  var Input = class extends InputBase {
    constructor(parent, params, saved) {
      var _a, _b;
      super(parent, InputDef.with(params), saved);
      this.isCustomComponentInput = false;
      this.numBits = params.numBits;
      this._isPushButton = (_a = saved == null ? void 0 : saved.isPushButton) != null ? _a : InputDef.aults.isPushButton;
      this._isConstant = (_b = saved == null ? void 0 : saved.isConstant) != null ? _b : InputDef.aults.isConstant;
    }
    toJSON() {
      return __spreadProps(__spreadValues({}, this.toJSONBase()), {
        bits: this.numBits === InputDef.aults.bits ? void 0 : this.numBits,
        val: this.contentRepr(true),
        isPushButton: this._isPushButton !== InputDef.aults.isPushButton ? this._isPushButton : void 0,
        isConstant: this._isConstant !== InputDef.aults.isConstant ? this._isConstant : void 0
      });
    }
    get isConstant() {
      return this._isConstant;
    }
    contentRepr(undefinedIfTrivial) {
      return reprForLogicValues(this.value, undefinedIfTrivial);
    }
    cursorWhenMouseover(e) {
      var _a, _b;
      const mode = this.parent.mode;
      if (mode === 0 /* STATIC */) {
        return "not-allowed";
      }
      if (((_a = e == null ? void 0 : e.ctrlKey) != null ? _a : false) && mode >= 2 /* CONNECT */) {
        return "context-menu";
      }
      if (((_b = e == null ? void 0 : e.altKey) != null ? _b : false) && mode >= 3 /* DESIGN */) {
        return "copy";
      }
      if (this.isCustomComponentInput) {
        return "grab";
      }
      if (this._isConstant) {
        if (mode >= 3 /* DESIGN */ && !this.lockPos) {
          return "grab";
        } else {
          return void 0;
        }
      }
      return "pointer";
    }
    makeTooltip() {
      const s = S.Components.Input.tooltip;
      return tooltipContent(void 0, mods(s.title.expand({ numBits: this.numBits })));
    }
    get isLinkedToSomeClock() {
      return this.outputs._all.some((out) => out.outgoingWires.some((w) => w.endNode.isClock));
    }
    get isPushButton() {
      return this._isPushButton;
    }
    shouldDrawBorder() {
      return !this._isConstant;
    }
    mouseClicked(e) {
      let result;
      if ((result = super.mouseClicked(e)).isChange) {
        return result;
      }
      if (this.parent.mode === 0 /* STATIC */ || this._isPushButton || this._isConstant) {
        return InteractionResult.NoChange;
      }
      if (this.isCustomComponentInput) {
        this.parent.editor.showMessage(S.Components.Input.contextMenu.InputSetFromOutside);
        return InteractionResult.NoChange;
      }
      const i2 = this.clickedBitIndex(e);
      if (i2 === -1) {
        return InteractionResult.SimpleChange;
      }
      const altKey = e.altKey;
      const doChange = /* @__PURE__ */ __name(() => {
        this.doSetValueChangingBit(i2, nextValue(this.value[i2], this.parent.mode, altKey));
        return true;
      }, "doChange");
      doChange();
      return InteractionResult.RepeatableChange(doChange);
    }
    mouseDown(e) {
      this.trySetPushButtonBit(true, e);
      return super.mouseDown(e);
    }
    mouseUp(e) {
      const result = super.mouseUp(e);
      this.trySetPushButtonBit(false, e);
      return result;
    }
    clickedBitIndex(e) {
      const h = this.unrotatedHeight;
      const y = this.parent.editor.offsetXYForComponent(e, this)[1] - this.posY + h / 2;
      const i2 = Math.floor(y * this.numBits / h);
      if (i2 >= 0 && i2 < this.numBits) {
        return i2;
      }
      return -1;
    }
    trySetPushButtonBit(v, e) {
      let i2;
      if (this.parent.mode === 0 /* STATIC */ || !this._isPushButton || this._isConstant || !this.parent.editor.eventMgr.currentSelectionEmpty() || (i2 = this.clickedBitIndex(e)) === -1) {
        return;
      }
      if (this.isCustomComponentInput) {
        if (v !== false) {
          this.parent.editor.showMessage(S.Components.Input.contextMenu.InputSetFromOutside);
        }
        return;
      }
      this.doSetValueChangingBit(i2, v);
    }
    doSetValueChangingBit(i2, v) {
      const newValues = [...this.value];
      newValues[i2] = v;
      this.doSetValue(newValues);
    }
    setValue(values) {
      if (values.length !== this.numBits) {
        console.warn(`Expected ${this.numBits} values, got ${values.length} for input ${this.ref}`);
        return;
      }
      this.doSetValue(values);
    }
    doSetIsPushButton(isPushButton) {
      this._isPushButton = isPushButton;
      if (isPushButton) {
        this.doSetValue(ArrayFillWith(false, this.numBits));
      }
    }
    doSetIsConstant(isConstant) {
      this._isConstant = isConstant;
      this.requestRedraw({ why: "constant changed" });
    }
    makeComponentSpecificContextMenuItems() {
      const s = S.Components.Input.contextMenu;
      const makeItemBehaveAs = /* @__PURE__ */ __name((desc, value) => {
        const isCurrent = this._isPushButton === value;
        const icon = isCurrent ? "check" : "none";
        const action = isCurrent ? () => void 0 : () => this.doSetIsPushButton(value);
        return MenuData.item(icon, desc, action);
      }, "makeItemBehaveAs");
      const newItems = [
        ["mid", makeItemBehaveAs(s.ToggleButton, false)],
        ["mid", makeItemBehaveAs(s.PushButton, true)],
        ["mid", MenuData.sep()],
        this.makeChangeParamsContextMenuItem("outputs", S.Components.Generic.contextMenu.ParamNumBits, this.numBits, "bits"),
        ["mid", MenuData.sep()]
      ];
      if (this.numBits === 1) {
        const makeToggleConstantItem = /* @__PURE__ */ __name(() => {
          const icon = this._isConstant ? "check" : "none";
          const action = /* @__PURE__ */ __name(() => this.doSetIsConstant(!this._isConstant), "action");
          return MenuData.item(icon, s.LockValue + ` (${toLogicValueRepr(this.value[0])})`, action);
        }, "makeToggleConstantItem");
        const replaceWithClockItem = MenuData.item("timer", s.ReplaceWithClock, () => {
          this.replaceWithComponent(ClockDef.make(this.parent));
        });
        newItems.push(
          ["mid", makeToggleConstantItem()],
          ["mid", MenuData.sep()],
          ["mid", replaceWithClockItem],
          ["mid", MenuData.sep()]
        );
      }
      newItems.push(...super.makeComponentSpecificContextMenuItems());
      return newItems;
    }
  };
  __name(Input, "Input");
  InputDef.impl = Input;
  function nextValue(value, mode, altKey) {
    switch (value) {
      case true:
        return mode >= 4 /* FULL */ && altKey ? Unknown : false;
      case false:
        return mode >= 4 /* FULL */ && altKey ? Unknown : true;
      case Unknown:
        return mode >= 4 /* FULL */ ? altKey ? HighImpedance : false : Unknown;
      case HighImpedance:
        return mode >= 4 /* FULL */ ? altKey ? Unknown : false : HighImpedance;
    }
  }
  __name(nextValue, "nextValue");

  // simulator/src/components/Clock.ts
  var ClockDef = defineComponent("clock", {
    idPrefix: "clock",
    button: { imgWidth: 50 },
    repr: {
      name: ComponentNameRepr,
      period: t12.number,
      dutycycle: typeOrUndefined(t12.number),
      phase: typeOrUndefined(t12.number),
      showLabel: typeOrUndefined(t12.boolean)
    },
    valueDefaults: {
      period: 2e3,
      dutycycle: 50,
      phase: 0,
      showLabel: true
    },
    size: { gridWidth: 2, gridHeight: 2 },
    // "overridden" by superclass
    makeNodes: () => ({
      outs: {
        // we don't strictly need a group, but we use it
        // for compatibility with InputBase
        Out: [[3, 0, "e"]]
      }
    }),
    initialValue: () => [false]
  });
  var Clock = class extends InputBase {
    constructor(parent, saved) {
      var _a, _b;
      super(parent, [ClockDef, void 0], saved);
      this._period = (_a = saved == null ? void 0 : saved.period) != null ? _a : ClockDef.aults.period;
      this._dutycycle = (saved == null ? void 0 : saved.dutycycle) !== void 0 ? saved.dutycycle % 100 : ClockDef.aults.dutycycle;
      this._phase = (saved == null ? void 0 : saved.phase) !== void 0 ? saved.phase % this._period : ClockDef.aults.phase;
      this._showLabel = (_b = saved == null ? void 0 : saved.showLabel) != null ? _b : ClockDef.aults.showLabel;
      this.tickCallback();
    }
    get numBits() {
      return 1;
    }
    toJSON() {
      return __spreadProps(__spreadValues({}, this.toJSONBase()), {
        period: this._period,
        dutycycle: this._dutycycle === ClockDef.aults.dutycycle ? void 0 : this._dutycycle,
        phase: this._phase === ClockDef.aults.phase ? void 0 : this._phase,
        showLabel: this._showLabel === ClockDef.aults.showLabel ? void 0 : this._showLabel
      });
    }
    toStringDetails() {
      return `period=${this._period} duty=${this._dutycycle} phase=${this._phase}`;
    }
    makeTooltip() {
      const s = S.Components.Clock.tooltip;
      return tooltipContent(
        s.title,
        mods(
          s.period[0] + this._period + s.period[1],
          br,
          s.dutycycle[0] + this._dutycycle + s.dutycycle[1],
          this._phase === 0 ? emptyMod : mods(br, s.phase[0] + this._phase + s.phase[1])
        )
      );
    }
    currentClockValue(logicalTime) {
      const myTime = logicalTime - this._phase;
      let timeOverPeriod = myTime % this._period;
      if (timeOverPeriod < 0) {
        timeOverPeriod += this._period;
      }
      const onDuration = this._period * this._dutycycle / 100;
      const offDuration = this._period - onDuration;
      let value;
      let timeOverLastTick;
      if (timeOverPeriod < onDuration) {
        value = true;
        timeOverLastTick = timeOverPeriod;
      } else {
        value = false;
        timeOverLastTick = timeOverPeriod - onDuration;
      }
      const lastTick = logicalTime - timeOverLastTick;
      const nextTick = lastTick + (value ? onDuration : offDuration);
      return [value, nextTick];
    }
    tickCallback() {
      const timeline = this.parent.editor.timeline;
      const [value, nextTick] = this.currentClockValue(timeline.logicalTime());
      this.doSetValue([value]);
      if (this.state !== 2 /* DEAD */) {
        const s = S.Components.Clock.timeline;
        const desc = value ? s.NextFallingEdge : s.NextRisingEdge;
        timeline.scheduleAt(nextTick, () => {
          this.tickCallback();
        }, desc, true);
      }
    }
    doDraw(g, ctx) {
      super.doDraw(g, ctx);
      if (!this._showLabel) {
        return;
      }
      ctx.inNonTransformedFrame(() => {
        const w = 40;
        const h = 10;
        const offsetY = this.orient === "s" ? -36 : 26;
        g.strokeStyle = COLOR_COMPONENT_BORDER;
        g.lineWidth = 1;
        const left2 = this.posX - w / 2;
        const mid1 = left2 + w * this._phase / this._period;
        const mid2 = mid1 + w * this._dutycycle / 100;
        const right2 = this.posX + w / 2;
        const bottom2 = this.posY + offsetY + h / 2;
        const top2 = this.posY + offsetY - h / 2;
        g.beginPath();
        g.moveTo(left2, bottom2);
        g.lineTo(mid1, bottom2);
        g.lineTo(mid1, top2);
        g.lineTo(mid2, top2);
        g.lineTo(mid2, bottom2);
        g.lineTo(right2, bottom2);
        g.stroke();
        g.fillStyle = COLOR_COMPONENT_BORDER;
        g.font = "10px sans-serif";
        const periodStr = this._period >= 1e3 ? this._period / 1e3 + " s" : this._period + " ms";
        g.textAlign = "center";
        fillTextVAlign(g, TextVAlign.middle, periodStr, this.posX, bottom2 + 8);
      });
    }
    doSetPeriod(period) {
      this._period = period;
      this.requestRedraw({ why: "period changed", invalidateTests: true });
    }
    makeComponentSpecificContextMenuItems() {
      const s = S.Components.Clock.contextMenu;
      const periodPresets = [
        [100, "100 ms (10 Hz)"],
        [250, "250 ms (4 Hz)"],
        [500, "500 ms (2 Hz)"],
        [1e3, "1 s (1 Hz)"],
        [2e3, "2 s (0.5 Hz)"],
        [4e3, "4 s (0.25 Hz)"],
        [8e3, "8 s (0.125 Hz)"],
        [16e3, "16 s (0.0625 Hz)"]
      ];
      let matchesSomePreset = false;
      const makeItemSetPeriod = /* @__PURE__ */ __name((data2) => {
        const [period, desc] = data2;
        const isCurrent = this._period === period;
        matchesSomePreset = matchesSomePreset || isCurrent;
        const icon = isCurrent ? "check" : "none";
        return MenuData.item(icon, desc, () => this.doSetPeriod(period));
      }, "makeItemSetPeriod");
      const presetPeriodItems = periodPresets.map(makeItemSetPeriod);
      const customPeriodItem = MenuData.item(matchesSomePreset ? "none" : "check", s.CustomPeriod + (matchesSomePreset ? "\u2026" : " (" + this._period + " ms, " + Math.round(1e6 / this._period) / 1e3 + " Hz)\u2026"), () => this.runSetPeriodDialog());
      const replaceWithInputItem = MenuData.item("replace", s.ReplaceWithInput, () => {
        this.replaceWithComponent(InputDef.make(this.parent, { bits: 1 }));
      });
      return [
        ...super.makeComponentSpecificContextMenuItems(),
        ["mid", MenuData.sep()],
        ["mid", MenuData.submenu("timer", s.Period, [...presetPeriodItems, MenuData.sep(), customPeriodItem])],
        ["mid", MenuData.sep()],
        ["mid", replaceWithInputItem]
      ];
    }
    runSetPeriodDialog() {
      const s = S.Components.Clock.contextMenu;
      const newPeriodStr = window.prompt(s.SetPeriodMillis, String(this._period));
      if (newPeriodStr === null || newPeriodStr.length === 0) {
        return;
      }
      const newPeriod = parseInt(newPeriodStr);
      if (isNaN(newPeriod) || newPeriod < 1) {
        window.alert(s.InvalidPeriod);
        this.runSetPeriodDialog();
        return;
      }
      this.doSetPeriod(newPeriod);
    }
  };
  __name(Clock, "Clock");
  ClockDef.impl = Clock;

  // simulator/src/components/Comparator.ts
  var ComparatorDef = defineComponent("comp", {
    idPrefix: "comp",
    button: { imgWidth: 50 },
    valueDefaults: {},
    size: { gridWidth: 5, gridHeight: 7 },
    makeNodes: () => ({
      ins: {
        A: [-4, 2, "w", "A", { hasTriangle: true }],
        B: [-4, -2, "w", "B", { hasTriangle: true }],
        E: [0, 5, "s", "E", { hasTriangle: true }]
      },
      outs: {
        G: [4, 0, "e", ">", { hasTriangle: true, labelName: ">" }],
        Eq: [0, -5, "n", "=", { hasTriangle: true, labelName: "=" }]
      }
    }),
    initialValue: () => ({
      g: false,
      eq: false
    })
  });
  var Comparator = class extends ComponentBase {
    constructor(parent, saved) {
      super(parent, ComparatorDef, saved);
    }
    toJSON() {
      return this.toJSONBase();
    }
    makeTooltip() {
      const s = S.Components.Comparator.tooltip;
      return tooltipContent(s.title, mods(
        div(s.desc)
      ));
    }
    doRecalcValue() {
      const a2 = this.inputs.A.value;
      const b2 = this.inputs.B.value;
      const e = this.inputs.E.value;
      if (isUnknown(a2) || isUnknown(b2) || isUnknown(e) || isHighImpedance(a2) || isHighImpedance(b2) || isHighImpedance(e)) {
        return { g: Unknown, eq: Unknown };
      }
      if (+e === 0) {
        return { g: false, eq: false };
      }
      const g = +a2 > +b2;
      const eq = +a2 === +b2;
      return { g, eq };
    }
    propagateValue(newValue) {
      this.outputs.G.value = newValue.g;
      this.outputs.Eq.value = newValue.eq;
    }
    doDraw(g, ctx) {
      this.doDrawDefault(g, ctx, () => {
        g.fillStyle = COLOR_COMPONENT_BORDER;
        g.font = "bold 11px sans-serif";
        g.textAlign = "center";
        fillTextVAlign(g, TextVAlign.middle, "CMP", this.posX, this.posY);
      });
    }
    makeComponentSpecificContextMenuItems() {
      return this.makeForceOutputsContextMenuItem();
    }
  };
  __name(Comparator, "Comparator");
  ComparatorDef.impl = Comparator;

  // simulator/src/components/ControlledInverter.ts
  var t13 = __toESM(require_lib());
  var ControlledInverterDef = defineParametrizedComponent("cnot-array", true, true, {
    variantName: ({ bits, bottom: bottom2 }) => `cnot-array-${bits}${bottom2 ? "b" : ""}`,
    idPrefix: "cnot",
    button: { imgWidth: 50 },
    repr: {
      bits: typeOrUndefined(t13.number),
      bottom: typeOrUndefined(t13.boolean)
    },
    valueDefaults: {},
    params: {
      bits: param(4, [2, 4, 8, 16]),
      bottom: paramBool()
    },
    validateParams: ({ bits, bottom: bottom2 }) => ({
      numBits: bits,
      controlPinsAtBottom: bottom2
    }),
    size: ({ numBits }) => ({
      gridWidth: 4,
      gridHeight: 8 + Math.max(0, numBits - 8)
    }),
    makeNodes: ({ numBits, controlPinsAtBottom, gridHeight }) => ({
      ins: {
        In: groupVertical("w", -3, 0, numBits),
        S: [
          0,
          -(gridHeight / 2 + 1) * (controlPinsAtBottom ? -1 : 1),
          controlPinsAtBottom ? "s" : "n"
        ]
      },
      outs: {
        Out: groupVertical("e", 3, 0, numBits)
      }
    }),
    initialValue: (saved, { numBits }) => ArrayFillWith(false, numBits)
  });
  var ControlledInverter = class extends ParametrizedComponentBase {
    constructor(parent, params, saved) {
      super(parent, ControlledInverterDef.with(params), saved);
      this.numBits = params.numBits;
      this.controlPinsAtBottom = params.controlPinsAtBottom;
    }
    toJSON() {
      return __spreadProps(__spreadValues({}, this.toJSONBase()), {
        bits: this.numBits === ControlledInverterDef.aults.bits ? void 0 : this.numBits,
        bottom: this.controlPinsAtBottom === ControlledInverterDef.aults.bottom ? void 0 : this.controlPinsAtBottom
      });
    }
    makeTooltip() {
      const s = S.Components.ControlledInverter.tooltip;
      return tooltipContent(s.title, mods(
        div(s.desc)
      ));
    }
    doRecalcValue() {
      const input2 = this.inputValues(this.inputs.In);
      const switch_ = this.inputs.S.value;
      if (isUnknown(switch_) || isHighImpedance(switch_)) {
        return ArrayFillWith(Unknown, this.numBits);
      }
      if (!switch_) {
        return input2;
      }
      return input2.map(LogicValue.invert);
    }
    propagateValue(newValue) {
      this.outputValues(this.outputs.Out, newValue);
    }
    doDraw(g, ctx) {
      this.doDrawDefault(g, ctx, {
        skipLabels: true,
        drawInside: ({ top: top2, bottom: bottom2, left: left2, right: right2 }) => {
          const invert = this.inputs.S.value;
          g.lineWidth = 2;
          g.strokeStyle = colorForLogicValue(invert);
          g.beginPath();
          if (this.controlPinsAtBottom) {
            g.moveTo(this.posX, bottom2);
            g.lineTo(this.posX, this.posY + 4);
          } else {
            g.moveTo(this.posX, top2);
            g.lineTo(this.posX, this.posY - 4);
          }
          g.stroke();
          g.strokeStyle = invert === true ? COLOR_COMPONENT_BORDER : COLOR_UNKNOWN;
          g.beginPath();
          g.moveTo(left2 + 12, this.posY - 8);
          g.lineTo(right2 - 13, this.posY);
          g.lineTo(left2 + 12, this.posY + 8);
          g.closePath();
          g.stroke();
          g.beginPath();
          circle(g, right2 - 10, this.posY, 5);
          g.stroke();
        }
      });
    }
    makeComponentSpecificContextMenuItems() {
      const s = S.Components.Generic.contextMenu;
      return [
        this.makeChangeParamsContextMenuItem("inputs", s.ParamNumBits, this.numBits, "bits"),
        this.makeChangeBooleanParamsContextMenuItem(s.ParamControlBitAtBottom, this.controlPinsAtBottom, "bottom"),
        ...this.makeForceOutputsContextMenuItem(true)
      ];
    }
  };
  __name(ControlledInverter, "ControlledInverter");
  ControlledInverterDef.impl = ControlledInverter;

  // simulator/src/components/Counter.ts
  var t15 = __toESM(require_lib());

  // simulator/src/components/FlipflopOrLatch.ts
  var t14 = __toESM(require_lib());
  var FlipflopOrLatchDef = defineAbstractComponent({
    button: { imgWidth: 50 },
    repr: {
      state: typeOrUndefined(LogicValueRepr),
      showContent: typeOrUndefined(t14.boolean)
    },
    valueDefaults: {
      state: false,
      showContent: true
    },
    size: { gridWidth: 5, gridHeight: 7 },
    makeNodes: () => {
      const s = S.Components.Generic;
      return {
        outs: {
          Q: [4, -2, "e", s.OutputQDesc],
          Q\u0305: [4, 2, "e", s.OutputQBarDesc]
        }
      };
    },
    initialValue: (saved, defaults) => {
      if (saved === void 0) {
        return [false, true];
      }
      const state = saved.state === void 0 ? defaults.state : toLogicValue(saved.state);
      return [state, LogicValue.invert(state)];
    }
  });
  var FlipflopOrLatch = class extends ComponentBase {
    constructor(parent, SubclassDef, saved) {
      var _a;
      super(parent, SubclassDef, saved);
      this._isInInvalidState = false;
      this._showContent = (_a = saved == null ? void 0 : saved.showContent) != null ? _a : FlipflopOrLatchDef.aults.showContent;
    }
    toJSONBase() {
      const state = this.value[0];
      return __spreadProps(__spreadValues({}, super.toJSONBase()), {
        state: state !== FlipflopOrLatchDef.aults.state ? toLogicValueRepr(state) : void 0,
        showContent: this._showContent !== FlipflopOrLatchDef.aults.showContent ? this._showContent : void 0
      });
    }
    propagateValue(newValue) {
      this.outputs.Q.value = newValue[0];
      this.outputs.Q\u0305.value = newValue[1];
    }
    doSetShowContent(showContent) {
      this._showContent = showContent;
      this.requestRedraw({ why: "show content changed" });
    }
    doDraw(g, ctx) {
      this.doDrawDefault(g, ctx, {
        background: this._isInInvalidState ? COLOR_BACKGROUND_INVALID : void 0,
        drawLabels: () => {
          if (this._showContent && !this.parent.editor.options.hideMemoryContent) {
            FlipflopOrLatch.drawStoredValue(g, this.value[0], this.posX, this.posY, 26, false);
          }
        }
      });
    }
    static drawStoredValueFrame(g, x, y, width, height, swapHeightWidth) {
      if (swapHeightWidth) {
        [width, height] = [height, width];
      }
      g.strokeStyle = COLOR_COMPONENT_BORDER;
      g.lineWidth = 2;
      g.beginPath();
      g.rect(x - width / 2, y - height / 2, width, height);
      g.fill();
      g.stroke();
    }
    static drawStoredValue(g, value, x, y, cellHeight, swapHeightWidth) {
      g.fillStyle = colorForLogicValue(value);
      FlipflopOrLatch.drawStoredValueFrame(g, x, y, 20, cellHeight, swapHeightWidth);
      drawValueText(g, value, x, y, { small: cellHeight < 18 });
    }
  };
  __name(FlipflopOrLatch, "FlipflopOrLatch");
  var FlipflopBaseDef = defineAbstractComponent({
    button: FlipflopOrLatchDef.button,
    repr: __spreadProps(__spreadValues({}, FlipflopOrLatchDef.repr), {
      trigger: typeOrUndefined(t14.keyof(EdgeTrigger))
    }),
    valueDefaults: __spreadProps(__spreadValues({}, FlipflopOrLatchDef.valueDefaults), {
      trigger: EdgeTrigger.rising
    }),
    size: FlipflopOrLatchDef.size,
    makeNodes: (clockYOffset) => {
      const base = FlipflopOrLatchDef.makeNodes();
      const s = S.Components.Generic;
      return {
        ins: {
          Clock: [-4, clockYOffset, "w", s.InputClockDesc, { isClock: true }],
          Pre: [0, -4, "n", s.InputPresetDesc, { prefersSpike: true }],
          Clr: [0, 4, "s", s.InputClearDesc, { prefersSpike: true }]
        },
        outs: base.outs
      };
    },
    initialValue: FlipflopOrLatchDef.initialValue
  });
  var Flipflop = class extends FlipflopOrLatch {
    constructor(parent, SubclassDef, saved) {
      var _a;
      super(parent, SubclassDef, saved);
      this._lastClock = Unknown;
      this._trigger = (_a = saved == null ? void 0 : saved.trigger) != null ? _a : FlipflopBaseDef.aults.trigger;
    }
    toJSONBase() {
      return __spreadProps(__spreadValues({}, super.toJSONBase()), {
        trigger: this._trigger !== FlipflopBaseDef.aults.trigger ? this._trigger : void 0
      });
    }
    get trigger() {
      return this._trigger;
    }
    static doRecalcValueForSyncComponent(comp, prevClock, clock, preset, clear) {
      if (preset === true) {
        if (clear === true) {
          return { isInInvalidState: true, newState: comp.makeInvalidState() };
        } else {
          return { isInInvalidState: false, newState: comp.makeStateFromMainValue(true) };
        }
      }
      if (clear === true) {
        return { isInInvalidState: false, newState: comp.makeStateFromMainValue(false) };
      }
      if (!Flipflop.isClockTrigger(comp.trigger, prevClock, clock)) {
        return { isInInvalidState: false, newState: comp.value };
      } else {
        return { isInInvalidState: false, newState: comp.makeStateAfterClock() };
      }
    }
    static isClockTrigger(trigger, prevClock, clock) {
      return trigger === EdgeTrigger.rising && prevClock === false && clock === true || trigger === EdgeTrigger.falling && prevClock === true && clock === false;
    }
    doRecalcValue() {
      const prevClock = this._lastClock;
      const clock = this._lastClock = this.inputs.Clock.value;
      const { isInInvalidState, newState } = Flipflop.doRecalcValueForSyncComponent(
        this,
        prevClock,
        clock,
        this.inputs.Pre.value,
        this.inputs.Clr.value
      );
      this._isInInvalidState = isInInvalidState;
      return newState;
    }
    makeInvalidState() {
      return [false, false];
    }
    makeStateFromMainValue(val) {
      return [val, LogicValue.invert(val)];
    }
    makeStateAfterClock() {
      return this.makeStateFromMainValue(LogicValue.filterHighZ(this.doRecalcValueAfterClock()));
    }
    doSetTrigger(trigger) {
      this._trigger = trigger;
      this.requestRedraw({ why: "trigger changed", invalidateTests: true });
    }
    makeComponentSpecificContextMenuItems() {
      const icon = this._showContent ? "check" : "none";
      const toggleShowContentItem = MenuData.item(
        icon,
        S.Components.Generic.contextMenu.ShowContent,
        () => this.doSetShowContent(!this._showContent)
      );
      return [
        ...makeTriggerItems(this._trigger, this.doSetTrigger.bind(this)),
        ["mid", MenuData.sep()],
        ["mid", toggleShowContentItem],
        ...this.makeForceOutputsContextMenuItem(true)
      ];
    }
  };
  __name(Flipflop, "Flipflop");
  function makeTriggerItems(currentTrigger, handler) {
    const s = S.Components.Generic.contextMenu;
    const makeTriggerItem = /* @__PURE__ */ __name((trigger, desc) => {
      const isCurrent = currentTrigger === trigger;
      const icon = isCurrent ? "check" : "none";
      const caption = s.TriggerOn + " " + desc;
      const action = isCurrent ? () => void 0 : () => handler(trigger);
      return MenuData.item(icon, caption, action);
    }, "makeTriggerItem");
    return [
      ["mid", makeTriggerItem(EdgeTrigger.rising, s.TriggerRisingEdge)],
      ["mid", makeTriggerItem(EdgeTrigger.falling, s.TriggerFallingEdge)]
    ];
  }
  __name(makeTriggerItems, "makeTriggerItems");

  // simulator/src/components/Counter.ts
  var CounterDef = defineParametrizedComponent("counter", true, true, {
    variantName: ({ bits }) => `counter-${bits}`,
    idPrefix: "counter",
    button: { imgWidth: 50 },
    repr: {
      bits: typeOrUndefined(t15.number),
      count: typeOrUndefined(t15.number),
      trigger: typeOrUndefined(t15.keyof(EdgeTrigger)),
      displayRadix: typeOrUndefined(typeOrNull(t15.number))
      // undefined means default, null means no display
    },
    valueDefaults: {
      trigger: EdgeTrigger.rising,
      displayRadix: 10
    },
    params: {
      bits: param(4, [2, 3, 4, 7, 8, 16])
    },
    validateParams: ({ bits }) => ({
      numBits: bits
    }),
    size: ({ numBits }) => ({
      gridWidth: numBits <= 6 ? 5 : numBits <= 8 ? 6 : 7,
      gridHeight: Math.max(11, 1 + (numBits + 1) * (useCompact(numBits) ? 1 : 2))
    }),
    makeNodes: ({ numBits, gridWidth, gridHeight }) => {
      const s = S.Components.Generic;
      const outX = 1 + gridWidth / 2;
      const groupQ = groupVertical("e", outX, -1, numBits);
      const lastQY = groupQ[numBits - 1][1];
      const qyDiff = lastQY - groupQ[numBits - 2][1];
      const clockVY = lastQY + qyDiff;
      const clearY = (gridHeight + 1) / 2;
      return {
        ins: {
          Clock: [-outX, clockVY, "w", s.InputClockDesc, { isClock: true }],
          Clr: [0, clearY, "s", s.InputClearDesc, { prefersSpike: true }]
        },
        outs: {
          Q: groupQ,
          V: [outX, clockVY, "e", "V (oVerflow)"]
        }
      };
    },
    initialValue: (saved, { numBits }) => {
      if (saved === void 0 || saved.count === void 0) {
        return Counter.emptyValue(numBits);
      }
      return [Counter.decimalToNBits(saved.count, numBits), false];
    }
  });
  var Counter = class extends ParametrizedComponentBase {
    constructor(parent, params, saved) {
      var _a;
      super(parent, CounterDef.with(params), saved);
      this._lastClock = Unknown;
      this.numBits = params.numBits;
      this._trigger = (_a = saved == null ? void 0 : saved.trigger) != null ? _a : CounterDef.aults.trigger;
      this._displayRadix = (saved == null ? void 0 : saved.displayRadix) === void 0 ? CounterDef.aults.displayRadix : saved.displayRadix === null ? void 0 : saved.displayRadix;
    }
    static emptyValue(numBits) {
      return [ArrayFillWith(false, numBits), false];
    }
    static decimalToNBits(value, width) {
      const binStr = value.toString(2).padStart(width, "0");
      const asBits = ArrayFillWith(false, width);
      for (let i2 = 0; i2 < width; i2++) {
        asBits[i2] = binStr[width - i2 - 1] === "1";
      }
      return asBits;
    }
    toJSON() {
      const [__, currentCountOrUnknown] = displayValuesFromArray(this.value[0], false);
      const currentCount = isUnknown(currentCountOrUnknown) ? 0 : currentCountOrUnknown;
      const displayRadix = this._displayRadix === void 0 ? null : this._displayRadix;
      return __spreadProps(__spreadValues({}, this.toJSONBase()), {
        bits: this.numBits === CounterDef.aults.bits ? void 0 : this.numBits,
        count: currentCount === 0 ? void 0 : currentCount,
        trigger: this._trigger !== CounterDef.aults.trigger ? this._trigger : void 0,
        displayRadix: displayRadix !== CounterDef.aults.displayRadix ? displayRadix : void 0
      });
    }
    get trigger() {
      return this._trigger;
    }
    makeTooltip() {
      const s = S.Components.Counter.tooltip;
      return tooltipContent(s.title, mods(
        div(s.desc)
        // TODO more info
      ));
    }
    doRecalcValue() {
      const clear = this.inputs.Clr.value;
      if (clear === true) {
        return Counter.emptyValue(this.numBits);
      }
      const prevClock = this._lastClock;
      const clock = this._lastClock = this.inputs.Clock.value;
      const activeOverflowValue = this._trigger === EdgeTrigger.rising ? true : false;
      if (Flipflop.isClockTrigger(this._trigger, prevClock, clock)) {
        const [__, value] = displayValuesFromArray(this.value[0], false);
        if (isUnknown(value)) {
          return [ArrayFillWith(Unknown, this.numBits), Unknown];
        }
        const newValue = value + 1;
        if (newValue >= Math.pow(2, this.numBits)) {
          return [ArrayFillWith(false, this.numBits), activeOverflowValue];
        }
        return [Counter.decimalToNBits(newValue, this.numBits), !activeOverflowValue];
      } else {
        return [this.value[0], !activeOverflowValue];
      }
    }
    propagateValue(newValue) {
      const [counter, overflow] = newValue;
      this.outputValues(this.outputs.Q, counter);
      this.outputs.V.value = overflow;
    }
    doSetTrigger(trigger) {
      this._trigger = trigger;
      this.requestRedraw({ why: "trigger changed", invalidateTests: true });
    }
    doDraw(g, ctx) {
      this.doDrawDefault(g, ctx, (ctx2, { width }) => {
        if (this._displayRadix !== void 0) {
          g.font = "bold 20px sans-serif";
          const [__, currentCount] = displayValuesFromArray(this.value[0], false);
          const stringRep = formatWithRadix(currentCount, this._displayRadix, this.numBits, false);
          const labelMargin = 10;
          const valueCenter = ctx2.rotatePoint(this.posX - labelMargin / 2, this.outputs.Q.group.posYInParentTransform);
          g.fillStyle = COLOR_EMPTY;
          const frameWidth = width - labelMargin - 12;
          FlipflopOrLatch.drawStoredValueFrame(g, ...valueCenter, frameWidth, 28, false);
          g.fillStyle = COLOR_LABEL_OFF;
          g.textAlign = "center";
          fillTextVAlign(g, TextVAlign.middle, stringRep, ...valueCenter);
        }
      });
    }
    doSetDisplayRadix(displayRadix) {
      this._displayRadix = displayRadix;
      this.requestRedraw({ why: "display radix changed" });
    }
    makeComponentSpecificContextMenuItems() {
      const s = S.Components.Counter.contextMenu;
      const makeItemShowRadix = /* @__PURE__ */ __name((displayRadix, desc) => {
        const icon = this._displayRadix === displayRadix ? "check" : "none";
        const caption = s.DisplayTempl.expand({ desc });
        const action = /* @__PURE__ */ __name(() => this.doSetDisplayRadix(displayRadix), "action");
        return MenuData.item(icon, caption, action);
      }, "makeItemShowRadix");
      return [
        ...makeTriggerItems(this._trigger, this.doSetTrigger.bind(this)),
        ["mid", MenuData.sep()],
        ["mid", makeItemShowRadix(void 0, s.DisplayNone)],
        ["mid", makeItemShowRadix(10, s.DisplayDecimal)],
        ["mid", makeItemShowRadix(16, s.DisplayHex)],
        ["mid", MenuData.sep()],
        this.makeChangeParamsContextMenuItem("outputs", S.Components.Generic.contextMenu.ParamNumBits, this.numBits, "bits"),
        ...this.makeForceOutputsContextMenuItem(true)
      ];
    }
  };
  __name(Counter, "Counter");
  CounterDef.impl = Counter;

  // simulator/src/components/CustomComponent.ts
  var t17 = __toESM(require_lib());

  // simulator/src/ComponentList.ts
  var ComponentList = class {
    constructor() {
      this._componentsByZIndex = ArrayFillUsing(() => [], 3);
      this._componentsById = /* @__PURE__ */ new Map();
    }
    *all() {
      for (const compList of this._componentsByZIndex) {
        for (const comp of compList) {
          yield comp;
        }
      }
    }
    *allInReversedZIndexOrder() {
      for (let i2 = this._componentsByZIndex.length - 1; i2 >= 0; i2--) {
        const compList = this._componentsByZIndex[i2];
        for (const comp of compList) {
          yield comp;
        }
      }
    }
    *withZIndex(zIndex) {
      for (const comp of this._componentsByZIndex[zIndex]) {
        yield comp;
      }
    }
    add(comp) {
      const z = comp.drawZIndex;
      this._componentsByZIndex[z].push(comp);
      let id = comp.ref;
      let oldComp;
      if (id === void 0) {
        id = this.generateIdFor(comp);
        comp.doSetValidatedId(id);
      } else if ((oldComp = this._componentsById.get(id)) !== void 0) {
        console.error(`Component with id '${id}' already exists and will be renamed`);
        const idForOldComp = this.generateIdFor(oldComp);
        oldComp.doSetValidatedId(idForOldComp);
        this._componentsById.set(idForOldComp, oldComp);
      }
      this._componentsById.set(id, comp);
    }
    contains(type7) {
      for (const comp of this.all()) {
        if (comp.def.type === type7) {
          return true;
        }
      }
      return false;
    }
    updateCustomComponents(type7) {
      for (const comp of [...this.all()]) {
        if (comp.def.type === type7 && comp instanceof CustomComponent) {
          comp.updateFromDef();
        }
      }
    }
    changeIdOf(comp, newId) {
      const oldId = comp.ref;
      if (oldId !== void 0) {
        const deleted = this._componentsById.delete(oldId);
        if (!deleted) {
          console.warn(`Component with id '${oldId}' not found`);
        }
      }
      if (this._componentsById.has(newId)) {
        throw new Error(`Component with id '${newId}' already exists`);
      }
      comp.doSetValidatedId(newId);
      this._componentsById.set(newId, comp);
    }
    regenerateIdOf(comp) {
      const newId = this.generateIdFor(comp);
      this.changeIdOf(comp, newId);
    }
    swapIdsOf(comp1, comp2) {
      const id1 = comp1.ref;
      const id2 = comp2.ref;
      if (id1 === void 0 || id2 === void 0) {
        throw new Error("Cannot swap ids of components without ids");
      }
      comp1.doSetValidatedId(id2);
      comp2.doSetValidatedId(id1);
      this._componentsById.set(id1, comp2);
      this._componentsById.set(id2, comp1);
    }
    get(id) {
      return this._componentsById.get(id);
    }
    looksLikeAutoGeneratedId(comp) {
      const ref = comp.ref;
      if (ref === void 0) {
        return false;
      }
      const prefix = ComponentList.idPrefixFor(comp);
      if (!ref.startsWith(prefix)) {
        return false;
      }
      const suffix = ref.slice(prefix.length);
      if (isNaN(Number(suffix))) {
        return false;
      }
      return true;
    }
    generateIdFor(comp) {
      const prefix = ComponentList.idPrefixFor(comp);
      let i2 = 0;
      let id;
      while (this._componentsById.has(id = `${prefix}${i2}`)) {
        i2++;
      }
      return id;
    }
    static idPrefixFor(comp) {
      const prefixFromDef = comp.def.idPrefix;
      return isString(prefixFromDef) ? prefixFromDef : prefixFromDef(comp);
    }
    tryDelete(comp) {
      return this.tryDeleteWhere((c) => c === comp, true).length > 0;
    }
    tryDeleteWhere(cond, onlyOne) {
      const deletedComps = [];
      outer:
        for (const compList of this._componentsByZIndex) {
          for (let i2 = 0; i2 < compList.length; i2++) {
            const comp = compList[i2];
            if (cond(comp)) {
              comp.destroy();
              compList.splice(i2, 1);
              deletedComps.push(comp);
              if (onlyOne) {
                break outer;
              }
            }
          }
        }
      for (const comp of deletedComps) {
        const id = comp.ref;
        if (id === void 0) {
          console.warn("Removing component without id");
        } else if (!this._componentsById.has(id)) {
          console.warn(`Removing component with id '${id}' but no component with that id exists`);
        } else {
          this._componentsById.delete(id);
        }
      }
      for (const comp of deletedComps) {
        for (const anchored of comp.anchoredDrawables) {
          anchored.anchor = void 0;
        }
      }
      return deletedComps;
    }
    clearAll() {
      for (const compList of this._componentsByZIndex) {
        compList.length = 0;
      }
      this._componentsById.clear();
    }
  };
  __name(ComponentList, "ComponentList");

  // simulator/src/NodeManager.ts
  var NodeManager = class {
    constructor() {
      this._lastGivenNodeID = -1;
      this._usedIDs = /* @__PURE__ */ new Set();
      this._allLiveNodes = [];
      this._currentMapping = void 0;
    }
    getFreeId() {
      while (this._usedIDs.has(++this._lastGivenNodeID)) {
      }
      this._usedIDs.add(this._lastGivenNodeID);
      return this._lastGivenNodeID;
    }
    getFreeIdFrom(sourceId) {
      if (!this._usedIDs.has(sourceId)) {
        this._usedIDs.add(sourceId);
        return sourceId;
      }
      if (this._currentMapping !== void 0) {
        const newId = this.getFreeId();
        this._currentMapping.set(sourceId, newId);
        return newId;
      } else {
        console.error(`Loaded node with id ${sourceId}, which is already taken, with no NodeMapping being built`);
        return sourceId;
      }
    }
    addLiveNode(node) {
      if (!this._usedIDs.has(node.id)) {
        console.error(`Inserting live node with unreserved id ${node.id}`);
      }
      this._allLiveNodes[node.id] = node;
    }
    removeLiveNode(node) {
      delete this._allLiveNodes[node.id];
      this._usedIDs.delete(node.id);
    }
    clearAll() {
      this._allLiveNodes.length = 0;
      this._usedIDs.clear();
      this._lastGivenNodeID = -1;
      this._currentMapping = void 0;
    }
    findNode(id, mapping) {
      var _a;
      const mappedId = (_a = mapping.get(id)) != null ? _a : id;
      return this._allLiveNodes[mappedId];
    }
    recordMappingWhile(f) {
      if (this._currentMapping !== void 0) {
        console.warn("NodeManager.recordMappingWhile called while already recording a mapping");
      }
      this._currentMapping = /* @__PURE__ */ new Map();
      f();
      const mapping = this._currentMapping;
      this._currentMapping = void 0;
      return mapping;
    }
    tryConnectNodesOf(comp) {
      const linkMgr = comp.parent.linkMgr;
      const addedConnections = [];
      for (const node of comp.allNodes()) {
        if (node.acceptsMoreConnections) {
          const nodeX = node.posX;
          const nodeY = node.posY;
          const component = node.component;
          for (const other of this._allLiveNodes) {
            if (other !== void 0 && other.component !== component && other.acceptsMoreConnections) {
              if (other.posX === nodeX && other.posY === nodeY) {
                linkMgr.startDraggingWireFrom(node);
                const wire = linkMgr.stopDraggingWireOn(other);
                if (wire !== void 0) {
                  addedConnections.push([node, other.component, other]);
                }
              }
            }
          }
        }
      }
      return addedConnections;
    }
  };
  __name(NodeManager, "NodeManager");

  // simulator/src/RedrawRecalcManager.ts
  var RedrawManager = class {
    constructor() {
      this._canvasRedrawReasons = {};
      this._maskWasInvalidated = false;
      this._testsInvalidationReasons = [];
      this._isPropagating = false;
      this._isEmpty = true;
    }
    requestRedraw(req) {
      var _a, _b, _c, _d;
      const compObj = (_a = req.component) != null ? _a : null;
      const compList = this._canvasRedrawReasons[req.why];
      if (compList === void 0) {
        this._canvasRedrawReasons[req.why] = [compObj];
      } else {
        compList.push(compObj);
      }
      if ((_b = req.invalidateMask) != null ? _b : false) {
        this._maskWasInvalidated = true;
      }
      if ((_c = req.invalidateTests) != null ? _c : false) {
        this._testsInvalidationReasons.push([req.why, compObj]);
      }
      if ((_d = req.isPropagation) != null ? _d : false) {
        this._isPropagating = true;
      }
      this._isEmpty = false;
    }
    getReasonsAndClear() {
      if (this._isEmpty) {
        return void 0;
      }
      const redrawReasons = this._canvasRedrawReasons;
      const getReasons = /* @__PURE__ */ __name(() => {
        var _a, _b;
        const reasonParts = [];
        for (const reason of Object.keys(redrawReasons)) {
          reasonParts.push(reason);
          const linkedComps = redrawReasons[reason];
          reasonParts.push(" (", String(linkedComps.length), "\xD7)", ": ");
          for (const comp of linkedComps) {
            if (comp !== null) {
              const compAny = comp;
              reasonParts.push((_b = (_a = compAny.constructor) == null ? void 0 : _a.name) != null ? _b : "Component");
              if (compAny.type !== void 0) {
                reasonParts.push("_", compAny.type);
              }
              if (compAny.name !== void 0) {
                reasonParts.push("('", compAny.name, "')");
              }
              reasonParts.push("; ");
            }
          }
          reasonParts.pop();
          reasonParts.push("\n    ");
        }
        reasonParts.pop();
        return reasonParts.join("");
      }, "getReasons");
      const redrawMask = this._maskWasInvalidated;
      const invalidateTests = this._testsInvalidationReasons.length > 0;
      this._canvasRedrawReasons = {};
      this._isPropagating = false;
      this._maskWasInvalidated = false;
      this._testsInvalidationReasons.length = 0;
      this._isEmpty = true;
      return { getReasons, redrawMask, invalidateTests };
    }
    hasReasons() {
      return !this._isEmpty;
    }
    isAnyValuePropagating() {
      return this._isPropagating;
    }
  };
  __name(RedrawManager, "RedrawManager");
  var RecalcManager = class {
    constructor() {
      this._propagateQueue = [];
      this._recalcQueue = [];
      this.debug = false;
    }
    enqueueForPropagate(comp) {
      this._propagateQueue.push(comp);
      this.log("Enqueued for propagate: " + comp);
    }
    enqueueForRecalc(comp, forcePropagate) {
      this._recalcQueue.push([comp, forcePropagate]);
      this.log("Enqueued for recalc: " + comp);
    }
    queueIsEmpty() {
      return this._propagateQueue.length === 0 && this._recalcQueue.length === 0;
    }
    recalcAndPropagateIfNeeded() {
      if (this.queueIsEmpty()) {
        return false;
      }
      this.recalcAndPropagate();
      return true;
    }
    recalcAndPropagate() {
      let round2 = 0;
      const roundLimit = 1e3;
      do {
        round2++;
        if (round2 >= roundLimit) {
          console.warn(`ERROR: Circular dependency; suspending updates after ${roundLimit} recalc/propagate rounds`);
          for (const comp of [...this._propagateQueue, ...this._recalcQueue.map((r) => r[0])]) {
            comp.setInvalid();
          }
          this._propagateQueue = [];
          this._recalcQueue = [];
          break;
        }
        this.log(`Recalc/propagate round ${round2}: ${this._propagateQueue.length} propagate, ${this._recalcQueue.length} recalc.`);
        const propagateQueue = this._propagateQueue;
        this._propagateQueue = [];
        this.log(`  PROPAG (${propagateQueue.length}) \u2013 ` + propagateQueue.map((c) => c.toString()).join("; "));
        for (const comp of propagateQueue) {
          try {
            comp.propagateCurrentValue();
          } catch (e) {
            console.error("Error while propagating value of " + comp, e);
            comp.setInvalid();
          }
        }
        const recalcQueue = this._recalcQueue;
        this._recalcQueue = [];
        this.log(`  RECALC (${recalcQueue.length}) \u2013 ` + recalcQueue.map((c) => c.toString()).join("; "));
        for (const [comp, forcePropagate] of recalcQueue) {
          try {
            comp.recalcValue(forcePropagate);
          } catch (e) {
            console.error("Error while recalculating value of " + comp, e);
            comp.setInvalid();
          }
        }
      } while (!this.queueIsEmpty());
      this.log(`Recalc/propagate done in ${round2} rounds.`);
    }
    log(msg) {
      if (this.debug) {
        console.log(msg);
      }
    }
  };
  __name(RecalcManager, "RecalcManager");

  // simulator/src/SVGRenderingContext.ts
  var SVGRenderingContext = class {
    constructor(optionsOrWidth, height) {
      // mirrored canvas properties
      this.strokeStyle = "#000000";
      this.fillStyle = "#000000";
      this.lineCap = "butt";
      this.lineJoin = "miter";
      this.miterLimit = 10;
      this.lineWidth = 1;
      this.globalAlpha = 1;
      this.font = "10px sans-serif";
      this.shadowColor = "#000000";
      this.shadowOffsetX = 0;
      this.shadowOffsetY = 0;
      this.shadowBlur = 0;
      this.textAlign = "start";
      this.textBaseline = "alphabetic";
      this.lineDash = null;
      this.lineDashOffset = 0;
      // extra
      this.fontUnderline = "";
      this._groupStack = [];
      this._transformMatrixStack = [];
      this._currentPath = new Path2DSVG(this);
      this._transformMatrix = new DOMMatrix();
      var _a, _b, _c, _d;
      let options;
      if (height !== void 0) {
        options = { width: optionsOrWidth, height };
      } else if (optionsOrWidth !== void 0) {
        options = optionsOrWidth;
      } else {
        options = {};
      }
      this.width = (_a = options.width) != null ? _a : 500;
      this.height = (_b = options.height) != null ? _b : 500;
      this.enableMirroring = (_c = options.enableMirroring) != null ? _c : false;
      this.canvas = this;
      this._document = (_d = options.document) != null ? _d : document;
      if (options.ctx) {
        this._g = options.ctx;
      } else {
        this._helperCanvas = this._document.createElement("canvas");
        this._g = this._helperCanvas.getContext("2d");
      }
      this._styleStack = [this._getStyleState()];
      this._svg = this._document.createElementNS("http://www.w3.org/2000/svg", "svg");
      this._svg.setAttribute("version", "1.1");
      this._svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
      this._svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
      this._svg.setAttribute("width", String(this.width));
      this._svg.setAttribute("height", String(this.height));
      this._ids = {};
      if (options.metadata !== void 0) {
        const metadata = this._document.createElementNS("http://www.w3.org/2000/svg", "metadata");
        const textNode = this._document.createTextNode(options.metadata);
        metadata.appendChild(textNode);
        this._svg.appendChild(metadata);
      }
      this._defs = this._document.createElementNS("http://www.w3.org/2000/svg", "defs");
      this._svg.appendChild(this._defs);
      this._currentElement = this._document.createElementNS("http://www.w3.org/2000/svg", "g");
      this._svg.appendChild(this._currentElement);
      this.resetTransform();
    }
    /// PRIVATE HELPERS
    _createElement(elementName, properties, resetFill = false) {
      const element = this._document.createElementNS("http://www.w3.org/2000/svg", elementName);
      if (resetFill) {
        element.setAttribute("fill", "none");
        element.setAttribute("stroke", "none");
      }
      if (properties !== void 0) {
        for (const [key, value] of Object.entries(properties)) {
          element.setAttribute(key, String(value));
        }
      }
      return element;
    }
    /**
     * Will return the closest group or svg node. May return the current element.
     */
    _closestGroupOrSvg(node) {
      node = node != null ? node : this._currentElement;
      if (node.nodeName === "g" || node.nodeName === "svg") {
        return node;
      } else {
        return this._closestGroupOrSvg(node.parentNode);
      }
    }
    /**
     * Applies styles on restore
     */
    _applyStyleState(styleState) {
      for (const [key, value] of Object.entries(styleState)) {
        this[key] = value;
      }
    }
    /**
     * Gets the current style state
     */
    _getStyleState() {
      const styleState = {};
      for (const key of Object.keys(STYLES)) {
        styleState[key] = this[key];
      }
      return styleState;
    }
    _applyTransformation(element, matrix) {
      const { a: a2, b: b2, c, d, e, f } = matrix != null ? matrix : this.getTransform();
      if (a2 === 1 && b2 === 0 && c === 0 && d === 1 && e === 0 && f === 0) {
        return;
      }
      element.setAttribute("transform", `matrix(${a2} ${b2} ${c} ${d} ${e} ${f})`);
    }
    /**
     * Apples the current styles to the current SVG element. On "ctx.fill" or "ctx.stroke"
     */
    _applyStyleToElement(elem, type7) {
      for (const [key, style2] of Object.entries(STYLES)) {
        let value = this[key];
        if ("apply" in style2 && style2.apply) {
          if (value instanceof CanvasPatternSVG) {
            for (const node of value._ctx._defs.children) {
              const id = node.getAttribute("id");
              this._ids[id] = id;
              this._defs.appendChild(node);
            }
            elem.setAttribute(style2.apply, `url(#${value.patternElem.getAttribute("id")})`);
          } else if (value instanceof CanvasGradientSVG) {
            elem.setAttribute(style2.apply, `url(#${value.gradientElem.getAttribute("id")})`);
          } else if (style2.apply.indexOf(type7) !== -1 && style2.svg !== value) {
            if ((style2.svgAttr === "stroke" || style2.svgAttr === "fill") && value.indexOf("rgba") !== -1) {
              const regex = /rgba\(\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
              const matches = regex.exec(value);
              elem.setAttribute(style2.svgAttr, `rgb(${matches[1]},${matches[2]},${matches[3]})`);
              const opacity = parseFloat(matches[4]) * this.globalAlpha;
              elem.setAttribute(style2.svgAttr + "-opacity", String(opacity));
            } else {
              let attr2 = style2.svgAttr;
              if (key === "globalAlpha") {
                attr2 = type7 + "-" + style2.svgAttr;
                if (elem.getAttribute(attr2) !== null) {
                  continue;
                }
              } else if (key === "lineWidth") {
                const scale = this._getTransformScale();
                value = value * Math.max(scale.x, scale.y);
              }
              elem.setAttribute(attr2, value);
            }
          }
        }
      }
    }
    /// SVG ACCESS
    /**
     * Returns the serialized value of the svg so far
     * @param fixNamedEntities - Standalone SVG doesn't support named entities, which document.createTextNode encodes. If true, we attempt to find all named entities and encode it as a numeric entity.
     * @return serialized svg
     */
    getSerializedSvg(fixNamedEntities = false) {
      let serialized = new XMLSerializer().serializeToString(this._svg);
      const xmlns = /xmlns="http:\/\/www\.w3\.org\/2000\/svg".+xmlns="http:\/\/www\.w3\.org\/2000\/svg/gi;
      if (xmlns.test(serialized)) {
        serialized = serialized.replace('xmlns="http://www.w3.org/2000/svg', 'xmlns:xlink="http://www.w3.org/1999/xlink');
      }
      if (fixNamedEntities) {
        for (const [key, value] of Object.entries(namedEntities)) {
          const regexp = new RegExp(key, "gi");
          if (regexp.test(serialized)) {
            serialized = serialized.replace(regexp, value);
          }
        }
      }
      return serialized;
    }
    getSvg() {
      return this._svg;
    }
    /// CONTEXT SAVE/RESTORE and GROUPS
    beginGroup(className) {
      const group2 = this._createElement("g");
      if (className !== void 0) {
        group2.setAttribute("class", className);
      }
      const parent = this._closestGroupOrSvg();
      this._groupStack.push(parent);
      parent.appendChild(group2);
      this._currentElement = group2;
    }
    endGroup() {
      var _a;
      this._currentElement = (_a = this._groupStack.pop()) != null ? _a : this._svg.children[1];
    }
    /**
     * Saves the current state by creating a group tag
     */
    save() {
      this.beginGroup(void 0);
      this._styleStack.push(this._getStyleState());
      this._transformMatrixStack.push(this.getTransform());
    }
    /**
     * Sets current element to parent
     */
    restore() {
      this.endGroup();
      this._applyStyleState(this._styleStack.pop());
      this.setTransform(this._transformMatrixStack.pop());
    }
    /// PATH API
    _createPathElement() {
      const path = this._createElement("path", {}, true);
      const parent = this._closestGroupOrSvg();
      parent.appendChild(path);
      return path;
    }
    beginPath() {
      this._currentPath = new Path2DSVG(this);
    }
    closePath() {
      this._currentPath.closePath();
    }
    moveTo(x, y) {
      this._currentPath.moveTo(x, y);
    }
    lineTo(x, y) {
      this._currentPath.lineTo(x, y);
    }
    rect(x, y, width, height) {
      this._currentPath.rect(x, y, width, height);
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      this._currentPath.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
      this._currentPath.quadraticCurveTo(cpx, cpy, x, y);
    }
    arc(x, y, radius, startAngle, endAngle, counterClockwise = false) {
      this._currentPath.arc(x, y, radius, startAngle, endAngle, counterClockwise);
    }
    arcTo(x1, y1, x2, y2, radius) {
      this._currentPath.arcTo(x1, y1, x2, y2, radius);
    }
    ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterClockwise = false) {
      this._currentPath.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterClockwise);
    }
    /// STROKE/FILL
    stroke(path2d) {
      this._strokeOrFill("stroke", path2d);
    }
    fill(path2d) {
      this._strokeOrFill("fill", path2d);
    }
    _strokeOrFill(action, path2d) {
      let path;
      if (path2d) {
        if (!(path2d instanceof Path2DSVG)) {
          throw new Error("Path2D is not a Path2DSVG");
        }
        path = path2d;
      } else {
        path = this._currentPath;
      }
      const pathElement = this._createPathElement();
      this._applyStyleToElement(pathElement, action);
      pathElement.setAttribute("paint-order", "fill stroke markers");
      pathElement.setAttribute("d", path.d);
    }
    fillRect(x, y, width, height) {
      const { a: a2, b: b2, c, d, e, f } = this.getTransform();
      if (a2 === 1 && b2 === 0 && c === 0 && d === 1 && e === 0 && f === 0) {
        if (x === 0 && y === 0 && width === this.width && height === this.height) {
          this._clearCanvas();
        }
      }
      const rect = this._createElement("rect", {
        x,
        y,
        width,
        height
      }, true);
      const parent = this._closestGroupOrSvg();
      parent.appendChild(rect);
      this._currentElement = rect;
      this._applyTransformation(rect);
      this._applyStyleToElement(this._currentElement, "fill");
    }
    strokeRect(x, y, width, height) {
      const rect = this._createElement("rect", {
        x,
        y,
        width,
        height
      }, true);
      const parent = this._closestGroupOrSvg();
      parent.appendChild(rect);
      this._currentElement = rect;
      this._applyTransformation(rect);
      this._applyStyleToElement(this._currentElement, "stroke");
    }
    /**
     * Clear the entire canvas by replacing the root group
     */
    _clearCanvas() {
      const rootGroup = this._svg.children[1];
      this._svg.removeChild(rootGroup);
      this._currentElement = this._document.createElementNS("http://www.w3.org/2000/svg", "g");
      this._svg.appendChild(this._currentElement);
      this._groupStack.length = 0;
    }
    /**
     * "Clears" a canvas by just drawing a white rectangle in the current group.
     */
    clearRect(x, y, width, height) {
      const { a: a2, b: b2, c, d, e, f } = this.getTransform();
      if (a2 === 1 && b2 === 0 && c === 0 && d === 1 && e === 0 && f === 0 && x === 0 && y === 0 && width === this.width && height === this.height) {
        this._clearCanvas();
        return;
      }
      const parent = this._closestGroupOrSvg();
      const rect = this._createElement("rect", {
        x,
        y,
        width,
        height,
        fill: "#FFFFFF"
      }, true);
      this._applyTransformation(rect);
      parent.appendChild(rect);
    }
    setLineDash(dashArray) {
      if (dashArray && dashArray.length > 0) {
        this.lineDash = dashArray.join(",");
      } else {
        this.lineDash = null;
      }
    }
    getLineDash() {
      if (this.lineDash === null) {
        return [];
      }
      return this.lineDash.split(",").map((s) => parseFloat(s));
    }
    clip(fillRule) {
      const group2 = this._closestGroupOrSvg();
      const clipPath = this._createElement("clipPath");
      const id = randomString(this._ids);
      const pathElement = this._createPathElement();
      pathElement.setAttribute("d", this._currentPath.d);
      clipPath.setAttribute("id", id);
      if (fillRule !== void 0) {
        clipPath.setAttribute("clip-rule", fillRule);
      }
      clipPath.appendChild(pathElement);
      this._defs.appendChild(clipPath);
      group2.setAttribute("clip-path", `url(#${id})`);
      this._currentElement = group2;
    }
    /**
     * Draws a canvas, image or mock context to this canvas.
     * http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage
     */
    drawImage() {
      const args = Array.prototype.slice.call(arguments);
      let image = args[0];
      let dx, dy, dw, dh, sx = 0, sy = 0, sw, sh;
      if (args.length === 3) {
        dx = args[1];
        dy = args[2];
        sw = image.width;
        sh = image.height;
        dw = sw;
        dh = sh;
      } else if (args.length === 5) {
        dx = args[1];
        dy = args[2];
        dw = args[3];
        dh = args[4];
        sw = image.width;
        sh = image.height;
      } else if (args.length === 9) {
        sx = args[1];
        sy = args[2];
        sw = args[3];
        sh = args[4];
        dx = args[5];
        dy = args[6];
        dw = args[7];
        dh = args[8];
      } else {
        throw new Error("Invalid number of arguments passed to drawImage: " + arguments.length);
      }
      const parent = this._closestGroupOrSvg();
      const matrix = this.getTransform().translate(dx, dy);
      if (image instanceof SVGRenderingContext) {
        const svg = image.getSvg().cloneNode(true);
        if (svg.childNodes.length > 1) {
          const defs = svg.childNodes[0];
          while (defs.childNodes.length) {
            const id = defs.childNodes[0].getAttribute("id");
            this._ids[id] = id;
            this._defs.appendChild(defs.childNodes[0]);
          }
          const group2 = svg.children[1];
          if (group2 !== void 0) {
            this._applyTransformation(group2, matrix);
            parent.appendChild(group2);
          }
        }
      } else if (image.nodeName === "CANVAS" || image.nodeName === "IMG") {
        const svgImage = this._createElement("image");
        svgImage.setAttribute("width", String(dw));
        svgImage.setAttribute("height", String(dh));
        svgImage.setAttribute("preserveAspectRatio", "none");
        if (sx || sy || sw !== image.width || sh !== image.height) {
          const canvas2 = this._document.createElement("canvas");
          canvas2.width = dw;
          canvas2.height = dh;
          const context = canvas2.getContext("2d");
          context.drawImage(image, sx, sy, sw, sh, 0, 0, dw, dh);
          image = canvas2;
        }
        this._applyTransformation(svgImage, matrix);
        svgImage.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          image.nodeName === "CANVAS" ? image.toDataURL() : image.getAttribute("src")
        );
        parent.appendChild(svgImage);
      }
    }
    /// TEXT
    /**
     * Fills or strokes text
     */
    _applyText(text, x, y, action) {
      const el = document.createElement("span");
      el.setAttribute("style", "font:" + this.font);
      const style2 = el.style;
      const parent = this._closestGroupOrSvg();
      const valign = getDominantBaseline(this.textBaseline);
      const textElement = this._createElement("text", {
        "font-family": style2.fontFamily,
        "font-size": style2.fontSize,
        "font-style": style2.fontStyle,
        "font-weight": style2.fontWeight,
        // canvas doesn't support underline natively, but we do :)
        "text-decoration": this.fontUnderline,
        "x": x,
        "y": y,
        "text-anchor": getTextAnchor(this.textAlign),
        "dominant-baseline": valign
      }, true);
      textElement.appendChild(this._document.createTextNode(text));
      this._currentElement = textElement;
      this._applyTransformation(textElement);
      this._applyStyleToElement(this._currentElement, action);
      if (this.fontHref !== void 0) {
        const a2 = this._createElement("a");
        a2.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", this.fontHref);
        a2.appendChild(textElement);
        parent.appendChild(a2);
      } else {
        parent.appendChild(textElement);
      }
    }
    fillText(text, x, y) {
      this._applyText(text, x, y, "fill");
    }
    strokeText(text, x, y) {
      this._applyText(text, x, y, "stroke");
    }
    measureText(text) {
      this._g.font = this.font;
      return this._g.measureText(text);
    }
    /// PATHS, GRADIENTS, PATTERNS
    createPath(arg) {
      return new Path2DSVG(this, arg);
    }
    /**
     * Adds a linear gradient to a defs tag.
     * Returns a canvas gradient object that has a reference to it's parent def
     */
    createLinearGradient(x1, y1, x2, y2) {
      const grad = this._createElement("linearGradient", {
        id: randomString(this._ids),
        x1: x1 + "px",
        x2: x2 + "px",
        y1: y1 + "px",
        y2: y2 + "px",
        "gradientUnits": "userSpaceOnUse"
      }, false);
      this._defs.appendChild(grad);
      return new CanvasGradientSVG(grad, this);
    }
    /**
     * Adds a radial gradient to a defs tag.
     * Returns a canvas gradient object that has a reference to it's parent def
     */
    createRadialGradient(x0, y0, r0, x1, y1, r1) {
      const grad = this._createElement("radialGradient", {
        id: randomString(this._ids),
        cx: x1 + "px",
        cy: y1 + "px",
        r: r1 + "px",
        fx: x0 + "px",
        fy: y0 + "px",
        "gradientUnits": "userSpaceOnUse"
      }, false);
      this._defs.appendChild(grad);
      return new CanvasGradientSVG(grad, this);
    }
    createPattern(image, __repetition) {
      const pattern = this._document.createElementNS("http://www.w3.org/2000/svg", "pattern");
      const id = randomString(this._ids);
      pattern.setAttribute("id", id);
      pattern.setAttribute("width", String(image.width));
      pattern.setAttribute("height", String(image.height));
      pattern.setAttribute("patternUnits", "userSpaceOnUse");
      if ("nodeName" in image && (image.nodeName === "CANVAS" || image.nodeName === "IMG")) {
        const img2 = this._document.createElementNS("http://www.w3.org/2000/svg", "image");
        img2.setAttribute("width", String(image.width));
        img2.setAttribute("height", String(image.height));
        img2.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          image.nodeName === "CANVAS" ? image.toDataURL() : image.getAttribute("src")
        );
        pattern.appendChild(img2);
        this._defs.appendChild(pattern);
      } else if (image instanceof SVGRenderingContext) {
        pattern.appendChild(image._svg.children[1]);
        this._defs.appendChild(pattern);
      }
      return new CanvasPatternSVG(pattern, this);
    }
    setTransform(am, b2, c, d, e, f) {
      if (b2 === void 0) {
        const m = am;
        this._transformMatrix = new DOMMatrix([m.a, m.b, m.c, m.d, m.e, m.f]);
      } else {
        const a2 = am;
        this._transformMatrix = new DOMMatrix([a2, b2, c, d, e, f]);
      }
    }
    getTransform() {
      const { a: a2, b: b2, c, d, e, f } = this._transformMatrix;
      return new DOMMatrix([a2, b2, c, d, e, f]);
    }
    resetTransform() {
      this.setTransform(1, 0, 0, 1, 0, 0);
    }
    transform(a2, b2, c, d, e, f) {
      const matrix = this.getTransform().multiply(new DOMMatrix([a2, b2, c, d, e, f]));
      this.setTransform(matrix);
    }
    scale(x, y) {
      if (y === void 0) {
        y = x;
      }
      if (isNaN(x) || isNaN(y) || !isFinite(x) || !isFinite(y)) {
        return;
      }
      const matrix = this.getTransform().scale(x, y);
      this.setTransform(matrix);
    }
    rotate(angle) {
      const matrix = this.getTransform().multiply(new DOMMatrix([
        Math.cos(angle),
        Math.sin(angle),
        -Math.sin(angle),
        Math.cos(angle),
        0,
        0
      ]));
      this.setTransform(matrix);
    }
    translate(x, y) {
      const matrix = this.getTransform().translate(x, y);
      this.setTransform(matrix);
    }
    _matrixTransform(x, y) {
      const { a: a2, b: b2, c, d, e, f } = this._transformMatrix;
      const x1 = a2 * x + c * y + e;
      const y1 = b2 * x + d * y + f;
      return [x1, y1];
    }
    /**
     * @returns The scale component of the transform matrix as {x,y}.
     */
    _getTransformScale() {
      return {
        x: Math.hypot(this._transformMatrix.a, this._transformMatrix.b),
        y: Math.hypot(this._transformMatrix.c, this._transformMatrix.d)
      };
    }
    /**
     * @returns The rotation component of the transform matrix in radians.
     */
    _getTransformRotation() {
      return Math.atan2(this._transformMatrix.b, this._transformMatrix.a);
    }
  };
  __name(SVGRenderingContext, "SVGRenderingContext");
  var Path2DSVG = class {
    constructor(g, path) {
      this._posX = void 0;
      this._posY = void 0;
      this.g = g;
      if (path === void 0) {
        this._parts = [];
        this._hasMoved = false;
      } else if (isString(path)) {
        this._parts = [path];
        this._hasMoved = path.indexOf("M") >= 0;
      } else {
        this._parts = [...path._parts];
        this._hasMoved = this._parts.some((path2) => path2.indexOf("M") >= 0);
      }
    }
    get d() {
      return this._parts.join(" ");
    }
    addPath(path, transform) {
      if (transform) {
        console.error("transform argument to addPath is not supported");
      }
      this._parts.push(path);
      this._hasMoved || (this._hasMoved = path.indexOf("M") >= 0);
    }
    closePath() {
      this.addPath("Z");
    }
    moveTo(x, y) {
      this._posX = x;
      this._posY = y;
      const [tx, ty] = this.g._matrixTransform(x, y);
      this.addPath(`M ${tx} ${ty}`);
    }
    lineTo(x, y) {
      this._posX = x;
      this._posY = y;
      const cmd = this._hasMoved ? "L" : "M";
      const [tx, ty] = this.g._matrixTransform(x, y);
      this.addPath(`${cmd} ${tx} ${ty}`);
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      this._posX = x;
      this._posY = y;
      const g = this.g;
      const [tcp1x, tcp1y] = g._matrixTransform(cp1x, cp1y);
      const [tcp2x, tcp2y] = g._matrixTransform(cp2x, cp2y);
      const [tx, ty] = g._matrixTransform(x, y);
      this.addPath(`C ${tcp1x} ${tcp1y} ${tcp2x} ${tcp2y} ${tx} ${ty}`);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
      this._posX = x;
      this._posY = y;
      const g = this.g;
      const [tcpx, tcpy] = g._matrixTransform(cpx, cpy);
      const [tx, ty] = g._matrixTransform(x, y);
      this.addPath(`Q ${tcpx} ${tcpy} ${tx} ${ty}`);
    }
    rect(x, y, width, height) {
      this.moveTo(x, y);
      this.lineTo(x + width, y);
      this.lineTo(x + width, y + height);
      this.lineTo(x, y + height);
      this.closePath();
    }
    arc(x, y, radius, startAngle, endAngle, counterClockwise = false) {
      if (startAngle === endAngle) {
        return;
      }
      const g = this.g;
      startAngle = startAngle % (2 * Math.PI);
      endAngle = endAngle % (2 * Math.PI);
      if (startAngle === endAngle) {
        endAngle = (endAngle + 2 * Math.PI - 1e-3 * (counterClockwise ? -1 : 1)) % (2 * Math.PI);
      }
      const endX = x + radius * Math.cos(endAngle);
      const endY = y + radius * Math.sin(endAngle);
      const startX = x + radius * Math.cos(startAngle);
      const startY = y + radius * Math.sin(startAngle);
      const sweepFlag = counterClockwise ? 0 : 1;
      let largeArcFlag = 0;
      let diff = endAngle - startAngle;
      if (diff < 0) {
        diff += 2 * Math.PI;
      }
      if (counterClockwise) {
        largeArcFlag = diff > Math.PI ? 0 : 1;
      } else {
        largeArcFlag = diff > Math.PI ? 1 : 0;
      }
      const scaleX = Math.hypot(g._transformMatrix.a, g._transformMatrix.b);
      const scaleY = Math.hypot(g._transformMatrix.c, g._transformMatrix.d);
      this.lineTo(startX, startY);
      const [endx, endy] = g._matrixTransform(endX, endY);
      this.addPath(`A ${radius * scaleX} ${radius * scaleY} ${0} ${largeArcFlag} ${sweepFlag} ${endx} ${endy}`);
      this._posX = x;
      this._posY = y;
    }
    arcTo(x1, y1, x2, y2, radius) {
      const x0 = this._posX;
      const y0 = this._posY;
      if (x0 === void 0 || y0 === void 0) {
        return;
      }
      if (radius < 0) {
        throw new Error(
          "IndexSizeError: The radius provided (" + radius + ") is negative."
        );
      }
      if (x0 === x1 && y0 === y1 || x1 === x2 && y1 === y2 || radius === 0) {
        this.lineTo(x1, y1);
        return;
      }
      const p1p0 = [x0 - x1, y0 - y1];
      const p1p2 = [x2 - x1, y2 - y1];
      const p1p0_length = Math.hypot(p1p0[0], p1p0[1]);
      const p1p2_length = Math.hypot(p1p2[0], p1p2[1]);
      const cos_phi = (p1p0[0] * p1p2[0] + p1p0[1] * p1p2[1]) / (p1p0_length * p1p2_length);
      if (cos_phi === -1) {
        this.lineTo(x1, y1);
        return;
      }
      if (cos_phi === 1) {
        const max_length = 65535;
        const factor_max = max_length / p1p0_length;
        const ep = [x0 + factor_max * p1p0[0], y0 + factor_max * p1p0[1]];
        this.lineTo(ep[0], ep[1]);
        return;
      }
      const tangent = radius / Math.tan(Math.acos(cos_phi) / 2);
      const factor_p1p0 = tangent / p1p0_length;
      const t_p1p0 = [x1 + factor_p1p0 * p1p0[0], y1 + factor_p1p0 * p1p0[1]];
      let orth_p1p0 = [p1p0[1], -p1p0[0]];
      const orth_p1p0_length = Math.hypot(orth_p1p0[0], orth_p1p0[1]);
      const factor_ra = radius / orth_p1p0_length;
      const cos_alpha = (orth_p1p0[0] * p1p2[0] + orth_p1p0[1] * p1p2[1]) / (orth_p1p0_length * p1p2_length);
      if (cos_alpha < 0) {
        orth_p1p0 = [-orth_p1p0[0], -orth_p1p0[1]];
      }
      const p = [t_p1p0[0] + factor_ra * orth_p1p0[0], t_p1p0[1] + factor_ra * orth_p1p0[1]];
      orth_p1p0 = [-orth_p1p0[0], -orth_p1p0[1]];
      let sa = Math.acos(orth_p1p0[0] / orth_p1p0_length);
      if (orth_p1p0[1] < 0) {
        sa = 2 * Math.PI - sa;
      }
      let anticlockwise = false;
      const factor_p1p2 = tangent / p1p2_length;
      const t_p1p2 = [x1 + factor_p1p2 * p1p2[0], y1 + factor_p1p2 * p1p2[1]];
      const orth_p1p2 = [t_p1p2[0] - p[0], t_p1p2[1] - p[1]];
      const orth_p1p2_length = Math.hypot(orth_p1p2[0], orth_p1p2[1]);
      let ea = Math.acos(orth_p1p2[0] / orth_p1p2_length);
      if (orth_p1p2[1] < 0) {
        ea = 2 * Math.PI - ea;
      }
      if (sa > ea && sa - ea < Math.PI) {
        anticlockwise = true;
      }
      if (sa < ea && ea - sa > Math.PI) {
        anticlockwise = true;
      }
      this.lineTo(t_p1p0[0], t_p1p0[1]);
      this.arc(p[0], p[1], radius, sa, ea, anticlockwise);
    }
    ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterClockwise = false) {
      if (startAngle === endAngle) {
        return;
      }
      const g = this.g;
      [x, y] = g._matrixTransform(x, y);
      const scale = g._getTransformScale();
      radiusX = radiusX * scale.x;
      radiusY = radiusY * scale.y;
      rotation = rotation + g._getTransformRotation();
      startAngle = startAngle % (2 * Math.PI);
      endAngle = endAngle % (2 * Math.PI);
      if (startAngle === endAngle) {
        endAngle = (endAngle + 2 * Math.PI - 1e-3 * (counterClockwise ? -1 : 1)) % (2 * Math.PI);
      }
      const endX = x + Math.cos(-rotation) * radiusX * Math.cos(endAngle) + Math.sin(-rotation) * radiusY * Math.sin(endAngle);
      const endY = y - Math.sin(-rotation) * radiusX * Math.cos(endAngle) + Math.cos(-rotation) * radiusY * Math.sin(endAngle);
      const startX = x + Math.cos(-rotation) * radiusX * Math.cos(startAngle) + Math.sin(-rotation) * radiusY * Math.sin(startAngle);
      const startY = y - Math.sin(-rotation) * radiusX * Math.cos(startAngle) + Math.cos(-rotation) * radiusY * Math.sin(startAngle);
      const sweepFlag = counterClockwise ? 0 : 1;
      let largeArcFlag = 0;
      let diff = endAngle - startAngle;
      if (diff < 0) {
        diff += 2 * Math.PI;
      }
      if (counterClockwise) {
        largeArcFlag = diff > Math.PI ? 0 : 1;
      } else {
        largeArcFlag = diff > Math.PI ? 1 : 0;
      }
      const currentTransform = g._transformMatrix;
      g.resetTransform();
      this.lineTo(startX, startY);
      g._transformMatrix = currentTransform;
      this.addPath(`A ${radiusX} ${radiusY} ${rotation * (180 / Math.PI)} ${largeArcFlag} ${sweepFlag} ${endX} ${endY}`);
      this._posX = endX;
      this._posY = endY;
    }
  };
  __name(Path2DSVG, "Path2DSVG");
  var CanvasGradientSVG = class {
    constructor(gradientElem, _ctx) {
      this.gradientElem = gradientElem;
      this._ctx = _ctx;
    }
    addColorStop(offset2, color) {
      const stop = this._ctx._createElement("stop");
      stop.setAttribute("offset", String(offset2));
      if (color.indexOf("rgba") !== -1) {
        const regex = /rgba\(\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
        const matches = regex.exec(color);
        if (matches) {
          stop.setAttribute("stop-color", `rgb(${matches[1]},${matches[2]},${matches[3]})`);
          stop.setAttribute("stop-opacity", matches[4]);
        } else {
          stop.setAttribute("stop-color", color);
        }
      } else {
        stop.setAttribute("stop-color", color);
      }
      this.gradientElem.appendChild(stop);
    }
  };
  __name(CanvasGradientSVG, "CanvasGradientSVG");
  var CanvasPatternSVG = class {
    constructor(patternElem, _ctx) {
      this.patternElem = patternElem;
      this._ctx = _ctx;
    }
  };
  __name(CanvasPatternSVG, "CanvasPatternSVG");
  function randomString(holder) {
    if (!holder) {
      throw new Error("cannot create a random attribute name for an undefined object");
    }
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
    let randomstring = "";
    do {
      randomstring = "";
      for (let i2 = 0; i2 < 12; i2++) {
        randomstring += chars[Math.floor(Math.random() * chars.length)];
      }
    } while (holder[randomstring] !== void 0);
    return randomstring;
  }
  __name(randomString, "randomString");
  var STYLES = {
    "strokeStyle": {
      svgAttr: "stroke",
      svg: "none",
      apply: "stroke"
    },
    "fillStyle": {
      svgAttr: "fill",
      svg: null,
      // svg default is black, but we need to special case this to handle canvas stroke without fill
      apply: "fill"
    },
    "lineCap": {
      svgAttr: "stroke-linecap",
      svg: "butt",
      apply: "stroke"
    },
    "lineJoin": {
      svgAttr: "stroke-linejoin",
      svg: "miter",
      apply: "stroke"
    },
    "miterLimit": {
      svgAttr: "stroke-miterlimit",
      svg: 4,
      apply: "stroke"
    },
    "lineWidth": {
      svgAttr: "stroke-width",
      svg: 1,
      apply: "stroke"
    },
    "globalAlpha": {
      svgAttr: "opacity",
      svg: 1,
      apply: "fill stroke"
    },
    "lineDash": {
      svgAttr: "stroke-dasharray",
      svg: null,
      apply: "stroke"
    }
  };
  var _textAnchorMapping = {
    left: "start",
    right: "end",
    center: "middle",
    start: "start",
    end: "end"
  };
  function getTextAnchor(textAlign) {
    var _a;
    return (_a = _textAnchorMapping[textAlign]) != null ? _a : _textAnchorMapping.start;
  }
  __name(getTextAnchor, "getTextAnchor");
  var _dominantBaselineMapping = {
    alphabetic: "alphabetic",
    hanging: "hanging",
    top: "text-before-edge",
    bottom: "text-after-edge",
    middle: "central"
    // neither central nor middle are correct work in Illustrator
  };
  function getDominantBaseline(textBaseline) {
    var _a;
    return (_a = _dominantBaselineMapping[textBaseline]) != null ? _a : _dominantBaselineMapping.alphabetic;
  }
  __name(getDominantBaseline, "getDominantBaseline");
  function createNamedToNumberedLookup(itemsStr, radix) {
    const lookup = {};
    const items = itemsStr.split(",");
    radix = radix != null ? radix : 10;
    for (let i2 = 0; i2 < items.length; i2 += 2) {
      const entity = "&" + items[i2 + 1] + ";";
      const base10 = parseInt(items[i2], radix);
      lookup[entity] = "&#" + base10 + ";";
    }
    lookup["\\xa0"] = "&#160;";
    return lookup;
  }
  __name(createNamedToNumberedLookup, "createNamedToNumberedLookup");
  var namedEntities = createNamedToNumberedLookup(
    "50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro",
    32
  );

  // simulator/src/components/Output.ts
  var t16 = __toESM(require_lib());
  var OutputDef = defineParametrizedComponent(ComponentTypeOutput, true, false, {
    variantName: ({ bits }) => `out-${bits}`,
    idPrefix: "out",
    button: { imgWidth: 32 },
    repr: {
      bits: typeOrUndefined(t16.number),
      name: ComponentNameRepr
    },
    valueDefaults: {},
    params: InputDef.paramDefs,
    validateParams: ({ bits }) => ({
      numBits: bits
    }),
    size: ({ numBits }) => {
      if (numBits === 1) {
        const d = INPUT_OUTPUT_DIAMETER / GRID_STEP;
        return { gridWidth: d, gridHeight: d };
      }
      return {
        gridWidth: 2,
        gridHeight: useCompact(numBits) ? numBits : 2 * numBits
      };
    },
    makeNodes: ({ numBits }) => ({
      ins: {
        In: groupVertical("w", numBits === 1 ? -3 : -2, 0, numBits, void 0, { hasTriangle: numBits !== 1 })
      }
    }),
    initialValue: (saved, { numBits }) => ArrayFillWith(false, numBits)
  });
  var Output = class extends ParametrizedComponentBase {
    constructor(parent, params, saved) {
      var _a;
      super(parent, OutputDef.with(params), saved);
      this.numBits = params.numBits;
      this._name = (_a = saved == null ? void 0 : saved.name) != null ? _a : void 0;
    }
    toJSON() {
      return __spreadProps(__spreadValues({}, this.toJSONBase()), {
        bits: this.numBits === OutputDef.aults.bits ? void 0 : this.numBits,
        name: this._name
      });
    }
    isOver(x, y) {
      if (this.numBits === 1) {
        return this.parent.mode >= 2 /* CONNECT */ && distSquared(x, y, this.posX, this.posY) < __pow(INPUT_OUTPUT_DIAMETER / 2, 2);
      }
      return super.isOver(x, y);
    }
    get name() {
      return this._name;
    }
    contentRepr(undefinedIfTrivial) {
      return reprForLogicValues(this.value, undefinedIfTrivial);
    }
    makeTooltip() {
      const s = S.Components.Output.tooltip;
      return tooltipContent(void 0, mods(s.title.expand({ numBits: this.numBits })));
    }
    doRecalcValue() {
      return this.inputValues(this.inputs.In);
    }
    doDraw(g, ctx) {
      if (this.numBits === 1) {
        this.doDrawSingle(g, ctx, this.inputs.In[0]);
      } else {
        this.doDrawMulti(g, ctx, this.inputs.In);
      }
    }
    doDrawSingle(g, ctx, input2) {
      drawWireLineToComponent(g, input2);
      g.strokeStyle = ctx.borderColor;
      g.fillStyle = ctx.borderColor;
      g.beginPath();
      triangle(
        g,
        this.posX - INPUT_OUTPUT_DIAMETER / 2 - 5,
        this.posY - 5,
        this.posX - INPUT_OUTPUT_DIAMETER / 2 - 5,
        this.posY + 5,
        this.posX - INPUT_OUTPUT_DIAMETER / 2 - 1,
        this.posY
      );
      g.lineWidth = 2;
      g.fill();
      g.stroke();
      const valueToShow = this.parent.editor.options.hideOutputColors ? Unknown : input2.value;
      g.fillStyle = colorForLogicValue(valueToShow);
      g.lineWidth = 4;
      g.beginPath();
      circle(g, this.posX, this.posY, INPUT_OUTPUT_DIAMETER);
      g.fill();
      g.stroke();
      ctx.inNonTransformedFrame((ctx2) => {
        if (this._name !== void 0) {
          drawComponentName(g, ctx2, this._name, toLogicValueRepr(valueToShow), this, true);
        }
        drawValueTextCentered(g, valueToShow, this);
      });
    }
    doDrawMulti(g, ctx, inputs) {
      const bounds = this.bounds();
      const { left: left2, top: top2, width } = bounds;
      const outline = bounds.outline(g);
      g.fillStyle = COLOR_BACKGROUND;
      g.fill(outline);
      for (const input2 of inputs) {
        drawWireLineToComponent(g, input2);
      }
      const displayValues = this.parent.editor.options.hideOutputColors ? ArrayFillWith(Unknown, this.numBits) : this.value;
      const drawMouseOver = ctx.isMouseOver && this.parent.mode !== 0 /* STATIC */;
      g.strokeStyle = drawMouseOver ? ctx.borderColor : COLOR_COMPONENT_BORDER;
      g.lineWidth = 1;
      const cellHeight = useCompact(this.numBits) ? GRID_STEP : 2 * GRID_STEP;
      for (let i2 = 0; i2 < this.numBits; i2++) {
        const y = top2 + i2 * cellHeight;
        g.fillStyle = colorForLogicValue(displayValues[i2]);
        g.beginPath();
        g.rect(left2, y, width, cellHeight);
        g.fill();
        g.stroke();
      }
      g.lineWidth = 3;
      g.stroke(outline);
      ctx.inNonTransformedFrame((ctx2) => {
        if (this._name !== void 0) {
          const valueString = displayValues.map(toLogicValueRepr).reverse().join("");
          drawComponentName(g, ctx2, this._name, valueString, this, true);
        }
        for (let i2 = 0; i2 < this.numBits; i2++) {
          const y = top2 + cellHeight / 2 + i2 * cellHeight;
          drawValueText(g, displayValues[i2], ...ctx2.rotatePoint(this.posX, y), { small: useCompact(this.numBits) });
        }
      });
    }
    autoConnected(newLinks) {
      if (newLinks.length !== 1) {
        return;
      }
      const [inNode, comp, outNode] = newLinks[0];
      if (outNode instanceof NodeOut) {
        let group2;
        if ((group2 = outNode.group) !== void 0 && group2.nodes.length === 1 && !isTrivialNodeName(group2.name)) {
          this.doSetName(group2.name);
        } else if (this._name === void 0 && !isTrivialNodeName(outNode.shortName)) {
          this.doSetName(outNode.shortName);
        }
      }
      if (inNode.orient !== "w") {
        return;
      }
      switch (Orientation.add(comp.orient, outNode.orient)) {
        case "e":
          return;
        case "w":
          this.doSetOrient("w");
          this.setPosition(this.posX - GRID_STEP * 6, this.posY, false);
          return;
        case "s":
          this.doSetOrient("s");
          this.setPosition(this.posX - GRID_STEP * 3, this.posY + GRID_STEP * 3, false);
          return;
        case "n":
          this.doSetOrient("n");
          this.setPosition(this.posX - GRID_STEP * 3, this.posY - GRID_STEP * 3, false);
          return;
      }
    }
    doSetName(name2) {
      this._name = name2;
      this.requestRedraw({ why: "name changed" });
    }
    makeComponentSpecificContextMenuItems() {
      return [
        ["mid", this.makeSetNameContextMenuItem(this._name, this.doSetName.bind(this))],
        ["mid", MenuData.sep()],
        this.makeChangeParamsContextMenuItem("inputs", S.Components.Generic.contextMenu.ParamNumBits, this.numBits, "bits")
      ];
    }
    keyDown(e) {
      if (e.key === "Enter" && !e.altKey) {
        this.runSetNameDialog(this._name, this.doSetName.bind(this));
      } else {
        super.keyDown(e);
      }
    }
  };
  __name(Output, "Output");
  OutputDef.impl = Output;

  // simulator/src/components/CustomComponent.ts
  var CustomComponentPrefix = "custom-";
  var CustomComponentImageWidth = 50;
  var CustomComponentImageHeight = 34;
  var CustomComponentDefRepr = t17.type({
    id: t17.string,
    caption: t17.string,
    circuit: t17.type({
      components: typeOrUndefined(t17.record(t17.string, t17.record(t17.string, t17.unknown))),
      wires: typeOrUndefined(t17.array(Wire.Repr))
    })
  });
  var CustomComponentDef = class {
    constructor(data2) {
      this.numBySide = { n: 0, e: 0, s: 0, w: 0 };
      var _a, _b, _c;
      this.customId = data2.id;
      this._caption = data2.caption;
      this.circuit = data2.circuit;
      this.insOuts = [];
      let totalIn = 0;
      let totalOut = 0;
      const components = (_a = this.circuit.components) != null ? _a : {};
      for (const [id, repr_] of Object.entries(components)) {
        const repr = repr_;
        const isIn = repr.type === "in" && !((_b = repr.isConstant) != null ? _b : false);
        const isOut = repr.type === "out";
        if (isIn || isOut) {
          const inOutRepr = repr;
          const name2 = isString(inOutRepr.name) ? inOutRepr.name : isIn ? "In" : "Out";
          let orient = Orientations.includes(inOutRepr.orient) ? inOutRepr.orient : Orientation.default;
          orient = isIn ? Orientation.invert(orient) : orient;
          const numBits = Number((_c = inOutRepr.bits) != null ? _c : 1);
          this.numBySide[orient] += numBits;
          const sourcePos = isArray(inOutRepr.pos) && inOutRepr.pos.length === 2 ? inOutRepr.pos.map(Number) : [0, 0];
          this.insOuts.push({ isIn, id, name: name2, orient, numBits, sourcePos, sourceRepr: inOutRepr });
          delete components[id];
          if (isIn) {
            totalIn += numBits;
          } else {
            totalOut += numBits;
          }
        }
      }
      sortInputsOutputs(this.insOuts);
      for (const spec of this.insOuts) {
        components[spec.id] = spec.sourceRepr;
      }
      this.numInputs = totalIn;
      this.numOutputs = totalOut;
      this.recalcSize();
    }
    toJSON() {
      return {
        id: this.customId,
        caption: this._caption,
        circuit: this.circuit
      };
    }
    get id() {
      return CustomComponentPrefix + this.customId;
    }
    get caption() {
      return this._caption;
    }
    doSetCaption(caption) {
      this._caption = caption;
      this.recalcSize();
    }
    recalcSize() {
      const spacing = 2;
      const margin = 1.5;
      const minSize = 1 * this._caption.length + 2;
      this.gridWidth = Math.ceil(Math.max(minSize, (Math.max(this.numBySide.s, this.numBySide.n) - 1) * spacing + 2 * margin));
      this.gridHeight = Math.ceil(Math.max(minSize, (Math.max(this.numBySide.e, this.numBySide.w) - 1) * spacing + 2 * margin));
    }
    // ComponentMaker interface
    isValid() {
      return true;
    }
    get type() {
      return CustomComponentPrefix + this.customId;
    }
    uses(type7, alsoIndirect) {
      var _a, _b;
      const compReprs = this.circuit.components;
      if (compReprs === void 0) {
        return false;
      }
      const whitelist = [];
      for (const compRepr of Object.values(compReprs)) {
        const compType = String(compRepr.type);
        if (compType === type7) {
          return true;
        } else if (alsoIndirect !== false && compType.startsWith(CustomComponentPrefix) && !whitelist.includes(compType)) {
          const factory = alsoIndirect[1];
          const customId = compType.substring(CustomComponentPrefix.length);
          if ((_b = (_a = factory.getCustomDef(customId)) == null ? void 0 : _a.uses(type7, alsoIndirect)) != null ? _b : false) {
            return true;
          }
          whitelist.push(compType);
        }
      }
      return false;
    }
    make(parent) {
      const comp = new CustomComponent(parent, this);
      parent.components.add(comp);
      return comp;
    }
    makeFromJSON(parent, data2) {
      const validated = validateJson(data2, CustomComponentRepr, "CustomComponent");
      if (validated === void 0) {
        return void 0;
      }
      const comp = new CustomComponent(parent, this, validated);
      parent.components.add(comp);
      return comp;
    }
    makeButtonSVG() {
      const width = CustomComponentImageWidth;
      const height = CustomComponentImageHeight;
      const g = new SVGRenderingContext(width, height);
      g.rect(10, 2, 30, 30);
      g.strokeStyle = "currentColor";
      g.lineWidth = 2;
      g.stroke();
      const maxHeight = 24;
      const stdSep = 6;
      const drawInsOuts = /* @__PURE__ */ __name((n, left2, right2) => {
        const sep = (n - 1) * stdSep <= maxHeight ? stdSep : maxHeight / (n - 1);
        const top2 = height / 2 - (n - 1) * sep / 2;
        for (let i2 = 0; i2 < n; i2++) {
          const y = top2 + i2 * sep;
          g.moveTo(left2, y);
          g.lineTo(right2, y);
        }
      }, "drawInsOuts");
      g.lineWidth = 1;
      const maxDrawnIO = 10;
      drawInsOuts(Math.min(maxDrawnIO, this.numInputs), 2, 10);
      drawInsOuts(Math.min(maxDrawnIO, this.numOutputs), 40, 48);
      g.stroke();
      let drawCaption = this._caption;
      let shortened = false;
      while (true) {
        let fontSize = 15;
        g.font = `${fontSize}px sans-serif`;
        const textWidth = g.measureText(drawCaption).width;
        const scale = (width - 24) / textWidth;
        if (scale < 1) {
          fontSize = Math.floor(scale * fontSize);
          g.font = `${fontSize}px sans-serif`;
        }
        if (fontSize >= 8) {
          g.fillStyle = "currentColor";
          g.textAlign = "center";
          fillTextVAlign(g, TextVAlign.middle, drawCaption + (shortened ? "." : ""), width / 2, height / 2);
          break;
        }
        drawCaption = drawCaption.slice(0, -1);
        shortened = true;
      }
      return g.getSvg();
    }
    // ComponentDef creation
    toStandardDef() {
      return defineComponent(CustomComponentPrefix + this.customId, {
        idPrefix: this.customId,
        button: { imgWidth: 50 },
        valueDefaults: {},
        size: { gridWidth: this.gridWidth, gridHeight: this.gridHeight },
        makeNodes: ({ gridWidth, gridHeight }) => {
          const right2 = gridWidth / 2 + 1;
          const left2 = -right2;
          const bottom2 = gridHeight / 2 + 1;
          const top2 = -bottom2;
          const starts = {
            n: this.numBySide.n - 1,
            e: -(this.numBySide.e - 1),
            s: this.numBySide.s - 1,
            w: -(this.numBySide.w - 1)
          };
          const counts = { n: 0, e: 0, s: 0, w: 0 };
          const make = /* @__PURE__ */ __name((spec) => {
            const { orient, numBits } = spec;
            const [x, y] = (() => {
              const f = Orientation.isVertical(orient) ? -1 : 1;
              const nextPos = starts[orient] + f * (counts[orient] + (numBits - 1) / 2) * 2;
              switch (orient) {
                case "e":
                  return [right2, nextPos];
                case "w":
                  return [left2, nextPos];
                case "n":
                  return [nextPos, top2];
                case "s":
                  return [nextPos, bottom2];
              }
            })();
            counts[orient] += numBits;
            return numBits === 1 ? [x, y, orient] : Orientation.isVertical(orient) ? groupHorizontal(orient, x, y, numBits) : groupVertical(orient, x, y, numBits);
          }, "make");
          const ins = {};
          const outs = {};
          for (const spec of this.insOuts) {
            (spec.isIn ? ins : outs)[spec.name] = make(spec);
          }
          return { ins, outs };
        },
        initialValue: () => ArrayFillWith(false, this.numOutputs)
      });
    }
  };
  __name(CustomComponentDef, "CustomComponentDef");
  var CustomComponentRepr = ComponentRepr(true, true);
  var CustomComponent = class extends ComponentBase {
    constructor(parent, customDef, saved) {
      super(parent, customDef.toStandardDef(), saved);
      this.components = new ComponentList();
      this.testSuites = new TestSuites(this);
      this.nodeMgr = new NodeManager();
      this.linkMgr = new LinkManager(this);
      this.recalcMgr = new RecalcManager();
      this._ifEditing = void 0;
      /// Other internals ///
      this._subcircuitInputs = [];
      this._subcircuitOutputs = [];
      this._customDef = customDef;
      this.numInputs = this.inputs._all.length;
      this.numOutputs = this.outputs._all.length;
      const error = Serialization.loadCircuitForCustomComponent(this, customDef.circuit);
      if (error !== void 0) {
        console.error("Failed to load custom component:", error);
        this.setInvalid();
      }
    }
    get customDef() {
      return this._customDef;
    }
    /// DrawableParent implementation ///
    isMainEditor() {
      return false;
    }
    get editor() {
      return this.parent.editor;
    }
    get mode() {
      return this.parent.mode;
    }
    get ifEditing() {
      return this._ifEditing;
    }
    stopEditingThis() {
      this._ifEditing = void 0;
    }
    startEditingThis(tools) {
      this._ifEditing = tools;
    }
    /**
     * Called by Serialization.loadCircuitOfCustomComponent after successfully loading a circuit;
     * can be seen as the rest of the constructor. It sets up the input and output nodes of this
     * CustomComponent according to the properties of the loaded Input/Output components.
     */
    circuitDidLoad() {
      this._subcircuitInputs.length = 0;
      this._subcircuitOutputs.length = 0;
      let iIn = 0;
      for (const comp of this.components.all()) {
        if (comp instanceof Input && !comp.isConstant) {
          this._subcircuitInputs.push(comp);
          comp.isCustomComponentInput = true;
          const nodes = comp.outputs._all;
          const num = nodes.length;
          if (num === 1 && comp.isLinkedToSomeClock) {
            this.inputs._all[iIn].isClock = true;
          }
          for (let i2 = 0; i2 < num; i2++) {
            const j = iIn + i2;
            if (j >= this.numInputs) {
              break;
            }
            this.inputs._all[j].prefersSpike = comp.isPushButton;
          }
          iIn += num;
        } else if (comp instanceof Output) {
          this._subcircuitOutputs.push(comp);
        }
      }
    }
    toStringDetails() {
      var _a, _b;
      return (_b = (_a = this.customDef) == null ? void 0 : _a.customId) != null ? _b : "";
    }
    toJSON() {
      return this.toJSONBase();
    }
    jsonType() {
      return CustomComponentPrefix + this.customDef.customId;
    }
    makeClone(setSpawning) {
      const repr = this.toNodelessJSON();
      const clone = new CustomComponent(this.parent, this.customDef, repr);
      this.parent.components.add(clone);
      if (setSpawning) {
        clone.setSpawning();
      }
      return clone;
    }
    updateFromDef() {
      const newDef = this.editor.factory.getCustomDef(this._customDef.customId);
      if (newDef === void 0) {
        console.warn("New custom component definition not found, using old one, but trouble is ahead");
      } else {
        this._customDef = newDef;
      }
      this.replaceWithComponent(this.makeClone(false));
    }
    doRecalcValue() {
      let bitOffset = 0;
      for (const inputComp of this._subcircuitInputs) {
        const numBits = inputComp.numBits;
        if (bitOffset + numBits > this.numInputs) {
          break;
        }
        inputComp.setValue(ArrayFillUsing((i2) => this.inputs._all[bitOffset + i2].value, numBits));
        inputComp.propagateCurrentValue();
        bitOffset += numBits;
      }
      this.recalcMgr.recalcAndPropagateIfNeeded();
      const outputs = [];
      for (const outputComp of this._subcircuitOutputs) {
        outputs.push(...outputComp.value);
      }
      return outputs;
    }
    propagateValue(newValue) {
      this.outputValues(this.outputs._all, newValue);
    }
    makeTooltip() {
      const s = S.Components.Custom.tooltip;
      return tooltipContent(mods(b(this.customDef.caption), span(s.titleSuffix)), mods(
        div(s.desc)
      ));
    }
    // TODO tooltip
    doDraw(g, ctx) {
      super.doDrawDefault(g, ctx, () => {
        g.font = `bold 18px sans-serif`;
        g.fillStyle = COLOR_COMPONENT_BORDER;
        g.textAlign = "center";
        fillTextVAlign(g, TextVAlign.middle, this.customDef.caption, this.posX, this.posY);
      });
    }
    makeComponentSpecificContextMenuItems() {
      const s = S.Components.Custom.contextMenu;
      return [
        ...this.makeForceOutputsContextMenuItem(),
        ["mid", MenuData.item("connect", s.ChangeCircuit, () => {
          this.tryOpenEditor();
        }, "\u21A9\uFE0E")]
      ];
    }
    keyDown(e) {
      if (e.key === "Enter" && !e.altKey) {
        this.tryOpenEditor();
      } else {
        super.keyDown(e);
      }
    }
    mouseDoubleClicked(e) {
      const result = super.mouseDoubleClicked(e);
      if (result.isChange) {
        return result;
      }
      return this.tryOpenEditor();
    }
    tryOpenEditor() {
      const s = S.Components.Custom.messages;
      let showOnly;
      if (!UIPermissions.canModifyCustomComponents(this.editor) || (showOnly = this.editor.options.showOnly) !== void 0 && !showOnly.includes(this._customDef.id)) {
        alert(s.CannotBeModified);
        return InteractionResult.NoChange;
      }
      if (!(this.editor.editorRoot instanceof LogicEditor)) {
        alert(s.NotInMainEditor);
        return InteractionResult.NoChange;
      }
      this.editor.setEditorRoot(this);
      this.editor.editTools.undoMgr.takeSnapshot();
      return InteractionResult.SimpleChange;
    }
  };
  __name(CustomComponent, "CustomComponent");
  function sortInputsOutputs(insOuts) {
    const orientValue = {
      e: 0,
      w: 1,
      n: 2,
      s: 3
    };
    const criterion = /* @__PURE__ */ __name((spec) => {
      return Orientation.isVertical(spec.orient) ? -spec.sourcePos[0] : spec.sourcePos[1];
    }, "criterion");
    insOuts.sort((a2, b2) => {
      return orientValue[a2.orient] - orientValue[b2.orient] || criterion(a2) - criterion(b2);
    });
  }
  __name(sortInputsOutputs, "sortInputsOutputs");

  // simulator/src/components/Decoder.ts
  var t18 = __toESM(require_lib());
  var DecoderDef = defineParametrizedComponent("dec", true, true, {
    variantName: ({ bits }) => `dec-${bits}`,
    idPrefix: "dec",
    button: { imgWidth: 50 },
    repr: {
      bits: typeOrUndefined(t18.number)
    },
    valueDefaults: {},
    params: {
      bits: param(2, [2, 3, 4, 5])
    },
    validateParams: ({ bits }) => ({
      numFrom: bits,
      numTo: __pow(2, bits)
    }),
    size: ({ numTo }) => ({
      gridWidth: 4,
      gridHeight: Math.max(8, 1 + numTo)
    }),
    makeNodes: ({ numFrom, numTo }) => ({
      ins: {
        In: groupVertical("w", -3, 0, numFrom)
      },
      outs: {
        Out: groupVertical("e", 3, 0, numTo)
      }
    }),
    initialValue: (saved, { numTo }) => ArrayFillWith(false, numTo)
  });
  var Decoder = class extends ParametrizedComponentBase {
    constructor(parent, params, saved) {
      super(parent, DecoderDef.with(params), saved);
      this.numFrom = params.numFrom;
      this.numTo = params.numTo;
    }
    toJSON() {
      return __spreadProps(__spreadValues({}, this.toJSONBase()), {
        bits: this.numFrom === DecoderDef.aults.bits ? void 0 : this.numFrom
      });
    }
    makeTooltip() {
      const s = S.Components.Decoder.tooltip;
      return tooltipContent(s.title, mods(
        div(s.desc.expand({ numFrom: this.numFrom, numTo: this.numTo, n: this.currentAddr() }))
      ));
    }
    currentAddr() {
      const addrArr = this.inputValues(this.inputs.In);
      return displayValuesFromArray(addrArr, false)[1];
    }
    doRecalcValue() {
      const addr = this.currentAddr();
      if (isUnknown(addr)) {
        return ArrayFillWith(Unknown, this.numTo);
      }
      const output = ArrayFillWith(false, this.numTo);
      output[addr] = true;
      return output;
    }
    doDraw(g, ctx) {
      this.doDrawDefault(g, ctx, {
        skipLabels: true,
        drawLabels: () => {
          g.font = `bold 14px sans-serif`;
          g.fillStyle = COLOR_COMPONENT_BORDER;
          g.textAlign = "center";
          fillTextVAlign(g, TextVAlign.middle, "Dec.", this.posX, this.posY);
        }
      });
    }
    propagateValue(newValue) {
      this.outputValues(this.outputs.Out, newValue);
    }
    makeComponentSpecificContextMenuItems() {
      return this.makeForceOutputsContextMenuItem();
    }
  };
  __name(Decoder, "Decoder");
  DecoderDef.impl = Decoder;

  // simulator/src/components/Decoder16Seg.ts
  var Decoder16SegDef = defineComponent("dec-16seg", {
    idPrefix: "dec",
    button: { imgWidth: 50 },
    valueDefaults: {},
    size: { gridWidth: 4, gridHeight: 10 },
    makeNodes: () => ({
      ins: {
        In: group("w", [
          [-3, -3],
          [-3, -2],
          [-3, -1],
          [-3, 0],
          [-3, 1],
          [-3, 2],
          [-3, 3]
        ])
      },
      outs: {
        Out: group("e", [
          [4, -4, "a1"],
          [3, -3.5, "a2"],
          [4, -3, "b"],
          [3, -2.5, "c"],
          [4, -2, "d2"],
          [3, -1.5, "d1"],
          [4, -1, "e"],
          [3, -0.5, "f"],
          [4, 0, "g1"],
          [3, 0.5, "g2"],
          [4, 1, "h"],
          [3, 1.5, "i"],
          [4, 2, "j"],
          [3, 2.5, "k"],
          [4, 3, "l"],
          [3, 3.5, "m"],
          [4, 4, "p"]
        ])
      }
    }),
    initialValue: () => FixedArrayFillWith(false, 17)
  });
  var Decoder16Seg = class extends ComponentBase {
    constructor(parent, saved) {
      super(parent, Decoder16SegDef, saved);
    }
    toJSON() {
      return this.toJSONBase();
    }
    makeTooltip() {
      return tooltipContent(void 0, mods(
        div(S.Components.Decoder16Seg.tooltip)
        // TODO better tooltip
      ));
    }
    doRecalcValue() {
      const input2 = this.inputValues(this.inputs.In);
      const [__, value] = displayValuesFromArray(input2, false);
      let output;
      if (isUnknown(value)) {
        output = FixedArrayFillWith(Unknown, 17);
      } else if (value < 32) {
        output = FixedArrayFillWith(false, 17);
      } else {
        const line = DECODER_MAPPING[value - 32];
        output = FixedArrayFillWith(false, 17);
        for (let i2 = 0; i2 < line.length; i2++) {
          output[i2] = line.charAt(i2) === "1";
        }
      }
      return output;
    }
    propagateValue(newValue) {
      this.outputValues(this.outputs.Out, newValue);
    }
    doDraw(g, ctx) {
      this.doDrawDefault(g, ctx, {
        skipLabels: true,
        drawInside: (bounds) => {
          this.drawGroupBox(g, this.inputs.In.group, bounds);
        },
        drawLabels: (ctx2, { left: left2, right: right2 }) => {
          g.fillStyle = COLOR_COMPONENT_INNER_LABELS;
          g.font = "bold 11px sans-serif";
          drawLabel(ctx2, this.orient, "C", "w", left2, this.inputs.In);
          g.font = "7px sans-serif";
          this.outputs._all.forEach((output) => {
            drawLabel(ctx2, this.orient, output.shortName, "e", right2, output);
          });
        }
      });
    }
    makeComponentSpecificContextMenuItems() {
      return this.makeForceOutputsContextMenuItem();
    }
  };
  __name(Decoder16Seg, "Decoder16Seg");
  Decoder16SegDef.impl = Decoder16Seg;
  var DECODER_MAPPING = [
    // starts at space, which is 32
    "00000000000000000",
    /* (space) */
    "00110000000000001",
    /* ! */
    "00100000000100000",
    /* " */
    "00111100110100100",
    /* # */
    "11011101110100100",
    /* $ */
    "10011001110111100",
    /* % */
    "10001110101100010",
    /* & */
    "00000000000100000",
    /* ' */
    "00000000000010010",
    /* ( */
    "00000000001001000",
    /* ) */
    "00000000111111110",
    /* * */
    "00000000110100100",
    /* + */
    "00000000000001000",
    /* , */
    "00000000110000000",
    /* - */
    "00000000000000001",
    /* . */
    "00000000000011000",
    /* / */
    "11111111000011000",
    /* 0 */
    "00110000000010000",
    /* 1 */
    "11101110110000000",
    /* 2 */
    "11111100010000000",
    /* 3 */
    "00110001110000000",
    /* 4 */
    "11001101100000010",
    /* 5 */
    "11011111110000000",
    /* 6 */
    "11110000000000000",
    /* 7 */
    "11111111110000000",
    /* 8 */
    "11111101110000000",
    /* 9 */
    "00000000000100100",
    /* : */
    "00000000000101000",
    /* ; */
    "00000000100010010",
    /* < */
    "00001100110000000",
    /* = */
    "00000000011001000",
    /* > */
    "11100000010000101",
    /* ? */
    "11101111010100000",
    /* @ */
    "11110011110000000",
    /* A */
    "11111100010100100",
    /* B */
    "11001111000000000",
    /* C */
    "11111100000100100",
    /* D */
    "11001111100000000",
    /* E */
    "11000011100000000",
    /* F */
    "11011111010000000",
    /* G */
    "00110011110000000",
    /* H */
    "11001100000100100",
    /* I */
    "00111110000000000",
    /* J */
    "00000011100010010",
    /* K */
    "00001111000000000",
    /* L */
    "00110011001010000",
    /* M */
    "00110011001000010",
    /* N */
    "11111111000000000",
    /* O */
    "11100011110000000",
    /* P */
    "11111111000000010",
    /* Q */
    "11100011110000010",
    /* R */
    "11011101110000000",
    /* S */
    "11000000000100100",
    /* T */
    "00111111000000000",
    /* U */
    "00000011000011000",
    /* V */
    "00110011000001010",
    /* W */
    "00000000001011010",
    /* X */
    "00111101110000000",
    /* Y */
    "11001100000011000",
    /* Z */
    "01001000000100100",
    /* [ */
    "00000000001000010",
    /* \ */
    "10000100000100100",
    /* ] */
    "00000000000001010",
    /* ^ */
    "00001100000000000",
    /* _ */
    "00000000001000000",
    /* ` */
    "00001110100000100",
    /* a */
    "00000111100000100",
    /* b */
    "00000110100000000",
    /* c */
    "00000110100100100",
    /* d */
    "00000110100001000",
    /* e */
    "10000011100000000",
    /* f */
    "10000101100100100",
    /* g */
    "00000011100000100",
    /* h */
    "00000000000000100",
    /* i */
    "00000100000100100",
    /* j */
    "00000000000110110",
    /* k */
    "00000000000100100",
    /* l */
    "00010010110000100",
    /* m */
    "00000010100000100",
    /* n */
    "00000110100000100",
    /* o */
    "10000011100100000",
    /* p */
    "10000001100100100",
    /* q */
    "00000010100000000",
    /* r */
    "10000101100000100",
    /* s */
    "00000111100000000",
    /* t */
    "00000110000000100",
    /* u */
    "00000010000001000",
    /* v */
    "00010010000001010",
    /* w */
    "00000000001011010",
    /* x */
    "00000101100100100",
    /* y */
    "00000100100001000",
    /* z */
    "01001000100100100",
    /* { */
    "00000000000100100",
    /* | */
    "10000100010100100",
    /* } */
    "00000000110011000",
    /* ~ */
    "00000000000000000"
    /* (del) */
  ];

  // simulator/src/components/Decoder7Seg.ts
  var Decoder7SegDef = defineComponent("dec-7seg", {
    idPrefix: "dec",
    button: { imgWidth: 50 },
    valueDefaults: {},
    size: { gridWidth: 4, gridHeight: 8 },
    makeNodes: () => ({
      ins: {
        In: group("w", [
          [-3, -3, "A"],
          [-3, -1, "B"],
          [-3, 1, "C"],
          [-3, 3, "D"]
        ])
      },
      outs: {
        Out: group("e", [
          [3, -3, "a"],
          [3, -2, "b"],
          [3, -1, "c"],
          [3, 0, "d"],
          [3, 1, "e"],
          [3, 2, "f"],
          [3, 3, "g"]
        ])
      }
    }),
    initialValue: () => FixedArrayFillWith(false, 7)
  });
  var Decoder7Seg = class extends ComponentBase {
    constructor(parent, saved) {
      super(parent, Decoder7SegDef, saved);
    }
    toJSON() {
      return this.toJSONBase();
    }
    makeTooltip() {
      return tooltipContent(void 0, mods(
        div(S.Components.Decoder7Seg.tooltip)
        // TODO better info
      ));
    }
    doRecalcValue() {
      const input2 = this.inputValues(this.inputs.In);
      const [__, value] = displayValuesFromArray(input2, false);
      let output;
      if (isUnknown(value)) {
        output = FixedArrayFillWith(Unknown, 7);
      } else {
        output = (() => {
          switch (value) {
            case 0:
              return [true, true, true, true, true, true, false];
            case 1:
              return [false, true, true, false, false, false, false];
            case 2:
              return [true, true, false, true, true, false, true];
            case 3:
              return [true, true, true, true, false, false, true];
            case 4:
              return [false, true, true, false, false, true, true];
            case 5:
              return [true, false, true, true, false, true, true];
            case 6:
              return [true, false, true, true, true, true, true];
            case 7:
              return [true, true, true, false, false, false, false];
            case 8:
              return [true, true, true, true, true, true, true];
            case 9:
              return [true, true, true, true, false, true, true];
            case 10:
              return [true, true, true, false, true, true, true];
            case 11:
              return [false, false, true, true, true, true, true];
            case 12:
              return [true, false, false, true, true, true, false];
            case 13:
              return [false, true, true, true, true, false, true];
            case 14:
              return [true, false, false, true, true, true, true];
            case 15:
              return [true, false, false, false, true, true, true];
            default:
              return FixedArrayFillWith(Unknown, 7);
          }
        })();
      }
      return output;
    }
    propagateValue(newValue) {
      this.outputValues(this.outputs.Out, newValue);
    }
    makeComponentSpecificContextMenuItems() {
      return this.makeForceOutputsContextMenuItem();
    }
  };
  __name(Decoder7Seg, "Decoder7Seg");
  Decoder7SegDef.impl = Decoder7Seg;

  // simulator/src/components/DecoderBCD4.ts
  var DecoderBCD4Def = defineComponent("dec-bcd4", {
    idPrefix: "bcd",
    button: { imgWidth: 50 },
    valueDefaults: {},
    size: { gridWidth: 5, gridHeight: 10 },
    makeNodes: () => ({
      ins: {
        In: group("w", [
          [-4, -3, "A"],
          [-4, -1, "B"],
          [-4, 1, "C"],
          [-4, 3, "D"]
        ])
      },
      outs: {
        Out: groupVertical("e", 4, 0, 5, 2)
      }
    }),
    initialValue: () => FixedArrayFillWith(false, 5)
  });
  var DecoderBCD4 = class extends ComponentBase {
    constructor(parent, saved) {
      super(parent, DecoderBCD4Def, saved);
    }
    toJSON() {
      return this.toJSONBase();
    }
    makeTooltip() {
      return tooltipContent(void 0, mods(
        div(S.Components.DecoderBCD4.tooltip)
      ));
    }
    doRecalcValue() {
      const input2 = this.inputValues(this.inputs.In);
      const [__, value] = displayValuesFromArray(input2, false);
      let output;
      if (isUnknown(value)) {
        output = FixedArrayFillWith(Unknown, 5);
      } else {
        output = (() => {
          switch (value) {
            case 0:
              return [false, false, false, false, false];
            case 1:
              return [false, false, false, false, true];
            case 2:
              return [false, false, false, true, false];
            case 3:
              return [false, false, false, true, true];
            case 4:
              return [false, false, true, false, false];
            case 5:
              return [false, false, true, false, true];
            case 6:
              return [false, false, true, true, false];
            case 7:
              return [false, false, true, true, true];
            case 8:
              return [false, true, false, false, false];
            case 9:
              return [false, true, false, false, true];
            case 10:
              return [true, false, false, false, false];
            case 11:
              return [true, false, false, false, true];
            case 12:
              return [true, false, false, true, false];
            case 13:
              return [true, false, false, true, true];
            case 14:
              return [true, false, true, false, false];
            case 15:
              return [true, false, true, false, true];
            default:
              return FixedArrayFillWith(Unknown, 5);
          }
        })();
      }
      return output;
    }
    propagateValue(newValue) {
      this.outputValues(this.outputs.Out, newValue, true);
    }
    makeComponentSpecificContextMenuItems() {
      return this.makeForceOutputsContextMenuItem();
    }
  };
  __name(DecoderBCD4, "DecoderBCD4");
  DecoderBCD4Def.impl = DecoderBCD4;

  // simulator/src/components/Demux.ts
  var t19 = __toESM(require_lib());
  var DemuxDef = defineParametrizedComponent("demux", true, true, {
    variantName: ({ from, to, bottom: bottom2 }) => `demux-${from}to${to}${bottom2 ? "b" : ""}`,
    idPrefix: "demux",
    button: { imgWidth: 50 },
    repr: {
      from: typeOrUndefined(t19.number),
      to: typeOrUndefined(t19.number),
      bottom: typeOrUndefined(t19.boolean),
      showWiring: typeOrUndefined(t19.boolean),
      disconnectedAsHighZ: typeOrUndefined(t19.boolean)
    },
    valueDefaults: {
      showWiring: true,
      disconnectedAsHighZ: false
    },
    params: {
      from: param(2, [1, 2, 4, 8, 16]),
      to: param(4),
      bottom: paramBool()
    },
    validateParams: ({ from, to, bottom: bottom2 }) => {
      const numTo = Math.min(16 * from, Math.max(2 * from, to));
      const numGroups = Math.ceil(numTo / from);
      const numSel = Math.ceil(Math.log2(numGroups));
      return { numFrom: from, numTo, numGroups, numSel, controlPinsAtBottom: bottom2 };
    },
    size: ({ numFrom, numTo, numGroups, numSel }) => {
      const gridWidth = 2 * numSel;
      const spacing = useCompact(numFrom === 1 ? numTo : numFrom) ? 1 : 2;
      const addByGroupSep = numFrom > 1 ? 1 : 0;
      const numLeftSlots = numTo + (numGroups - 1) * addByGroupSep;
      const gridHeight = spacing * numLeftSlots;
      return { gridWidth, gridHeight };
    },
    makeNodes: ({ numFrom, numGroups, numSel, controlPinsAtBottom }) => {
      const outX = 1 + numSel;
      const inX = -outX;
      const groupOfOutputs = groupVerticalMulti("e", outX, 0, numGroups, numFrom);
      const firstInputY = groupOfOutputs[0][0][1];
      const lastGroup = groupOfOutputs[groupOfOutputs.length - 1];
      const lastInputY = lastGroup[lastGroup.length - 1][1];
      const selY = controlPinsAtBottom ? lastInputY + 2 : firstInputY - 2;
      return {
        ins: {
          In: groupVertical("w", inX, 0, numFrom),
          S: groupHorizontal(controlPinsAtBottom ? "s" : "n", 0, selY, numSel, void 0, { leadLength: 35 })
        },
        outs: {
          Z: groupOfOutputs
        }
      };
    },
    initialValue: (saved, { numTo }) => ArrayFillWith(false, numTo)
  });
  var Demux = class extends ParametrizedComponentBase {
    constructor(parent, params, saved) {
      var _a, _b;
      super(parent, DemuxDef.with(params), saved);
      this.numFrom = params.numFrom;
      this.numTo = params.numTo;
      this.numGroups = params.numGroups;
      this.numSel = params.numSel;
      this.controlPinsAtBottom = params.controlPinsAtBottom;
      this._showWiring = (_a = saved == null ? void 0 : saved.showWiring) != null ? _a : DemuxDef.aults.showWiring;
      this._disconnectedAsHighZ = (_b = saved == null ? void 0 : saved.disconnectedAsHighZ) != null ? _b : DemuxDef.aults.disconnectedAsHighZ;
    }
    toJSON() {
      return __spreadProps(__spreadValues({}, super.toJSONBase()), {
        from: this.numFrom,
        to: this.numTo,
        bottom: this.controlPinsAtBottom === DemuxDef.aults.bottom ? void 0 : this.controlPinsAtBottom,
        showWiring: this._showWiring !== DemuxDef.aults.showWiring ? this._showWiring : void 0,
        disconnectedAsHighZ: this._disconnectedAsHighZ !== DemuxDef.aults.disconnectedAsHighZ ? this._disconnectedAsHighZ : void 0
      });
    }
    makeTooltip() {
      return tooltipContent(void 0, mods(
        div(S.Components.Demux.tooltip.expand({ from: this.numFrom, to: this.numTo }))
        // TODO better tooltip
      ));
    }
    doRecalcValue() {
      const sels = this.inputValues(this.inputs.S);
      const sel = displayValuesFromArray(sels, false)[1];
      if (isUnknown(sel)) {
        return ArrayFillWith(Unknown, this.numTo);
      }
      const values = [];
      const disconnected = this._disconnectedAsHighZ ? HighImpedance : false;
      for (let g = 0; g < this.numGroups; g++) {
        if (g === sel) {
          const inputs = this.inputValues(this.inputs.In);
          for (const input2 of inputs) {
            values.push(input2);
          }
        } else {
          for (let i2 = 0; i2 < this.numFrom; i2++) {
            values.push(disconnected);
          }
        }
      }
      return values;
    }
    propagateValue(newValues) {
      this.outputValues(this.outputs._all, newValues);
    }
    doDraw(g, ctx) {
      const { top: top2, left: left2, bottom: bottom2, right: right2 } = this.bounds();
      const dy = (right2 - left2) / 3;
      for (const input2 of this.inputs.In) {
        drawWireLineToComponent(g, input2);
      }
      for (const sel of this.inputs.S) {
        drawWireLineToComponent(g, sel);
      }
      for (const outputGroup of this.outputs.Z) {
        for (const output of outputGroup) {
          drawWireLineToComponent(g, output);
        }
      }
      const outline = g.createPath();
      outline.moveTo(left2, top2 + dy);
      outline.lineTo(right2, top2);
      outline.lineTo(right2, bottom2);
      outline.lineTo(left2, bottom2 - dy);
      outline.closePath();
      g.fillStyle = COLOR_BACKGROUND;
      g.fill(outline);
      if (this._showWiring) {
        const neutral = this.parent.editor.options.hideWireColors;
        const sels = this.inputValues(this.inputs.S);
        const sel = displayValuesFromArray(sels, false)[1];
        if (!isUnknown(sel)) {
          const selectedOutputs = this.outputs.Z[sel];
          const anchorDiffX = (right2 - left2) / 3;
          const wireStyle = this.parent.editor.options.wireStyle;
          const wireStyleBezier = wireStyle === WireStyles.bezier || wireStyle === WireStyles.auto;
          const timeFraction = ctx.drawParams.drawTimeAnimationFraction;
          for (let i2 = 0; i2 < this.inputs.In.length; i2++) {
            g.beginPath();
            const fromNode = this.inputs.In[i2];
            const fromY = fromNode.posYInParentTransform;
            const toY = selectedOutputs[i2].posYInParentTransform;
            g.moveTo(left2 + 1, fromY);
            if (!wireStyleBezier) {
              g.lineTo(left2 + 3, fromY);
              g.lineTo(right2 - 3, toY);
              g.lineTo(right2 - 1, toY);
            } else {
              g.bezierCurveTo(
                left2 + anchorDiffX,
                fromY,
                // anchor left
                right2 - anchorDiffX,
                toY,
                // anchor right
                right2 - 1,
                toY
              );
            }
            strokeWireOutlineAndSingleValue(g, this.inputs.In[i2].value, fromNode.color, neutral, timeFraction);
          }
        }
      }
      g.lineWidth = 3;
      g.strokeStyle = ctx.borderColor;
      g.stroke(outline);
    }
    doSetShowWiring(showWiring) {
      this._showWiring = showWiring;
      this.requestRedraw({ why: "show wiring changed" });
    }
    doSetDisconnectedAsHighZ(disconnectedAsHighZ) {
      this._disconnectedAsHighZ = disconnectedAsHighZ;
      this.setNeedsRecalc();
    }
    makeComponentSpecificContextMenuItems() {
      const s = S.Components.MuxDemux.contextMenu;
      let icon = this._showWiring ? "check" : "none";
      const toggleShowWiringItem = MenuData.item(icon, s.ShowWiring, () => {
        this.doSetShowWiring(!this._showWiring);
      });
      icon = this._disconnectedAsHighZ ? "check" : "none";
      const toggleUseHighZItem = MenuData.item(icon, s.UseZForDisconnected, () => {
        this.doSetDisconnectedAsHighZ(!this._disconnectedAsHighZ);
      });
      return [
        this.makeChangeParamsContextMenuItem("inputs", s.ParamNumFrom, this.numFrom, "from"),
        this.makeChangeParamsContextMenuItem("outputs", s.ParamNumTo, this.numTo, "to", [2, 4, 8, 16].map((x) => x * this.numFrom)),
        ["mid", MenuData.sep()],
        this.makeChangeBooleanParamsContextMenuItem(this.numSel === 1 ? S.Components.Generic.contextMenu.ParamControlBitAtBottom : S.Components.Generic.contextMenu.ParamControlBitsAtBottom, this.controlPinsAtBottom, "bottom"),
        ["mid", toggleShowWiringItem],
        ["mid", toggleUseHighZItem],
        ...this.makeForceOutputsContextMenuItem(true)
      ];
    }
  };
  __name(Demux, "Demux");
  DemuxDef.impl = Demux;

  // simulator/src/components/Display.ts
  var t20 = __toESM(require_lib());
  var DisplayDef = defineParametrizedComponent("display", true, false, {
    variantName: ({ bits }) => `display-${bits}`,
    idPrefix: "disp",
    button: { imgWidth: 32 },
    repr: {
      bits: typeOrUndefined(t20.number),
      name: ComponentNameRepr,
      radix: typeOrUndefined(t20.number),
      showAsUnknown: typeOrUndefined(t20.boolean)
    },
    valueDefaults: {
      radix: 10,
      showAsUnknown: false
    },
    params: {
      bits: param(4, [3, 4, 8, 16])
    },
    validateParams: ({ bits }) => ({
      numBits: bits
    }),
    size: ({ numBits }) => ({
      gridWidth: 2 + Math.ceil(numBits / 2),
      gridHeight: useCompact(numBits) ? numBits : 2 * numBits
    }),
    makeNodes: ({ numBits, gridWidth }) => {
      const inX = -gridWidth / 2 - 1;
      return {
        ins: {
          In: groupVertical("w", inX, 0, numBits)
        }
      };
    },
    initialValue: (saved, { numBits }) => [repeatString2("0", numBits), 0]
  });
  var Display = class extends ParametrizedComponentBase {
    constructor(parent, params, saved) {
      var _a, _b, _c;
      super(parent, DisplayDef.with(params), saved);
      this.numBits = params.numBits;
      this._name = (_a = saved == null ? void 0 : saved.name) != null ? _a : void 0;
      this._radix = (_b = saved == null ? void 0 : saved.radix) != null ? _b : DisplayDef.aults.radix;
      this._showAsUnknown = (_c = saved == null ? void 0 : saved.showAsUnknown) != null ? _c : DisplayDef.aults.showAsUnknown;
    }
    toJSON() {
      return __spreadProps(__spreadValues({}, this.toJSONBase()), {
        bits: this.numBits === DisplayDef.aults.bits ? void 0 : this.numBits,
        name: this._name,
        radix: this._radix === DisplayDef.aults.radix ? void 0 : this._radix,
        showAsUnknown: this._showAsUnknown === DisplayDef.aults.showAsUnknown ? void 0 : this._showAsUnknown
      });
    }
    get showAsUnknown() {
      return this._showAsUnknown || this.parent.editor.options.hideOutputColors;
    }
    makeTooltip() {
      const s = S.Components.Display.tooltip;
      const radixStr = (() => {
        switch (this._radix) {
          case 2:
            return s.RadixBinary;
          case 10:
            return s.RadixDecimal;
          case -10:
            return s.RadixSignedDecimal;
          case 16:
            return s.RadixHexadecimal;
          default:
            return s.RadixGeneric.expand({ radix: this._radix });
        }
      })();
      const [binaryStringRep, value] = this.value;
      const sParams = { numBits: this.numBits, radixStr };
      return tooltipContent(s.title.expand(sParams), mods(
        div(s.desc[0].expand(sParams) + " ", b(binaryStringRep), s.desc[1]),
        !isUnknown(value) || this.showAsUnknown ? emptyMod : div(s.CurrentlyUndefined)
      ));
    }
    doRecalcValue() {
      return displayValuesFromArray(this.inputValues(this.inputs.In), false);
    }
    doDraw(g, ctx) {
      const [binaryStringRep, value] = this.value;
      const maxValue = (1 << this.inputs.In.length) - 1;
      const background = isUnknown(value) || this.showAsUnknown ? COLOR_UNKNOWN : colorForFraction(value / maxValue);
      this.doDrawDefault(g, ctx, {
        background,
        skipLabels: true,
        componentName: [this._name, true, value],
        drawLabels: (ctx2, { width, height }) => {
          const isVertical = Orientation.isVertical(this.orient);
          const backColorComps = colorCompsRGB(background);
          const textColor = ColorString2(backColorComps[0] + backColorComps[1] + backColorComps[2] > 3 * 127 ? 0 : 255);
          g.fillStyle = textColor;
          g.textAlign = "center";
          if (!this.showAsUnknown) {
            const [hasSpaces, spacedStringRep] = insertSpaces(binaryStringRep, this._radix);
            g.font = `${hasSpaces ? 9 : 10}px sans-serif`;
            fillTextVAlign(g, TextVAlign.middle, spacedStringRep, this.posX, this.posY + (isVertical ? -width / 2 + 7 : -height / 2 + 8));
          }
          const mainSize = this.numBits === 4 && this._radix === 8 ? 16 : 18;
          g.font = `bold ${mainSize}px sans-serif`;
          const stringRep = this.showAsUnknown ? Unknown : formatWithRadix(value, this._radix, this.numBits);
          fillTextVAlign(g, TextVAlign.middle, stringRep, this.posX, this.posY + (isVertical ? 6 : 0));
        }
      });
    }
    mouseDoubleClicked(e) {
      const superChange = super.mouseDoubleClicked(e);
      if (superChange.isChange) {
        return superChange;
      }
      const mode = this.parent.mode;
      if (mode >= 4 /* FULL */ && e.altKey) {
        this.doSetShowAsUnknown(!this._showAsUnknown);
        return InteractionResult.SimpleChange;
      } else if (mode >= 3 /* DESIGN */) {
        this.doSetRadix(this._radix === 10 ? 16 : 10);
        return InteractionResult.SimpleChange;
      }
      return InteractionResult.NoChange;
    }
    doSetName(name2) {
      this._name = name2;
      this.requestRedraw({ why: "name changed" });
    }
    doSetShowAsUnknown(showAsUnknown) {
      this._showAsUnknown = showAsUnknown;
      this.requestRedraw({ why: "display as unknown changed" });
    }
    doSetRadix(radix) {
      this._radix = radix;
      this.requestRedraw({ why: "radix changed" });
    }
    makeComponentSpecificContextMenuItems() {
      const s = S.Components.Display.contextMenu;
      const makeItemShowAs = /* @__PURE__ */ __name((desc, handler, isCurrent) => {
        const icon = isCurrent ? "check" : "none";
        const caption = s.DisplayAs + " " + desc;
        const action = isCurrent ? () => void 0 : handler;
        return MenuData.item(icon, caption, action);
      }, "makeItemShowAs");
      const makeItemShowRadix = /* @__PURE__ */ __name((radix, desc) => {
        return makeItemShowAs(desc, () => {
          if (this._showAsUnknown) {
            this.doSetShowAsUnknown(false);
          }
          this.doSetRadix(radix);
        }, !this._showAsUnknown && this._radix === radix);
      }, "makeItemShowRadix");
      return [
        ["mid", makeItemShowRadix(10, s.DisplayAsDecimal)],
        ["mid", makeItemShowRadix(-10, s.DisplayAsSignedDecimal)],
        ["mid", makeItemShowRadix(8, s.DisplayAsOctal)],
        ["mid", makeItemShowRadix(16, s.DisplayAsHexadecimal)],
        ["mid", makeItemShowAs(s.DisplayAsUnknown, () => this.doSetShowAsUnknown(!this._showAsUnknown), this._showAsUnknown)],
        ["mid", MenuData.sep()],
        this.makeChangeParamsContextMenuItem("inputs", S.Components.Generic.contextMenu.ParamNumBits, this.numBits, "bits"),
        ["mid", MenuData.sep()],
        ["mid", this.makeSetNameContextMenuItem(this._name, this.doSetName.bind(this))]
      ];
    }
    keyDown(e) {
      if (e.key === "Enter" && !e.altKey) {
        this.runSetNameDialog(this._name, this.doSetName.bind(this));
      } else {
        super.keyDown(e);
      }
    }
  };
  __name(Display, "Display");
  DisplayDef.impl = Display;
  function repeatString2(s, n) {
    let result = "";
    for (let i2 = 0; i2 < n; i2++) {
      result += s;
    }
    return result;
  }
  __name(repeatString2, "repeatString");
  function insertSpaces(binaryStringRep, radix) {
    let n = -1;
    if (radix === 16) {
      n = 4;
    } else if (radix === 8) {
      n = 3;
    }
    if (n < 0) {
      return [false, binaryStringRep];
    }
    const re = new RegExp(`(.{${n}})`, "g");
    const spaced = reverseString(reverseString(binaryStringRep).replace(re, "$1 "));
    return [true, spaced];
  }
  __name(insertSpaces, "insertSpaces");
  function reverseString(str) {
    return str.split("").reverse().join("");
  }
  __name(reverseString, "reverseString");

  // simulator/src/components/Display16Seg.ts
  var t22 = __toESM(require_lib());

  // simulator/src/components/DisplayBar.ts
  var t21 = __toESM(require_lib());
  var LedColors = {
    green: null,
    red: null,
    yellow: null
  };
  var DisplayBarTypes = {
    v: null,
    h: null,
    px: null,
    PX: null
  };
  function ledColorForLogicValue(v, onColor) {
    return isUnknown(v) ? COLOR_UNKNOWN : isHighImpedance(v) ? COLOR_HIGH_IMPEDANCE : v ? COLOR_LED_ON[onColor] : COLOR_WIRE_BORDER;
  }
  __name(ledColorForLogicValue, "ledColorForLogicValue");
  var DisplayBarBase = class extends ComponentBase {
    constructor(parent, SubclassDef, transparentDefault, saved) {
      var _a, _b, _c;
      super(parent, SubclassDef, saved);
      this.transparentDefault = transparentDefault;
      this._color = (_a = saved == null ? void 0 : saved.color) != null ? _a : DisplayBarDef.aults.color;
      this._transparent = (_b = saved == null ? void 0 : saved.transparent) != null ? _b : transparentDefault;
      this._name = (_c = saved == null ? void 0 : saved.name) != null ? _c : void 0;
    }
    toJSONBase() {
      return __spreadProps(__spreadValues({}, super.toJSONBase()), {
        color: this._color === DisplayBarDef.aults.color ? void 0 : this._color,
        transparent: this._transparent === this.transparentDefault ? void 0 : this._transparent,
        name: this._name
      });
    }
    doSetName(name2) {
      this._name = name2;
      this.requestRedraw({ why: "name changed" });
    }
    doSetColor(color) {
      this._color = color;
      this.requestRedraw({ why: "color changed" });
    }
    doSetTransparent(transparent) {
      this._transparent = transparent;
      this.requestRedraw({ why: "transparent changed" });
    }
    makeComponentSpecificContextMenuItems() {
      const s = S.Components.DisplayBar.contextMenu;
      const makeItemUseColor = /* @__PURE__ */ __name((desc, color) => {
        const isCurrent = this._color === color;
        const icon = isCurrent ? "check" : "none";
        const action = isCurrent ? () => void 0 : () => this.doSetColor(color);
        const cssColor = COLOR_LED_ON[color];
        return MenuData.item(icon, span(title(desc), style(`display: inline-block; width: 140px; height: 16px; background-color: ${cssColor}; margin-right: 8px`)), action);
      }, "makeItemUseColor");
      const itemTransparent = MenuData.item(
        this._transparent ? "check" : "none",
        s.TransparentWhenOff,
        () => this.doSetTransparent(!this._transparent)
      );
      return [
        ["mid", MenuData.submenu("palette", s.Color, [
          makeItemUseColor(s.ColorGreen, "green"),
          makeItemUseColor(s.ColorRed, "red"),
          makeItemUseColor(s.ColorYellow, "yellow"),
          MenuData.sep(),
          itemTransparent
        ])],
        ["mid", this.makeSetNameContextMenuItem(this._name, this.doSetName.bind(this))]
      ];
    }
    keyDown(e) {
      if (e.key === "Enter" && !e.altKey) {
        this.runSetNameDialog(this._name, this.doSetName.bind(this));
      } else {
        super.keyDown(e);
      }
    }
  };
  __name(DisplayBarBase, "DisplayBarBase");
  var DisplayBarDef = defineComponent("bar", {
    idPrefix: "bar",
    button: { imgWidth: 32 },
    repr: {
      display: t21.keyof(DisplayBarTypes, "OutputBarType"),
      color: typeOrUndefined(t21.keyof(LedColors, "LedColor")),
      transparent: typeOrUndefined(t21.boolean),
      name: ComponentNameRepr
    },
    valueDefaults: {
      display: "h",
      color: "green",
      transparent: true
    },
    size: { gridWidth: 1, gridHeight: 1 },
    // overridden
    makeNodes: () => ({
      ins: {
        I: [0, 0, "w"]
      }
    }),
    initialValue: () => false
  });
  var DisplayBar = class extends DisplayBarBase {
    constructor(parent, saved) {
      var _a;
      super(parent, DisplayBarDef, false, saved);
      this.doSetDisplay((_a = saved == null ? void 0 : saved.display) != null ? _a : DisplayBarDef.aults.display);
    }
    toJSON() {
      return __spreadProps(__spreadValues({}, super.toJSONBase()), {
        display: this._display
      });
    }
    get unrotatedWidth() {
      return this.getWidthAndHeight()[0];
    }
    get unrotatedHeight() {
      return this.getWidthAndHeight()[1];
    }
    makeTooltip() {
      const s = S.Components.DisplayBar.tooltip;
      const expl = (() => {
        switch (this.value) {
          case Unknown:
            return s.ValueUnknown;
          case HighImpedance:
            return s.ValueUnknown;
          case true:
            return mods(s.Value1[0], asValue(this.value), s.Value1[1]);
          case false:
            return mods(s.Value0[0], asValue(this.value), s.Value0[1]);
        }
      })();
      return tooltipContent(s.title, expl);
    }
    get display() {
      return this._display;
    }
    doRecalcValue() {
      return this.inputs.I.value;
    }
    doDraw(g, ctx) {
      const valueToShow = this.parent.editor.options.hideOutputColors ? Unknown : this.value;
      const background = this._transparent && valueToShow === false ? COLOR_TRANSPARENT : ledColorForLogicValue(valueToShow, this._color);
      this.doDrawDefault(g, ctx, {
        background,
        skipLabels: true,
        componentName: [this._name, true, toLogicValueRepr(valueToShow)]
      });
    }
    getWidthAndHeight() {
      var _a;
      const w = 10;
      const h = 2;
      switch ((_a = this._display) != null ? _a : DisplayBarDef.aults.display) {
        case "h":
          return [w * GRID_STEP, h * GRID_STEP];
        case "v":
          return [h * GRID_STEP, w * GRID_STEP];
        case "px":
          return [h * GRID_STEP, h * GRID_STEP];
        case "PX":
          return [w * GRID_STEP, w * GRID_STEP];
      }
    }
    mouseDoubleClicked(e) {
      const superChange = super.mouseDoubleClicked(e);
      if (superChange.isChange) {
        return superChange;
      }
      this.doSetDisplay((() => {
        switch (this.display) {
          case "h":
            return "v";
          case "v":
            return "px";
          case "px":
            return "PX";
          case "PX":
            return "h";
        }
      })());
      return InteractionResult.SimpleChange;
    }
    doSetDisplay(newDisplay) {
      this._display = newDisplay;
      this.updateInputOffsetX();
      this.requestRedraw({ why: "display mode changed", invalidateMask: true });
    }
    updateInputOffsetX() {
      const width = this.getWidthAndHeight()[0];
      const input2 = this.inputs.I;
      input2.gridOffsetX = -pxToGrid(width / 2) - 1;
      input2.updateLeadLength();
    }
    makeComponentSpecificContextMenuItems() {
      const s = S.Components.DisplayBar.contextMenu;
      const makeItemShowAs = /* @__PURE__ */ __name((desc, display) => {
        const isCurrent = this._display === display;
        const icon = isCurrent ? "check" : "none";
        const action = isCurrent ? () => void 0 : () => {
          this.doSetDisplay(display);
        };
        return MenuData.item(icon, desc, action);
      }, "makeItemShowAs");
      return [
        ["mid", MenuData.submenu("eye", s.Display, [
          makeItemShowAs(s.DisplayVerticalBar, "v"),
          makeItemShowAs(s.DisplayHorizontalBar, "h"),
          makeItemShowAs(s.DisplaySmallSquare, "px"),
          makeItemShowAs(s.DisplayLargeSquare, "PX"),
          MenuData.sep(),
          MenuData.text(s.DisplayChangeDesc)
        ])],
        ...super.makeComponentSpecificContextMenuItems()
      ];
    }
  };
  __name(DisplayBar, "DisplayBar");
  DisplayBarDef.impl = DisplayBar;

  // simulator/src/components/Display16Seg.ts
  var Display16SegDef = defineComponent("16seg", {
    idPrefix: "16seg",
    button: { imgWidth: 32 },
    repr: {
      color: typeOrUndefined(t22.keyof(LedColors, "LedColor")),
      transparent: typeOrUndefined(t22.boolean),
      name: ComponentNameRepr
    },
    valueDefaults: {},
    size: { gridWidth: 8, gridHeight: 10 },
    makeNodes: () => ({
      ins: {
        In: group("w", [
          [-5, -4, "a1"],
          [-6, -3.5, "a2"],
          [-5, -3, "b"],
          [-6, -2.5, "c"],
          [-5, -2, "d2"],
          [-6, -1.5, "d1"],
          [-5, -1, "e"],
          [-6, -0.5, "f"],
          [-5, 0, "g1"],
          [-6, 0.5, "g2"],
          [-5, 1, "h"],
          [-6, 1.5, "i"],
          [-5, 2, "j"],
          [-6, 2.5, "k"],
          [-5, 3, "l"],
          [-6, 3.5, "m"],
          [-5, 4, "p"]
        ])
      }
    }),
    initialValue: () => ArrayFillWith(false, 17)
  });
  var Display16Seg = class extends DisplayBarBase {
    constructor(parent, saved) {
      super(parent, Display16SegDef, true, saved);
    }
    toJSON() {
      return this.toJSONBase();
    }
    makeTooltip() {
      return tooltipContent(void 0, mods(
        div(S.Components.Display16Seg.tooltip)
      ));
    }
    doRecalcValue() {
      return this.inputValues(this.inputs.In);
    }
    doDraw(g, ctx) {
      this.doDrawDefault(g, ctx, {
        labelSize: 7,
        componentName: [this._name, true, () => this.value.map(toLogicValueRepr).reverse().join("")],
        drawInside: ({ left: left2, right: right2, top: top2, bottom: bottom2 }) => {
          const [a1, a2, b2, c, d2, d1, e, f, g1, g2, h, i2, j, k, l, m, p] = this.value;
          const vMargin = 10;
          const strokeHalfWidth = 3;
          const drawLeft = left2 + 18;
          const drawRight = right2 - 10;
          const drawCenterX = (drawLeft + drawRight) / 2;
          const drawTop = top2 + vMargin;
          const drawBottom = bottom2 - vMargin;
          const doFill = /* @__PURE__ */ __name((v) => {
            if (!this._transparent || v !== false) {
              g.fillStyle = ledColorForLogicValue(v, this._color);
              g.fill();
            }
          }, "doFill");
          const drawH = /* @__PURE__ */ __name((v, xLeft, xRight, y) => {
            g.beginPath();
            g.moveTo(xLeft, y);
            g.lineTo(xLeft + strokeHalfWidth, y - strokeHalfWidth);
            g.lineTo(xRight - strokeHalfWidth, y - strokeHalfWidth);
            g.lineTo(xRight, y);
            g.lineTo(xRight - strokeHalfWidth, y + strokeHalfWidth);
            g.lineTo(xLeft + strokeHalfWidth, y + strokeHalfWidth);
            g.closePath();
            g.stroke();
            doFill(v);
          }, "drawH");
          const drawV = /* @__PURE__ */ __name((v, x, yTop, yBottom) => {
            g.beginPath();
            g.moveTo(x, yTop);
            g.lineTo(x + strokeHalfWidth, yTop + strokeHalfWidth);
            g.lineTo(x + strokeHalfWidth, yBottom - strokeHalfWidth);
            g.lineTo(x, yBottom);
            g.lineTo(x - strokeHalfWidth, yBottom - strokeHalfWidth);
            g.lineTo(x - strokeHalfWidth, yTop + strokeHalfWidth);
            g.closePath();
            g.stroke();
            doFill(v);
          }, "drawV");
          const dx = strokeHalfWidth * 1.41;
          const dy = strokeHalfWidth * 1.41;
          const drawBackslash = /* @__PURE__ */ __name((v, xLeft, yTop, xRight, yBottom) => {
            g.beginPath();
            g.moveTo(xLeft, yTop);
            g.lineTo(xLeft + dx, yTop);
            g.lineTo(xRight, yBottom - dy);
            g.lineTo(xRight, yBottom);
            g.lineTo(xRight - dx, yBottom);
            g.lineTo(xLeft, yTop + dy);
            g.closePath();
            g.stroke();
            doFill(v);
          }, "drawBackslash");
          const drawSlash = /* @__PURE__ */ __name((v, xLeft, yBottom, xRight, yTop) => {
            g.beginPath();
            g.moveTo(xLeft, yBottom);
            g.lineTo(xLeft, yBottom - dy);
            g.lineTo(xRight - dx, yTop);
            g.lineTo(xRight, yTop);
            g.lineTo(xRight, yTop + dy);
            g.lineTo(xLeft + dx, yBottom);
            g.closePath();
            g.stroke();
            doFill(v);
          }, "drawSlash");
          g.strokeStyle = COLOR_OFF_BACKGROUND;
          g.lineWidth = 1;
          drawH(a1, drawLeft + strokeHalfWidth, drawCenterX, drawTop + strokeHalfWidth);
          drawH(a2, drawCenterX, drawRight - strokeHalfWidth, drawTop + strokeHalfWidth);
          drawV(b2, drawRight - strokeHalfWidth, drawTop + strokeHalfWidth, this.posY);
          drawV(c, drawRight - strokeHalfWidth, this.posY, drawBottom - strokeHalfWidth);
          drawH(d1, drawLeft + strokeHalfWidth, drawCenterX, drawBottom - strokeHalfWidth);
          drawH(d2, drawCenterX, drawRight - strokeHalfWidth, drawBottom - strokeHalfWidth);
          drawV(e, drawLeft + strokeHalfWidth, this.posY, drawBottom - strokeHalfWidth);
          drawV(f, drawLeft + strokeHalfWidth, drawTop + strokeHalfWidth, this.posY);
          drawH(g1, drawLeft + strokeHalfWidth, drawCenterX, this.posY);
          drawH(g2, drawCenterX, drawRight - strokeHalfWidth, this.posY);
          drawV(i2, drawCenterX, drawTop + strokeHalfWidth, this.posY);
          drawV(l, drawCenterX, this.posY, drawBottom - strokeHalfWidth);
          const slashTop = drawTop + strokeHalfWidth + strokeHalfWidth;
          const slashBottom = drawBottom - strokeHalfWidth - strokeHalfWidth;
          drawBackslash(h, drawLeft + strokeHalfWidth + strokeHalfWidth, slashTop, drawCenterX - strokeHalfWidth, this.posY - strokeHalfWidth);
          drawSlash(j, drawCenterX + strokeHalfWidth, this.posY - strokeHalfWidth, drawRight - strokeHalfWidth - strokeHalfWidth, slashTop);
          drawSlash(k, drawLeft + strokeHalfWidth + strokeHalfWidth, slashBottom, drawCenterX - strokeHalfWidth, this.posY + strokeHalfWidth);
          drawBackslash(m, drawCenterX + strokeHalfWidth, this.posY + strokeHalfWidth, drawRight - strokeHalfWidth - strokeHalfWidth, slashBottom);
          g.beginPath();
          const radius = 1.3 * strokeHalfWidth;
          g.arc(right2 - 8, bottom2 - 7 - radius / 2, radius, 0, 2 * Math.PI);
          g.stroke();
          doFill(p);
        }
      });
    }
  };
  __name(Display16Seg, "Display16Seg");
  Display16SegDef.impl = Display16Seg;

  // simulator/src/components/Display7Seg.ts
  var t23 = __toESM(require_lib());
  var Display7SegDef = defineComponent("7seg", {
    idPrefix: "7seg",
    button: { imgWidth: 32 },
    repr: {
      color: typeOrUndefined(t23.keyof(LedColors, "LedColor")),
      transparent: typeOrUndefined(t23.boolean),
      name: ComponentNameRepr
    },
    valueDefaults: {},
    size: { gridWidth: 8, gridHeight: 10 },
    makeNodes: () => ({
      ins: {
        In: group("w", [
          [-5, -4, "a"],
          [-5, -3, "b"],
          [-5, -2, "c"],
          [-5, -1, "d"],
          [-5, 0, "e"],
          [-5, 1, "f"],
          [-5, 2, "g"],
          [-5, 4, "p"]
        ])
      }
    }),
    initialValue: () => ArrayFillWith(false, 8)
  });
  var Display7Seg = class extends DisplayBarBase {
    constructor(parent, saved) {
      super(parent, Display7SegDef, true, saved);
    }
    toJSON() {
      return this.toJSONBase();
    }
    makeTooltip() {
      return tooltipContent(void 0, mods(
        div(S.Components.Display7Seg.tooltip)
      ));
    }
    doRecalcValue() {
      return this.inputValues(this.inputs.In);
    }
    doDraw(g, ctx) {
      this.doDrawDefault(g, ctx, {
        labelSize: 9,
        componentName: [this._name, true, () => this.value.map(toLogicValueRepr).reverse().join("")],
        drawInside: ({ left: left2, right: right2, top: top2, bottom: bottom2 }) => {
          const [a2, b2, c, d, e, f, gg, p] = this.value;
          const hMargin = 20;
          const vMargin = 10;
          const strokeHalfWidth = 4;
          const drawLeft = left2 + hMargin;
          const drawRight = right2 - hMargin;
          const drawTop = top2 + vMargin;
          const drawBottom = bottom2 - vMargin;
          const doFill = /* @__PURE__ */ __name((v) => {
            if (!this._transparent || v !== false) {
              g.fillStyle = ledColorForLogicValue(v, this._color);
              g.fill();
            }
          }, "doFill");
          const drawH = /* @__PURE__ */ __name((v, y) => {
            g.beginPath();
            g.moveTo(drawLeft + strokeHalfWidth, y);
            g.lineTo(drawLeft + strokeHalfWidth + strokeHalfWidth, y - strokeHalfWidth);
            g.lineTo(drawRight - strokeHalfWidth - strokeHalfWidth, y - strokeHalfWidth);
            g.lineTo(drawRight - strokeHalfWidth, y);
            g.lineTo(drawRight - strokeHalfWidth - strokeHalfWidth, y + strokeHalfWidth);
            g.lineTo(drawLeft + strokeHalfWidth + strokeHalfWidth, y + strokeHalfWidth);
            g.closePath();
            g.stroke();
            doFill(v);
          }, "drawH");
          const drawV = /* @__PURE__ */ __name((v, x, yTop, yBottom) => {
            g.beginPath();
            g.moveTo(x, yTop);
            g.lineTo(x + strokeHalfWidth, yTop + strokeHalfWidth);
            g.lineTo(x + strokeHalfWidth, yBottom - strokeHalfWidth);
            g.lineTo(x, yBottom);
            g.lineTo(x - strokeHalfWidth, yBottom - strokeHalfWidth);
            g.lineTo(x - strokeHalfWidth, yTop + strokeHalfWidth);
            g.closePath();
            g.stroke();
            doFill(v);
          }, "drawV");
          g.strokeStyle = COLOR_OFF_BACKGROUND;
          g.lineWidth = 1;
          drawH(a2, drawTop + strokeHalfWidth);
          drawV(b2, drawRight - strokeHalfWidth, drawTop + strokeHalfWidth, this.posY);
          drawV(c, drawRight - strokeHalfWidth, this.posY, drawBottom - strokeHalfWidth);
          drawH(d, drawBottom - strokeHalfWidth);
          drawV(e, drawLeft + strokeHalfWidth, this.posY, drawBottom - strokeHalfWidth);
          drawV(f, drawLeft + strokeHalfWidth, drawTop + strokeHalfWidth, this.posY);
          drawH(gg, this.posY);
          g.beginPath();
          const radius = 1.3 * strokeHalfWidth;
          g.arc(right2 - hMargin / 2, bottom2 - vMargin - radius / 2, radius, 0, 2 * Math.PI);
          g.stroke();
          doFill(p);
        }
      });
    }
  };
  __name(Display7Seg, "Display7Seg");
  Display7SegDef.impl = Display7Seg;

  // simulator/src/components/DisplayAscii.ts
  var t24 = __toESM(require_lib());
  var DisplayAsciiDef = defineComponent("ascii", {
    idPrefix: "disp",
    button: { imgWidth: 32 },
    repr: {
      name: ComponentNameRepr,
      additionalReprRadix: typeOrUndefined(t24.number),
      showAsUnknown: typeOrUndefined(t24.boolean)
    },
    valueDefaults: {},
    size: { gridWidth: 4, gridHeight: 8 },
    makeNodes: () => ({
      ins: {
        Z: groupVertical("w", -3, 0, 7)
      }
    }),
    initialValue: () => ["0000000", 0]
  });
  var DisplayAscii = class extends ComponentBase {
    constructor(parent, saved) {
      var _a, _b, _c;
      super(parent, DisplayAsciiDef, saved);
      this._name = (_a = saved == null ? void 0 : saved.name) != null ? _a : void 0;
      this._additionalReprRadix = (_b = saved == null ? void 0 : saved.additionalReprRadix) != null ? _b : void 0;
      this._showAsUnknown = (_c = saved == null ? void 0 : saved.showAsUnknown) != null ? _c : false;
    }
    toJSON() {
      return __spreadProps(__spreadValues({}, this.toJSONBase()), {
        name: this._name,
        additionalReprRadix: this._additionalReprRadix,
        showAsUnknown: this._showAsUnknown ? true : void 0
      });
    }
    get showAsUnknown() {
      return this._showAsUnknown || this.parent.editor.options.hideOutputColors;
    }
    makeTooltip() {
      const s = S.Components.DisplayAscii.tooltip;
      const [binaryStringRep, value] = this.value;
      return tooltipContent(s.title, mods(
        div(s.desc[0], b(binaryStringRep), s.desc[1]),
        this.showAsUnknown ? emptyMod : isUnknown(value) ? div(s.CurrentlyUndefined) : mods(
          s.CurrentlyThisCharacter + " ",
          b("" + value),
          value < 32 ? s.WhichIsNotPrintable : mods(", \u2018", b(String.fromCharCode(value)), "\u2019.")
        )
      ));
    }
    doRecalcValue() {
      const values = this.inputValues(this.inputs.Z);
      return displayValuesFromArray(values, false);
    }
    doDraw(g, ctx) {
      const [binaryStringRep, value] = this.value;
      let mainText;
      let mainTextFont;
      let mainTextStyle = COLOR_COMPONENT_BORDER;
      if (isUnknown(value) || this.showAsUnknown) {
        mainTextFont = "bold 18px sans-serif";
        if (this.showAsUnknown) {
          mainTextStyle = COLOR_UNKNOWN;
        }
        mainText = "?";
      } else {
        mainText = DisplayAscii.numberToAscii(value);
        if (value < 32) {
          mainTextFont = "16px sans-serif";
        } else {
          mainTextFont = "bold 18px sans-serif";
        }
      }
      this.doDrawDefault(g, ctx, {
        skipLabels: true,
        componentName: [this._name, true, mainText],
        drawLabels: (ctx2, { width, height }) => {
          var _a;
          const isVertical = Orientation.isVertical(this.orient);
          const hasAdditionalRepresentation = this._additionalReprRadix !== void 0;
          let mainTextPosY = this.posY + (isVertical ? 4 : 0);
          g.font = "9px sans-serif";
          g.fillStyle = COLOR_COMPONENT_BORDER;
          if (!this.showAsUnknown) {
            if (isVertical && hasAdditionalRepresentation) {
              g.textAlign = "start";
              fillTextVAlign(g, TextVAlign.middle, binaryStringRep, this.posX - height / 2 + 3, this.posY - width / 2 + 8);
              g.textAlign = "center";
            } else {
              g.textAlign = "center";
              fillTextVAlign(g, TextVAlign.middle, binaryStringRep, this.posX, this.posY + (isVertical ? -width / 2 + 8 : -height / 2 + 10));
            }
            if (hasAdditionalRepresentation) {
              const additionalRepr = formatWithRadix(value, (_a = this._additionalReprRadix) != null ? _a : 10, 7);
              g.font = "bold 11px sans-serif";
              if (isVertical) {
                g.textAlign = "end";
                fillTextVAlign(g, TextVAlign.middle, additionalRepr, this.posX + height / 2 - 3, this.posY - width / 2 + 9);
                g.textAlign = "center";
              } else {
                fillTextVAlign(g, TextVAlign.middle, additionalRepr, this.posX, this.posY - height / 2 + 22);
                mainTextPosY += 8;
              }
            }
          }
          g.font = mainTextFont;
          g.fillStyle = mainTextStyle;
          fillTextVAlign(g, TextVAlign.middle, mainText, this.posX, mainTextPosY);
        }
      });
    }
    static numberToAscii(n) {
      if (n < 32) {
        return "\\" + n;
      }
      return String.fromCharCode(n);
    }
    mouseDoubleClicked(e) {
      const superChange = super.mouseDoubleClicked(e);
      if (superChange.isChange) {
        return superChange;
      }
      const mode = this.parent.mode;
      if (mode >= 4 /* FULL */ && e.altKey) {
        this.doSetShowAsUnknown(!this._showAsUnknown);
        return InteractionResult.SimpleChange;
      } else if (mode >= 3 /* DESIGN */) {
        this.doSetAdditionalDisplayRadix((() => {
          switch (this._additionalReprRadix) {
            case void 0:
              return 10;
            case 10:
              return 16;
            case 16:
              return void 0;
            default:
              return void 0;
          }
        })());
        return InteractionResult.SimpleChange;
      }
      return InteractionResult.NoChange;
    }
    doSetName(name2) {
      this._name = name2;
      this.requestRedraw({ why: "name changed" });
    }
    doSetShowAsUnknown(showAsUnknown) {
      this._showAsUnknown = showAsUnknown;
      this.requestRedraw({ why: "display as unknown changed" });
    }
    doSetAdditionalDisplayRadix(additionalReprRadix) {
      this._additionalReprRadix = additionalReprRadix;
      this.requestRedraw({ why: "additional display radix changed" });
    }
    makeComponentSpecificContextMenuItems() {
      const s = S.Components.DisplayAscii.contextMenu;
      const makeItemShowAs = /* @__PURE__ */ __name((desc, handler, isCurrent) => {
        const icon = isCurrent ? "check" : "none";
        return MenuData.item(icon, desc, handler);
      }, "makeItemShowAs");
      const makeItemShowRadix = /* @__PURE__ */ __name((radix, desc) => {
        return makeItemShowAs(
          desc,
          () => this.doSetAdditionalDisplayRadix(radix),
          this._additionalReprRadix === radix
        );
      }, "makeItemShowRadix");
      return [
        ["mid", MenuData.submenu("eye", s.AdditionalDisplay, [
          makeItemShowRadix(void 0, s.DisplayNone),
          makeItemShowRadix(10, s.DisplayDecimal),
          makeItemShowRadix(16, s.DisplayHex),
          MenuData.sep(),
          MenuData.text(s.ChangeDisplayDesc)
        ])],
        ["mid", makeItemShowAs(S.Components.Generic.contextMenu.ShowAsUnknown, () => this.doSetShowAsUnknown(!this._showAsUnknown), this._showAsUnknown)],
        ["mid", MenuData.sep()],
        ["mid", this.makeSetNameContextMenuItem(this._name, this.doSetName.bind(this))]
      ];
    }
    keyDown(e) {
      if (e.key === "Enter" && !e.altKey) {
        this.runSetNameDialog(this._name, this.doSetName.bind(this));
      } else {
        super.keyDown(e);
      }
    }
  };
  __name(DisplayAscii, "DisplayAscii");
  DisplayAsciiDef.impl = DisplayAscii;

  // simulator/src/components/FlipflopD.ts
  var FlipflopDDef = defineComponent("ff-d", __spreadProps(__spreadValues({
    idPrefix: "ff"
  }, FlipflopBaseDef), {
    makeNodes: () => {
      const base = FlipflopBaseDef.makeNodes(2);
      const s = S.Components.Generic;
      return {
        ins: __spreadProps(__spreadValues({}, base.ins), {
          D: [-4, -2, "w", s.InputDataDesc]
        }),
        outs: base.outs
      };
    }
  }));
  var FlipflopD = class extends Flipflop {
    constructor(parent, saved) {
      super(parent, FlipflopDDef, saved);
    }
    toJSON() {
      return this.toJSONBase();
    }
    makeTooltip() {
      const s = S.Components.FlipflopD.tooltip;
      return tooltipContent(s.title, mods(
        div(s.desc)
        // TODO more info
      ));
    }
    doRecalcValueAfterClock() {
      return LogicValue.filterHighZ(this.inputs.D.value);
    }
  };
  __name(FlipflopD, "FlipflopD");
  FlipflopDDef.impl = FlipflopD;

  // simulator/src/components/FlipflopJK.ts
  var FlipflopJKDef = defineComponent("ff-jk", __spreadProps(__spreadValues({
    idPrefix: "ff"
  }, FlipflopBaseDef), {
    makeNodes: () => {
      const base = FlipflopBaseDef.makeNodes(0);
      const s = S.Components.FlipflopJK;
      return {
        ins: __spreadProps(__spreadValues({}, base.ins), {
          J: [-4, -2, "w", s.InputJDesc],
          K: [-4, 2, "w", s.InputKDesc]
        }),
        outs: base.outs
      };
    }
  }));
  var FlipflopJK = class extends Flipflop {
    constructor(parent, saved) {
      super(parent, FlipflopJKDef, saved);
    }
    toJSON() {
      return this.toJSONBase();
    }
    makeTooltip() {
      const s = S.Components.FlipflopJK.tooltip;
      return tooltipContent(s.title, mods(
        div(s.desc)
        // TODO more info
      ));
    }
    doRecalcValueAfterClock() {
      const j = this.inputs.J.value;
      const k = this.inputs.K.value;
      const q = this.outputs.Q.value;
      if (j === true) {
        if (k === true) {
          return LogicValue.invert(q);
        } else {
          return true;
        }
      }
      if (k === true) {
        return false;
      } else {
        return q;
      }
    }
  };
  __name(FlipflopJK, "FlipflopJK");
  FlipflopJKDef.impl = FlipflopJK;

  // simulator/src/components/FlipflopT.ts
  var FlipflopTDef = defineComponent("ff-t", __spreadProps(__spreadValues({
    idPrefix: "ff"
  }, FlipflopBaseDef), {
    makeNodes: () => {
      const base = FlipflopBaseDef.makeNodes(2);
      const s = S.Components.FlipflopT;
      return {
        ins: __spreadProps(__spreadValues({}, base.ins), {
          T: [-4, -2, "w", s.InputTDesc]
        }),
        outs: base.outs
      };
    }
  }));
  var FlipflopT = class extends Flipflop {
    constructor(parent, saved) {
      super(parent, FlipflopTDef, saved);
    }
    toJSON() {
      return this.toJSONBase();
    }
    makeTooltip() {
      const s = S.Components.FlipflopT.tooltip;
      return tooltipContent(s.title, mods(
        div(s.desc)
        // TODO more info
      ));
    }
    doRecalcValueAfterClock() {
      const t38 = this.inputs.T.value;
      if (isUnknown(t38) || isHighImpedance(t38)) {
        return Unknown;
      }
      const q = this.outputs.Q.value;
      return t38 ? LogicValue.invert(q) : q;
    }
  };
  __name(FlipflopT, "FlipflopT");
  FlipflopTDef.impl = FlipflopT;

  // simulator/src/components/Gate.ts
  var t25 = __toESM(require_lib());
  var LEAD_LENGTH_NORMAL = 20;
  var LEAD_LENGTH_OR_STYLE = 25;
  var GateBase = class extends ParametrizedComponentBase {
    constructor(parent, SubclassDef, type7, saved) {
      var _a, _b;
      super(parent, SubclassDef, saved);
      this._type = type7;
      this._poseAs = (_a = saved == null ? void 0 : saved.poseAs) != null ? _a : void 0;
      this._showAsUnknown = (_b = saved == null ? void 0 : saved.showAsUnknown) != null ? _b : false;
    }
    toJSONBase() {
      return __spreadProps(__spreadValues({}, super.toJSONBase()), {
        showAsUnknown: this._showAsUnknown ? true : void 0,
        poseAs: this._poseAs
      });
    }
    jsonType() {
      return this._type;
    }
    get type() {
      return this._type;
    }
    doSetType(newType) {
      var _a;
      this._type = newType;
      this.updateLeadsFor(newType);
      for (const input2 of this.inputs.In) {
        (_a = input2.incomingWire) == null ? void 0 : _a.invalidateWirePath();
      }
      this.setNeedsRecalc();
      this.requestRedraw({ why: "gate type changed", invalidateTests: true });
    }
    updateLeadsFor(type7) {
      const isOrStyle = type7 === "or" || type7 === "nor" || type7 === "imply" || type7 === "rimply";
      const leadLength = isOrStyle ? LEAD_LENGTH_OR_STYLE : LEAD_LENGTH_NORMAL;
      const ins = this.inputs.In;
      ins.forEach((node) => node.updateLeadLength(leadLength));
      if (isOrStyle) {
        const numBits = this.numBits;
        if (numBits >= 6 || numBits === 4) {
          ins[0].updateLeadLength(leadLength - 3);
          ins[numBits - 1].updateLeadLength(leadLength - 3);
          if (numBits >= 8) {
            const numCoveredByGate = 6;
            const iTopGate = (numBits - numCoveredByGate) / 2;
            const iBottomGate = iTopGate + numCoveredByGate - 1;
            ins[iTopGate].updateLeadLength(leadLength - 3);
            ins[iBottomGate].updateLeadLength(leadLength - 3);
            if (numBits >= 24) {
              ins[1].updateLeadLength(leadLength - 2);
              ins[numBits - 2].updateLeadLength(leadLength - 2);
              ins[iTopGate - 1].updateLeadLength(leadLength - 2);
              ins[iTopGate - 2].updateLeadLength(leadLength - 2);
              ins[iBottomGate + 1].updateLeadLength(leadLength - 2);
              ins[iBottomGate + 2].updateLeadLength(leadLength - 2);
            }
          }
        }
      }
    }
    get poseAs() {
      return this._poseAs;
    }
    set poseAs(newPoseAs) {
      if (newPoseAs !== this._poseAs) {
        this._poseAs = newPoseAs;
        this.requestRedraw({ why: "gate display changed" });
      }
    }
    get showAsUnknown() {
      return this._showAsUnknown;
    }
    doSetShowAsUnknown(newUnknown) {
      this._showAsUnknown = newUnknown;
      this.requestRedraw({ why: "display as unknown changed" });
    }
    toStringDetails() {
      return this.type;
    }
    doRecalcValue() {
      const inputs = this.inputValues(this.inputs.In);
      const logicFunc = this.gateTypes(this.numBits).props[this.type].out;
      return logicFunc(inputs);
    }
    propagateValue(newValue) {
      this.outputs.Out.value = newValue;
    }
    makeTooltip() {
      const s = S.Components.Gate.tooltip;
      if (this.showAsUnknown) {
        return div(s.UnknownGate);
      }
      const myIns = this.inputValues(this.inputs.In);
      const myOut = this.value;
      const gateProps = this.gateTypes(this.numBits).props[this.type];
      const genTruthTableData = /* @__PURE__ */ __name(() => {
        const header2 = this.numBits === 1 ? [s.Input] : ArrayFillUsing((i2) => s.Input + " " + (i2 + 1), this.numBits);
        header2.push(s.Output);
        const rows = [];
        for (const ins of valueCombinations(this.numBits)) {
          const matchesCurrent = deepArrayEquals(myIns, ins);
          const out = gateProps.out(ins);
          ins.push(out);
          rows.push({ matchesCurrent, cells: ins });
        }
        return [header2, rows];
      }, "genTruthTableData");
      const nodeOut = this.outputs.Out.value;
      const desc = nodeOut === myOut ? s.CurrentlyDelivers : s.ShouldCurrentlyDeliver;
      const gateIsUnspecified = myIns.includes(Unknown);
      const explanation = gateIsUnspecified ? mods(desc + " " + s.UndeterminedOutputBecauseInputUnknown) : mods(desc + " " + s.ThisOutput + " ", asValue(myOut), " " + s.BecauseInputIs + " ", ...myIns.map(asValue));
      const fullShortDesc = gateProps.fullShortDesc();
      const header = (() => {
        switch (this.type) {
          case "not":
            return mods(s.Inverter[0], b(S.Components.Gate.not[0]), s.Inverter[1]);
          case "buf":
            return mods(s.Buffer[0], b(S.Components.Gate.buf[0]), s.Buffer[1]);
          default:
            return s.GateTitle(b(fullShortDesc[0]));
        }
      })();
      const explanationAndTable = this.numBits <= 4 ? mods(explanation, ", " + s.AccordingToTruthTable, div(makeTruthTable(genTruthTableData()))) : mods(explanation, ".");
      return makeGateTooltip(
        this.numBits,
        header,
        fullShortDesc[2],
        explanationAndTable
      );
    }
    doDraw(g, ctx) {
      var _a;
      const gateType = this._showAsUnknown ? Unknown : (_a = this.poseAs) != null ? _a : this.type;
      this.drawGate(g, gateType, gateType !== this.type && !this._showAsUnknown, ctx);
    }
    drawGate(g, type7, isFake, ctx) {
      const numBits = this.numBits;
      const output = this.outputs.Out;
      const { top: top2, left: left2, bottom: bottom2, right: right2, height } = this.bounds();
      const drawArms = numBits >= 4 && numBits !== 5;
      const armsOffset = GRID_STEP / (useCompact(numBits) ? 2 : 1);
      const armsTop = this.inputs.In[0].posYInParentTransform - armsOffset;
      const armsBottom = this.inputs.In[numBits - 1].posYInParentTransform + armsOffset;
      const pi22 = Math.PI / 2;
      let nameDeltaX = 0;
      const drawInversionCircle = /* @__PURE__ */ __name((x, y) => {
        g.beginPath();
        circle(g, x, y, 8);
        g.fillStyle = COLOR_BACKGROUND;
        g.fill();
        g.stroke();
      }, "drawInversionCircle");
      const showAsFake = isFake && this.parent.mode >= 4 /* FULL */;
      const gateBorderColor = ctx.isMouseOver ? COLOR_MOUSE_OVER : showAsFake ? COLOR_DARK_RED : COLOR_COMPONENT_BORDER;
      const gateFill = showAsFake ? PATTERN_STRIPED_GRAY : COLOR_BACKGROUND;
      for (let i2 = 0; i2 < numBits; i2++) {
        drawWireLineToComponent(g, this.inputs.In[i2]);
      }
      drawWireLineToComponent(g, output);
      g.lineWidth = 3;
      g.strokeStyle = gateBorderColor;
      g.fillStyle = gateFill;
      switch (type7) {
        case "not":
        case "buf": {
          g.beginPath();
          g.moveTo(left2, top2);
          g.lineTo(right2, this.posY);
          g.lineTo(left2, bottom2);
          g.closePath();
          g.fill();
          g.stroke();
          if (type7 === "not") {
            drawInversionCircle(right2 + 5, this.posY);
          }
          nameDeltaX = -7;
          break;
        }
        case "and":
        case "nand":
        case "nimply":
        case "rnimply": {
          const arcBeginX = right2 - height / 2;
          g.beginPath();
          g.moveTo(arcBeginX, bottom2);
          g.lineTo(left2, bottom2);
          g.lineTo(left2, top2);
          g.lineTo(arcBeginX, top2);
          g.arc(arcBeginX, this.posY, height / 2, -pi22, pi22);
          g.closePath();
          g.fill();
          g.lineWidth = 1;
          g.stroke();
          g.strokeStyle = gateBorderColor;
          g.lineWidth = 3;
          g.stroke();
          g.beginPath();
          if (type7.startsWith("nand")) {
            drawInversionCircle(right2 + 5, this.posY);
          }
          if (type7 === "nimply") {
            drawInversionCircle(left2 - 5, this.posY + GRID_STEP);
          } else if (type7 === "rnimply") {
            drawInversionCircle(left2 - 5, this.posY - GRID_STEP);
          }
          nameDeltaX = -2;
          if (drawArms) {
            g.moveTo(left2, armsTop);
            g.lineTo(left2, armsBottom);
            g.stroke();
          }
          break;
        }
        case "or":
        case "nor":
        case "xor":
        case "xnor":
        case "imply":
        case "rimply": {
          const leftCurve = 12;
          g.beginPath();
          g.moveTo(this.posX - 15, top2);
          g.bezierCurveTo(
            this.posX + 10,
            top2,
            right2 - 5,
            this.posY - 8,
            right2,
            this.posY
          );
          g.bezierCurveTo(
            right2 - 5,
            this.posY + 8,
            this.posX + 10,
            bottom2,
            left2,
            bottom2
          );
          g.quadraticCurveTo(left2 + leftCurve, this.posY, left2, top2);
          g.closePath();
          g.fill();
          g.stroke();
          const armsHeight = armsBottom - bottom2;
          const armsCurvature = Math.min(leftCurve, armsHeight / 4);
          if (drawArms) {
            g.beginPath();
            g.moveTo(left2, bottom2);
            g.quadraticCurveTo(left2 + armsCurvature, bottom2 + armsHeight / 2, left2, armsBottom);
            g.moveTo(left2, top2);
            g.quadraticCurveTo(left2 + armsCurvature, top2 - armsHeight / 2, left2, armsTop);
            g.stroke();
          }
          if (type7.startsWith("nor") || type7.startsWith("xnor")) {
            drawInversionCircle(right2 + 5, this.posY);
          }
          if (type7 === "imply") {
            drawInversionCircle(left2 - 2, this.posY - GRID_STEP);
          } else if (type7 === "rimply") {
            drawInversionCircle(left2 - 2, this.posY + GRID_STEP);
          }
          if (type7.startsWith("x")) {
            g.lineWidth = 3;
            const leftXorCurve = /* @__PURE__ */ __name((delta) => {
              g.beginPath();
              if (drawArms) {
                g.moveTo(left2 - delta, armsBottom);
                g.quadraticCurveTo(left2 + armsCurvature - delta, bottom2 + armsHeight / 2, left2 - delta, bottom2);
                g.quadraticCurveTo(left2 + leftCurve - delta, this.posY, left2 - delta, top2);
                g.quadraticCurveTo(left2 + armsCurvature - delta, top2 - armsHeight / 2, left2 - delta, armsTop);
              } else {
                g.moveTo(left2 - delta, bottom2);
                g.quadraticCurveTo(left2 + leftCurve - delta, this.posY, left2 - delta, top2);
              }
            }, "leftXorCurve");
            leftXorCurve(3);
            g.strokeStyle = COLOR_BACKGROUND;
            g.stroke();
            leftXorCurve(6);
            g.strokeStyle = gateBorderColor;
            g.stroke();
          }
          nameDeltaX = 1;
          break;
        }
        case "txa":
        case "txna": {
          g.beginPath();
          g.moveTo(left2, bottom2);
          g.lineTo(left2, top2);
          g.lineTo(right2, this.posY + 0.5);
          g.lineTo(left2 + 2, this.posY + 0.5);
          g.fill();
          g.stroke();
          if (type7 === "txna") {
            drawInversionCircle(left2 - 5, this.posY - GRID_STEP);
          }
          break;
        }
        case "txb":
        case "txnb": {
          g.beginPath();
          g.moveTo(left2, top2);
          g.lineTo(left2, bottom2);
          g.lineTo(right2, this.posY - 0.5);
          g.lineTo(left2 + 2, this.posY - 0.5);
          g.fill();
          g.stroke();
          if (type7 === "txnb") {
            drawInversionCircle(left2 - 5, this.posY + GRID_STEP);
          }
          break;
        }
        case "?": {
          const gateRightSquare = left2 + (bottom2 - top2);
          g.strokeStyle = ctx.isMouseOver ? COLOR_MOUSE_OVER : COLOR_UNKNOWN;
          g.beginPath();
          g.moveTo(left2, top2);
          g.lineTo(gateRightSquare, top2);
          g.lineTo(gateRightSquare, bottom2);
          g.lineTo(left2, bottom2);
          g.closePath();
          g.fill();
          g.stroke();
          if (drawArms) {
            g.moveTo(left2, armsTop);
            g.lineTo(left2, armsBottom);
            g.stroke();
          }
          g.lineWidth = 0;
          ctx.inNonTransformedFrame(() => {
            g.fillStyle = COLOR_UNKNOWN;
            g.textAlign = "center";
            g.font = "bold 20px sans-serif";
            fillTextVAlign(g, TextVAlign.middle, "?", (left2 + gateRightSquare) / 2, this.posY);
          });
          break;
        }
      }
      if (this.parent.editor.options.showGateTypes && !isUnknown(type7)) {
        const gateShortName = this.gateTypes(this.numBits).props[type7].fullShortDesc()[1];
        if (gateShortName !== void 0) {
          g.fillStyle = COLOR_GATE_NAMES;
          g.font = "bold 13px sans-serif";
          const oldTransform = g.getTransform();
          g.translate(this.posX + nameDeltaX, this.posY);
          g.scale(0.65, 1);
          g.textAlign = "center";
          fillTextVAlign(g, TextVAlign.middle, gateShortName, 0, 0);
          g.setTransform(oldTransform);
        }
      }
    }
    mouseDoubleClicked(e) {
      if (this.parent.mode >= 4 /* FULL */ && e.altKey) {
        this.doSetShowAsUnknown(!this._showAsUnknown);
        return InteractionResult.SimpleChange;
      }
      return super.mouseDoubleClicked(e);
    }
    makeComponentSpecificContextMenuItems() {
      const items = [];
      const adminMode = this.parent.mode >= 4 /* FULL */;
      if (!this._showAsUnknown || adminMode) {
        const replaceBy = this.makeReplaceByMenuItem();
        if (replaceBy !== void 0) {
          items.push(
            ["start", replaceBy]
          );
        }
      }
      if (adminMode) {
        items.push(
          ["mid", this.makePoseAsMenuItem()],
          ...this.makeForceOutputsContextMenuItem()
        );
      }
      return items;
    }
    makeReplaceByMenuItem() {
      const gateTypes = this.gateTypes(this.numBits);
      const s = S.Components.Gate.contextMenu;
      const otherTypes = gateTypes.values.filter((t38) => t38 !== this._type && gateTypes.props[t38].includeInContextMenu).filter((t38) => this.parent.editor.allowGateType(t38));
      if (otherTypes.length === 0) {
        return void 0;
      }
      return MenuData.submenu("replace", s.ReplaceBy, [
        ...otherTypes.map((newType) => {
          const gateProps = gateTypes.props[newType];
          return MenuData.item(void 0, s.GateTempl.expand({ type: gateProps.fullShortDesc()[0] }), () => {
            const oldType = this._type;
            this.doSetType(newType);
            const ref = this.ref;
            if (ref !== void 0 && ref.startsWith(oldType)) {
              this.parent.components.regenerateIdOf(this);
            }
          });
        }),
        MenuData.sep(),
        MenuData.text(s.VariantChangeDesc)
      ]);
    }
    makePoseAsMenuItem() {
      const gateTypes = this.gateTypes(this.numBits);
      const s = S.Components.Gate.contextMenu;
      const otherTypes = gateTypes.values.filter((t38) => t38 !== this._type && gateTypes.props[t38].includeInPoseAs);
      const currentShowAsUnknown = this._showAsUnknown;
      const currentPoseAs = this.poseAs;
      return MenuData.submenu("questioncircled", s.ShowAs, [
        MenuData.item(
          !currentShowAsUnknown && currentPoseAs === void 0 ? "check" : "none",
          s.NormalGateTempl.expand({ type: gateTypes.props[this._type].fullShortDesc()[0] }),
          () => {
            this.poseAs = void 0;
            this.doSetShowAsUnknown(false);
          }
        ),
        MenuData.item(
          currentShowAsUnknown ? "check" : "none",
          s.UnknownGate,
          () => {
            this.poseAs = void 0;
            this.doSetShowAsUnknown(true);
          }
        ),
        MenuData.sep(),
        ...otherTypes.map((newType) => {
          const gateProps = gateTypes.props[newType];
          return MenuData.item(
            !currentShowAsUnknown && newType === currentPoseAs ? "check" : "none",
            s.GateTempl.expand({ type: gateProps.fullShortDesc()[0] }),
            () => {
              this.doSetShowAsUnknown(false);
              this.poseAs = newType;
            }
          );
        })
      ]);
    }
  };
  __name(GateBase, "GateBase");
  function validateGateType(GateTypes2, typeFromParam, typeFromJson, defaultFromDef, jsonTypeSuffix) {
    let typeToValidate;
    if (typeFromJson === void 0) {
      typeToValidate = typeFromParam;
    } else {
      if (jsonTypeSuffix !== void 0 && typeFromJson.endsWith(jsonTypeSuffix)) {
        typeToValidate = typeFromJson.slice(0, -jsonTypeSuffix.length);
      } else {
        typeToValidate = typeFromJson;
      }
    }
    if (!GateTypes2.includes(typeToValidate)) {
      console.error(`Invalid gate type: '${typeToValidate}'`);
      return defaultFromDef;
    }
    return typeToValidate;
  }
  __name(validateGateType, "validateGateType");
  var GateTypePrefix = "gate";
  var Gate1Def = defineParametrizedComponent(GateTypePrefix + "1", true, true, {
    variantName: ({ type: type7 }) => (
      // return array thus overriding default component id
      [type7]
    ),
    button: { imgWidth: 50 },
    repr: {
      // type not part of specific repr, using normal type field
      poseAs: typeOrUndefined(Gate1TypeRepr),
      showAsUnknown: typeOrUndefined(t25.boolean)
    },
    valueDefaults: {},
    params: {
      type: param("not")
    },
    validateParams: ({ type: paramType }, jsonType, defaults) => {
      const type7 = validateGateType(Gate1Types, paramType, jsonType, defaults.type.defaultValue);
      return { type: type7 };
    },
    idPrefix: ({ type: type7 }) => type7,
    size: () => ({
      gridWidth: 4,
      gridHeight: 4
    }),
    makeNodes: () => ({
      ins: { In: [[-4, 0, "w", { leadLength: 20 }]] },
      outs: { Out: [4, 0, "e", { leadLength: 20 }] }
    }),
    initialValue: () => false
  });
  var Gate1 = class extends GateBase {
    get numBits() {
      return 1;
    }
    constructor(parent, params, saved) {
      super(parent, Gate1Def.with(params), params.type, saved);
    }
    gateTypes() {
      return Gate1Types;
    }
    toJSON() {
      return super.toJSONBase();
    }
    mouseDoubleClicked(e) {
      const superChange = super.mouseDoubleClicked(e);
      if (superChange.isChange) {
        return superChange;
      }
      if (this.parent.mode >= 3 /* DESIGN */) {
        this.doSetType(this.type === "buf" ? "not" : "buf");
        return InteractionResult.SimpleChange;
      }
      return InteractionResult.NoChange;
    }
  };
  __name(Gate1, "Gate1");
  Gate1Def.impl = Gate1;
  var GateNDef = defineParametrizedComponent(GateTypePrefix + "", true, true, {
    variantName: ({ type: type7, bits }) => (
      // return array thus overriding default component id
      [type7, `${type7}-${bits}`]
    ),
    button: { imgWidth: 50 },
    repr: {
      // type not part of specific repr, using normal type field
      poseAs: typeOrUndefined(GateNTypeRepr),
      showAsUnknown: typeOrUndefined(t25.boolean)
    },
    valueDefaults: {},
    params: {
      bits: param(2, [2, 3, 4, 5, 6, 7, 8, 12, 16, 24, 32]),
      type: param("and")
    },
    validateParams: ({ type: paramType, bits }, jsonType, defaults) => {
      const type7 = validateGateType(bits > 2 ? Gate2toNTypes : GateNTypes, paramType, jsonType, defaults.type.defaultValue);
      return { type: type7, numBits: bits };
    },
    idPrefix: ({ type: type7 }) => type7,
    size: ({ numBits }) => {
      const tall = numBits !== 2 && numBits !== 4 && numBits !== 6;
      return {
        gridWidth: 4,
        gridHeight: tall ? 5 : 4
      };
    },
    makeNodes: ({ numBits }) => {
      const leadLength = 20;
      return {
        ins: {
          In: groupVertical("w", -4, 0, numBits, void 0, { leadLength })
        },
        outs: {
          Out: [4, 0, "e", { leadLength }]
        }
      };
    },
    initialValue: () => false
  });
  var GateN = class extends GateBase {
    constructor(parent, params, saved) {
      super(parent, GateNDef.with(params), params.type, saved);
      this.numBits = params.numBits;
      this.updateLeadsFor(params.type);
    }
    gateTypes(numBits) {
      return numBits > 2 ? Gate2toNTypes : GateNTypes;
    }
    toJSON() {
      return __spreadProps(__spreadValues({}, this.toJSONBase()), {
        bits: this.numBits !== GateNDef.aults.bits ? this.numBits : void 0
      });
    }
    mouseDoubleClicked(e) {
      const superChange = super.mouseDoubleClicked(e);
      if (superChange.isChange) {
        return superChange;
      }
      if (this.parent.mode >= 3 /* DESIGN */) {
        const newType = (() => {
          switch (this.type) {
            case "imply":
              return "rimply";
            case "rimply":
              return "imply";
            case "nimply":
              return "rnimply";
            case "rnimply":
              return "nimply";
            case "txa":
              return "txb";
            case "txb":
              return "txna";
            case "txna":
              return "txnb";
            case "txnb":
              return "txa";
            default:
              return void 0;
          }
        })();
        if (newType !== void 0) {
          this.doSetType(newType);
          return InteractionResult.SimpleChange;
        }
      }
      return InteractionResult.NoChange;
    }
    makeComponentSpecificContextMenuItems() {
      const s = S.Components.Generic.contextMenu;
      const changeBitsItems = Gate2OnlyTypes.includes(this.type) ? [] : [
        this.makeChangeParamsContextMenuItem("inputs", s.ParamNumInputs, this.numBits, "bits"),
        ["mid", MenuData.sep()]
      ];
      return [
        ...changeBitsItems,
        ...super.makeComponentSpecificContextMenuItems()
      ];
    }
  };
  __name(GateN, "GateN");
  GateNDef.impl = GateN;
  function* valueCombinations(n) {
    let curr = 0;
    const max3 = 1 << n;
    while (curr < max3) {
      const binString = curr.toString(2).padStart(n, "0");
      const valueArray = binString.split("").reverse().map((v) => v === "1");
      yield valueArray;
      curr++;
    }
  }
  __name(valueCombinations, "valueCombinations");
  function makeTruthTable([header, rows]) {
    const htmlRows = rows.map(
      ({ matchesCurrent, cells }) => tr(matchesCurrent ? cls("current") : emptyMod, ...cells.map((v) => td(asValue(v))))
    );
    return table(
      cls("truth-table"),
      thead(tr(
        ...header.map((title2) => th(title2))
      )),
      tbody(...htmlRows)
    );
  }
  __name(makeTruthTable, "makeTruthTable");
  function makeGateTooltip(numBits, title2, description, explanationAndTable) {
    const numBitsDisplay = Math.min(4, numBits);
    const maxWidth = 200 + Math.max(0, numBitsDisplay - 2) * 50;
    return tooltipContent(title2, mods(div(description), div(explanationAndTable)), maxWidth);
  }
  __name(makeGateTooltip, "makeGateTooltip");

  // simulator/src/components/GateArray.ts
  var t26 = __toESM(require_lib());
  var GateArrayDef = defineParametrizedComponent(GateTypePrefix + "-array", true, true, {
    variantName: ({ type: type7, bits }) => (
      // return array thus overriding default component id
      [`gate-array`, `${type7}-array`, `${type7}-array-${bits}`]
    ),
    idPrefix: "array",
    button: { imgWidth: 50 },
    repr: {
      // type not part of specific repr, using normal type field
      bits: typeOrUndefined(t26.number),
      showAsUnknown: typeOrUndefined(t26.boolean)
    },
    valueDefaults: {
      showAsUnknown: false
    },
    params: {
      bits: param(4, [2, 4, 8, 16]),
      type: param("and", GateNTypes.values)
    },
    validateParams: ({ type: paramType, bits }, jsonType, defaults) => {
      const type7 = validateGateType(GateNTypes, paramType, jsonType, defaults.type.defaultValue, "-array");
      return { type: type7, numBits: bits };
    },
    size: AdderArrayDef.size,
    makeNodes: ({ numBits }) => {
      const inputCenterY = 5 + Math.max(0, (numBits - 8) / 2);
      return {
        ins: {
          A: groupVertical("w", -3, -inputCenterY, numBits),
          B: groupVertical("w", -3, inputCenterY, numBits)
        },
        outs: {
          S: groupVertical("e", 3, 0, numBits)
        }
      };
    },
    initialValue: (saved, { numBits }) => ArrayFillWith(false, numBits)
  });
  var GateArray = class extends ParametrizedComponentBase {
    constructor(parent, params, saved) {
      var _a;
      super(parent, GateArrayDef.with(params), saved);
      this.numBits = params.numBits;
      this._type = params.type;
      this._showAsUnknown = (_a = saved == null ? void 0 : saved.showAsUnknown) != null ? _a : GateArrayDef.aults.showAsUnknown;
    }
    toJSON() {
      return __spreadProps(__spreadValues({}, this.toJSONBase()), {
        bits: this.numBits === GateArrayDef.aults.bits ? void 0 : this.numBits,
        showAsUnknown: this._showAsUnknown === GateArrayDef.aults.showAsUnknown ? void 0 : this._showAsUnknown
      });
    }
    jsonType() {
      return `${this._type}-array`;
    }
    get type() {
      return this._type;
    }
    makeTooltip() {
      const s = S.Components.GateArray.tooltip;
      const opDesc = S.Components.Gate[this._type][0];
      return tooltipContent(s.title, mods(
        div(s.desc.expand({ op: opDesc }))
      ));
    }
    doRecalcValue() {
      const out = GateNTypes.props[this._type].out;
      const a2 = this.inputValues(this.inputs.A);
      const b2 = this.inputValues(this.inputs.B);
      return ArrayFillUsing((i2) => out([a2[i2], b2[i2]]), this.numBits);
    }
    propagateValue(newValue) {
      this.outputValues(this.outputs.S, newValue);
    }
    doDraw(g, ctx) {
      this.doDrawDefault(g, ctx, {
        skipLabels: true,
        drawInside: ({ left: left2, right: right2 }) => {
          if (this._showAsUnknown) {
            ctx.inNonTransformedFrame(() => {
              g.fillStyle = COLOR_UNKNOWN;
              g.font = "bold 20px sans-serif";
              g.textAlign = "center";
              fillTextVAlign(g, TextVAlign.middle, "?", this.posX, this.posY);
            });
          } else {
            g.lineWidth = 2;
            g.strokeStyle = COLOR_COMPONENT_BORDER;
            g.beginPath();
            const top2 = this.posY - GRID_STEP;
            const bottom2 = this.posY + GRID_STEP;
            let gateLeft = left2 + 10;
            const gateRight = right2 - 10;
            const pi22 = Math.PI / 2;
            const type7 = this._type;
            const drawRightCircle = /* @__PURE__ */ __name(() => {
              g.beginPath();
              circle(g, gateRight + 3, this.posY, 5);
              g.stroke();
            }, "drawRightCircle");
            const drawLeftCircle = /* @__PURE__ */ __name((up) => {
              g.beginPath();
              circle(g, gateLeft - 3, this.posY - (up ? 1 : -1) * 4, 5);
              g.stroke();
            }, "drawLeftCircle");
            switch (type7) {
              case "and":
              case "nand":
              case "nimply":
              case "rnimply": {
                g.moveTo(this.posX, bottom2);
                g.lineTo(gateLeft, bottom2);
                g.lineTo(gateLeft, top2);
                g.lineTo(this.posX, top2);
                g.arc(this.posX, this.posY, GRID_STEP, -pi22, pi22);
                g.closePath();
                g.stroke();
                g.beginPath();
                if (type7.startsWith("nand")) {
                  drawRightCircle();
                }
                if (type7 === "nimply") {
                  drawLeftCircle(false);
                } else if (type7 === "rnimply") {
                  drawLeftCircle(true);
                }
                break;
              }
              case "or":
              case "nor":
              case "xor":
              case "xnor":
              case "imply":
              case "rimply": {
                g.beginPath();
                g.moveTo(gateLeft, top2);
                g.lineTo(this.posX - 5, top2);
                g.bezierCurveTo(
                  this.posX + 2,
                  top2,
                  gateRight - 5,
                  this.posY - 8,
                  gateRight,
                  this.posY
                );
                g.bezierCurveTo(
                  gateRight - 5,
                  this.posY + 8,
                  this.posX + 2,
                  bottom2,
                  this.posX - 5,
                  bottom2
                );
                g.lineTo(gateLeft, bottom2);
                g.quadraticCurveTo(this.posX - 4, this.posY, gateLeft, top2);
                g.closePath();
                g.stroke();
                const savedGateLeft = gateLeft;
                gateLeft += 2;
                if (type7.startsWith("nor") || type7.startsWith("xnor")) {
                  drawRightCircle();
                }
                if (type7 === "imply") {
                  drawLeftCircle(true);
                } else if (type7 === "rimply") {
                  drawLeftCircle(false);
                }
                if (type7.startsWith("x")) {
                  g.beginPath();
                  g.moveTo(savedGateLeft - 4, bottom2);
                  g.quadraticCurveTo(this.posX - 8, this.posY, savedGateLeft - 4, top2);
                  g.stroke();
                }
                break;
              }
              case "txa":
              case "txna": {
                g.beginPath();
                g.moveTo(gateLeft, bottom2);
                g.lineTo(gateLeft, top2);
                g.lineTo(gateRight, this.posY);
                g.lineTo(gateLeft + 2, this.posY);
                g.stroke();
                if (type7 === "txna") {
                  drawLeftCircle(true);
                }
                break;
              }
              case "txb":
              case "txnb": {
                g.beginPath();
                g.moveTo(gateLeft, top2);
                g.lineTo(gateLeft, bottom2);
                g.lineTo(gateRight, this.posY);
                g.lineTo(gateLeft + 2, this.posY);
                g.stroke();
                if (type7 === "txnb") {
                  drawLeftCircle(false);
                }
                break;
              }
            }
          }
        }
      });
    }
    doSetType(newSubtype) {
      this._type = newSubtype;
      this.setNeedsRecalc();
      this.requestRedraw({ why: "quad gate type changed", invalidateTests: true });
    }
    doSetShowAsUnknown(showAsUnknown) {
      this._showAsUnknown = showAsUnknown;
      this.requestRedraw({ why: "display as unknown changed" });
    }
    makeComponentSpecificContextMenuItems() {
      const s = S.Components.GateArray.contextMenu;
      const typeItems = [];
      const subtypes = ["and", "or", "xor", "nand", "nor", "xnor", "-", "imply", "rimply", "nimply", "rnimply"].filter((t38) => this.parent.editor.allowGateType(t38));
      if (subtypes.length !== 0) {
        if (subtypes[0] === "-") {
          subtypes.shift();
        } else if (subtypes[subtypes.length - 1] === "-") {
          subtypes.pop();
        }
        for (const subtype of subtypes) {
          if (subtype === "-") {
            typeItems.push(MenuData.sep());
          } else {
            const icon = this._type === subtype ? "check" : "none";
            typeItems.push(MenuData.item(icon, subtype.toUpperCase(), () => {
              this.doSetType(subtype);
            }));
          }
        }
      }
      const items = [];
      if (typeItems.length >= 2) {
        items.push(["mid", MenuData.submenu("settings", s.Type, typeItems)]);
      }
      if (this.parent.mode >= 4 /* FULL */) {
        const showAsUnknownItem = MenuData.item(this._showAsUnknown ? "check" : "none", s.ShowAsUnknown, () => {
          this.doSetShowAsUnknown(!this._showAsUnknown);
        });
        items.push(
          ["mid", showAsUnknownItem]
        );
      }
      items.push(
        ["mid", MenuData.sep()],
        this.makeChangeParamsContextMenuItem("inputs", S.Components.Generic.contextMenu.ParamNumBits, this.numBits, "bits"),
        ...this.makeForceOutputsContextMenuItem(true)
      );
      return items;
    }
  };
  __name(GateArray, "GateArray");
  GateArrayDef.impl = GateArray;

  // simulator/src/components/HalfAdder.ts
  var HalfAdderDef = defineComponent("halfadder", {
    idPrefix: "hadder",
    button: { imgWidth: 50 },
    valueDefaults: {},
    size: { gridWidth: 4, gridHeight: 6 },
    makeNodes: () => {
      const s = S.Components.Generic;
      return {
        ins: {
          A: [-4, -2, "w", "A", { hasTriangle: true }],
          B: [-4, 2, "w", "B", { hasTriangle: true }]
        },
        outs: {
          S: [4, -2, "e", s.OutputSumDesc, { hasTriangle: true }],
          C: [4, 2, "e", s.OutputCarryDesc, { hasTriangle: true }]
        }
      };
    },
    initialValue: () => ({ s: false, c: false })
  });
  var HalfAdder = class extends ComponentBase {
    constructor(parent, saved) {
      super(parent, HalfAdderDef, saved);
    }
    toJSON() {
      return this.toJSONBase();
    }
    makeTooltip() {
      const s = S.Components.HalfAdder.tooltip;
      return tooltipContent(s.title, mods(
        div(s.desc)
      ));
    }
    doRecalcValue() {
      const a2 = this.inputs.A.value;
      const b2 = this.inputs.B.value;
      if (isUnknown(a2) || isUnknown(b2) || isHighImpedance(a2) || isHighImpedance(b2)) {
        return { s: Unknown, c: Unknown };
      }
      const sum = +a2 + +b2;
      switch (sum) {
        case 0:
          return { s: false, c: false };
        case 1:
          return { s: true, c: false };
        case 2:
          return { s: false, c: true };
        default:
          console.log("ERROR: sum of halfadder is > 2");
          return { s: false, c: false };
      }
    }
    propagateValue(newValue) {
      this.outputs.S.value = newValue.s;
      this.outputs.C.value = newValue.c;
    }
    doDraw(g, ctx) {
      this.doDrawDefault(g, ctx, () => {
        g.fillStyle = COLOR_COMPONENT_BORDER;
        g.font = "26px sans-serif";
        g.textAlign = "center";
        fillTextVAlign(g, TextVAlign.middle, "+", this.posX, this.posY - 2);
      });
    }
    makeComponentSpecificContextMenuItems() {
      return this.makeForceOutputsContextMenuItem();
    }
  };
  __name(HalfAdder, "HalfAdder");
  HalfAdderDef.impl = HalfAdder;

  // simulator/src/components/Label.ts
  var t27 = __toESM(require_lib());
  var LabelDef = defineComponent("label", {
    idPrefix: "label",
    button: { imgWidth: 32 },
    repr: {
      text: t27.string,
      // align: typeOrUndefined(t.string), 
      font: typeOrUndefined(t27.string)
    },
    valueDefaults: {
      text: "Label",
      // align: "center" as const,
      font: FONT_LABEL_DEFAULT
    },
    size: { gridWidth: 4, gridHeight: 2 },
    // overridden
    makeNodes: () => ({})
  });
  var Label = class extends ComponentBase {
    constructor(parent, saved) {
      var _a, _b;
      super(parent, LabelDef, saved);
      this._cachedTextMetrics = void 0;
      this._text = (_a = saved == null ? void 0 : saved.text) != null ? _a : LabelDef.aults.text;
      this._font = (_b = saved == null ? void 0 : saved.font) != null ? _b : LabelDef.aults.font;
    }
    toJSON() {
      return __spreadProps(__spreadValues({}, this.toJSONBase()), {
        text: this._text,
        // align: this._align === LabelStringDefaults.align ? undefined : this._align,
        font: this._font === LabelDef.aults.font ? void 0 : this._font
      });
    }
    get unrotatedWidth() {
      var _a, _b;
      return (_b = (_a = this._cachedTextMetrics) == null ? void 0 : _a.width) != null ? _b : GRID_STEP * this._text.length;
    }
    get unrotatedHeight() {
      const metrics = this._cachedTextMetrics;
      if (metrics === void 0) {
        return 2 * GRID_STEP;
      }
      return metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
    }
    get text() {
      return this._text;
    }
    doRecalcValue() {
      return void 0;
    }
    get drawZIndex() {
      return DrawZIndex.Overlay;
    }
    doDraw(g, ctx) {
      g.font = this._font;
      g.lineWidth = 3;
      if (ctx.isMouseOver) {
        if (this._cachedTextMetrics === void 0) {
          this._cachedTextMetrics = g.measureText(this._text);
        }
        const width = this.unrotatedWidth;
        const height = this.unrotatedHeight;
        g.strokeStyle = ctx.borderColor;
        g.beginPath();
        g.rect(this.posX - width / 2, this.posY - height / 2, width, height);
        g.stroke();
      }
      g.fillStyle = COLOR_COMPONENT_BORDER;
      g.textAlign = "center";
      fillTextVAlign(g, TextVAlign.middle, this._text, this.posX, this.posY);
    }
    doSetText(text) {
      this._text = text;
      this._cachedTextMetrics = void 0;
      this.requestRedraw({ why: "text changed", invalidateMask: true });
    }
    doSetFont(font) {
      this._font = font;
      this._cachedTextMetrics = void 0;
      this.requestRedraw({ why: "font changed", invalidateMask: true });
    }
    makeComponentSpecificContextMenuItems() {
      const s = S.Components.Label.contextMenu;
      const setTextItem = MenuData.item("pen", s.ChangeText, this.runSetTextDialog.bind(this), "\u21A9\uFE0E");
      const setFontItem = MenuData.item("font", s.Font, () => {
        this.runSetFontDialog(this._font, LabelDef.aults.font, this.doSetFont.bind(this));
      });
      return [
        ["mid", setTextItem],
        ["mid", setFontItem]
      ];
    }
    runSetTextDialog() {
      const promptReturnValue = window.prompt(S.Components.Label.contextMenu.ChangeTextPrompt, this._text);
      if (promptReturnValue !== null) {
        const newText = promptReturnValue.length === 0 ? LabelDef.aults.text : promptReturnValue;
        this.doSetText(newText);
        return InteractionResult.SimpleChange;
      }
      return InteractionResult.NoChange;
    }
    keyDown(e) {
      if (e.key === "Enter" && !e.altKey) {
        this.runSetTextDialog();
      } else {
        super.keyDown(e);
      }
    }
    mouseDoubleClicked(e) {
      const superChange = super.mouseDoubleClicked(e);
      if (superChange.isChange) {
        return superChange;
      }
      return this.runSetTextDialog();
    }
  };
  __name(Label, "Label");
  LabelDef.impl = Label;

  // simulator/src/components/LatchSR.ts
  var LatchSRDef = defineComponent("latch-sr", __spreadProps(__spreadValues({
    idPrefix: "latch"
  }, FlipflopOrLatchDef), {
    makeNodes: () => {
      const base = FlipflopOrLatchDef.makeNodes();
      const s = S.Components.Generic;
      return {
        ins: {
          S: [-4, -2, "w", s.InputSetDesc, { prefersSpike: true }],
          R: [-4, 2, "w", s.InputResetDesc, { prefersSpike: true }]
        },
        outs: base.outs
      };
    }
  }));
  var LatchSR = class extends FlipflopOrLatch {
    constructor(parent, saved) {
      super(parent, LatchSRDef, saved);
    }
    toJSON() {
      return this.toJSONBase();
    }
    makeTooltip() {
      const s = S.Components.LatchSR.tooltip;
      return tooltipContent(s.title, mods(
        div(s.desc)
        // TODO more info
      ));
    }
    doRecalcValue() {
      const s = this.inputs.S.value;
      const r = this.inputs.R.value;
      this._isInInvalidState = false;
      if (s === true) {
        if (r === true) {
          this._isInInvalidState = true;
          return [false, false];
        } else {
          return [true, false];
        }
      }
      if (r === true) {
        return [false, true];
      }
      const q = this.outputs.Q.value;
      return [q, LogicValue.invert(q)];
    }
    makeComponentSpecificContextMenuItems() {
      const icon = this._showContent ? "check" : "none";
      const toggleShowContentItem = MenuData.item(icon, S.Components.Generic.contextMenu.ShowContent, () => {
        this.doSetShowContent(!this._showContent);
      });
      return [
        ["mid", toggleShowContentItem],
        ...this.makeForceOutputsContextMenuItem(true)
      ];
    }
  };
  __name(LatchSR, "LatchSR");
  LatchSRDef.impl = LatchSR;

  // simulator/src/components/Mux.ts
  var t28 = __toESM(require_lib());
  var MuxDef = defineParametrizedComponent("mux", true, true, {
    variantName: ({ from, to, bottom: bottom2 }) => `mux-${from}to${to}${bottom2 ? "b" : ""}`,
    idPrefix: "mux",
    button: { imgWidth: 50 },
    repr: {
      from: typeOrUndefined(t28.number),
      to: typeOrUndefined(t28.number),
      bottom: typeOrUndefined(t28.boolean),
      showWiring: typeOrUndefined(t28.boolean)
    },
    valueDefaults: {
      showWiring: true
    },
    params: {
      to: param(2, [1, 2, 4, 8, 16]),
      from: param(4),
      bottom: paramBool()
    },
    validateParams: ({ from, to, bottom: bottom2 }) => {
      const numFrom = Math.min(16 * to, Math.max(2 * to, from));
      const numGroups = Math.ceil(numFrom / to);
      const numSel = Math.ceil(Math.log2(numGroups));
      return { numFrom, numTo: to, numGroups, numSel, controlPinsAtBottom: bottom2 };
    },
    size: ({ numFrom, numTo, numGroups, numSel }) => {
      const gridWidth = 2 * numSel;
      const spacing = useCompact(numTo === 1 ? numFrom : numTo) ? 1 : 2;
      const addByGroupSep = numTo > 1 ? 1 : 0;
      const numLeftSlots = numFrom + (numGroups - 1) * addByGroupSep;
      const gridHeight = 1 + spacing * numLeftSlots;
      return { gridWidth, gridHeight };
    },
    makeNodes: ({ numTo, numGroups, numSel, controlPinsAtBottom }) => {
      const outX = 1 + numSel;
      const inX = -outX;
      const groupOfInputs = groupVerticalMulti("w", inX, 0, numGroups, numTo);
      const firstInputY = groupOfInputs[0][0][1];
      const lastGroup = groupOfInputs[groupOfInputs.length - 1];
      const lastInputY = lastGroup[lastGroup.length - 1][1];
      const selY = controlPinsAtBottom ? lastInputY + 2 : firstInputY - 2;
      return {
        ins: {
          I: groupOfInputs,
          S: groupHorizontal(controlPinsAtBottom ? "s" : "n", 0, selY, numSel, void 0, { leadLength: 35 })
        },
        outs: {
          Z: groupVertical("e", outX, 0, numTo)
        }
      };
    },
    initialValue: (saved, { numTo }) => ArrayFillWith(false, numTo)
  });
  var Mux = class extends ParametrizedComponentBase {
    constructor(parent, params, saved) {
      var _a;
      super(parent, MuxDef.with(params), saved);
      this.numFrom = params.numFrom;
      this.numTo = params.numTo;
      this.numGroups = params.numGroups;
      this.numSel = params.numSel;
      this.controlPinsAtBottom = params.controlPinsAtBottom;
      this._showWiring = (_a = saved == null ? void 0 : saved.showWiring) != null ? _a : MuxDef.aults.showWiring;
    }
    toJSON() {
      return __spreadProps(__spreadValues({}, super.toJSONBase()), {
        from: this.numFrom,
        to: this.numTo,
        bottom: this.controlPinsAtBottom === MuxDef.aults.bottom ? void 0 : this.controlPinsAtBottom,
        showWiring: this._showWiring !== MuxDef.aults.showWiring ? this._showWiring : void 0
      });
    }
    makeTooltip() {
      return tooltipContent(void 0, mods(
        div(S.Components.Mux.tooltip.expand({ from: this.numFrom, to: this.numTo }))
      ));
    }
    doRecalcValue() {
      const sels = this.inputValues(this.inputs.S);
      const sel = displayValuesFromArray(sels, false)[1];
      if (isUnknown(sel)) {
        return ArrayFillWith(Unknown, this.numTo);
      }
      return this.inputValues(this.inputs.I[sel]);
    }
    propagateValue(newValues) {
      this.outputValues(this.outputs.Z, newValues);
    }
    doDraw(g, ctx) {
      const { top: top2, left: left2, bottom: bottom2, right: right2 } = this.bounds();
      const dy = (right2 - left2) / 3;
      for (const inputGroup of this.inputs.I) {
        for (const input2 of inputGroup) {
          drawWireLineToComponent(g, input2);
        }
      }
      for (const sel of this.inputs.S) {
        drawWireLineToComponent(g, sel);
      }
      for (const output of this.outputs.Z) {
        drawWireLineToComponent(g, output);
      }
      g.fillStyle = COLOR_BACKGROUND;
      const outline = g.createPath();
      outline.moveTo(left2, top2);
      outline.lineTo(right2, top2 + dy);
      outline.lineTo(right2, bottom2 - dy);
      outline.lineTo(left2, bottom2);
      outline.closePath();
      g.fill(outline);
      if (this._showWiring) {
        const sels = this.inputValues(this.inputs.S);
        const sel = displayValuesFromArray(sels, false)[1];
        if (!isUnknown(sel)) {
          const neutral = this.parent.editor.options.hideWireColors;
          const selectedInputs = this.inputs.I[sel];
          const anchorDiffX = (right2 - left2) / 3;
          const wireStyle = this.parent.editor.options.wireStyle;
          const wireStyleBezier = wireStyle === WireStyles.bezier || wireStyle === WireStyles.auto;
          const timeFraction = ctx.drawParams.drawTimeAnimationFraction;
          for (let i2 = 0; i2 < selectedInputs.length; i2++) {
            this.parent.editor.options.wireStyle;
            g.beginPath();
            const fromY = selectedInputs[i2].posYInParentTransform;
            const toNode = this.outputs.Z[i2];
            const toY = toNode.posYInParentTransform;
            g.moveTo(left2 + 1, fromY);
            if (!wireStyleBezier) {
              g.lineTo(left2 + 3, fromY);
              g.lineTo(right2 - 3, toY);
              g.lineTo(right2 - 1, toY);
            } else {
              g.bezierCurveTo(
                left2 + anchorDiffX,
                fromY,
                // anchor left
                right2 - anchorDiffX,
                toY,
                // anchor right
                right2 - 1,
                toY
              );
            }
            strokeWireOutlineAndSingleValue(g, selectedInputs[i2].value, toNode.color, neutral, timeFraction);
          }
        }
      }
      g.lineWidth = 3;
      g.strokeStyle = ctx.borderColor;
      g.stroke(outline);
    }
    doSetShowWiring(showWiring) {
      this._showWiring = showWiring;
      this.requestRedraw({ why: "show wiring changed" });
    }
    makeComponentSpecificContextMenuItems() {
      const s = S.Components.MuxDemux.contextMenu;
      const icon = this._showWiring ? "check" : "none";
      const toggleShowWiringItem = MenuData.item(icon, s.ShowWiring, () => {
        this.doSetShowWiring(!this._showWiring);
      });
      return [
        this.makeChangeParamsContextMenuItem("outputs", s.ParamNumTo, this.numTo, "to"),
        this.makeChangeParamsContextMenuItem("inputs", s.ParamNumFrom, this.numFrom, "from", [2, 4, 8, 16].map((x) => x * this.numTo)),
        ["mid", MenuData.sep()],
        this.makeChangeBooleanParamsContextMenuItem(this.numSel === 1 ? S.Components.Generic.contextMenu.ParamControlBitAtBottom : S.Components.Generic.contextMenu.ParamControlBitsAtBottom, this.controlPinsAtBottom, "bottom"),
        ["mid", toggleShowWiringItem],
        ...this.makeForceOutputsContextMenuItem(true)
      ];
    }
  };
  __name(Mux, "Mux");
  MuxDef.impl = Mux;

  // simulator/src/components/RAM.ts
  var t30 = __toESM(require_lib());

  // simulator/src/components/ROM.ts
  var import_file_saver2 = __toESM(require_FileSaver_min());
  var t29 = __toESM(require_lib());
  var ROMRAMDef = defineAbstractParametrizedComponent({
    button: { imgWidth: 50 },
    repr: {
      bits: typeOrUndefined(t29.number),
      lines: typeOrUndefined(t29.number),
      showContent: typeOrUndefined(t29.boolean),
      displayRadix: typeOrUndefined(t29.number),
      content: typeOrUndefined(t29.union([t29.string, t29.array(t29.string)]))
    },
    valueDefaults: {
      showContent: true,
      displayRadix: void 0
    },
    params: {
      bits: param(4, [4, 8, 16, 24, 32]),
      lines: param(16, [4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048])
    },
    validateParams: ({ bits, lines }) => {
      const numAddressBits = Math.ceil(Math.log2(lines));
      const numWords = Math.pow(2, numAddressBits);
      return { numDataBits: bits, numAddressBits, numWords };
    },
    size: ({ numWords, numDataBits }) => ({
      gridWidth: 11,
      // always wide enough even for 256 lines
      gridHeight: Math.max(numWords <= 16 ? 16 : 22, numDataBits + 4)
    }),
    makeNodes: ({ numDataBits, numAddressBits, gridHeight }) => {
      const addrTopOffset = -Math.ceil((gridHeight + 1) / 2);
      return {
        ins: {
          Addr: groupHorizontal("n", 0, addrTopOffset, numAddressBits)
        },
        outs: {
          Q: groupVertical("e", 7, 0, numDataBits)
        }
      };
    },
    initialValue: (saved, { numDataBits, numWords }) => {
      if (saved === void 0 || saved.content === void 0) {
        return ROMRAMBase.defaultValue(numWords, numDataBits);
      }
      const mem = ROMRAMBase.contentsFromString(saved.content, numDataBits, numWords);
      const out = [...mem[0]];
      return { mem, out };
    }
  });
  var ROMRAMBase = class extends ParametrizedComponentBase {
    constructor(parent, SubclassDef, params, saved) {
      var _a, _b;
      super(parent, SubclassDef.with(params), saved);
      this.numDataBits = params.numDataBits;
      this.numAddressBits = params.numAddressBits;
      this.numWords = params.numWords;
      this._showContent = (_a = saved == null ? void 0 : saved.showContent) != null ? _a : !this.canShowContent() ? false : RAMDef.aults.showContent;
      this._displayRadix = (_b = saved == null ? void 0 : saved.displayRadix) != null ? _b : RAMDef.aults.displayRadix;
    }
    static defaultValue(numWords, numDataBits) {
      return ROMRAMBase.valueFilledWith(false, numWords, numDataBits);
    }
    static valueFilledWith(v, numWords, numDataBits) {
      const mem = new Array(numWords);
      for (let i2 = 0; i2 < numWords; i2++) {
        mem[i2] = ArrayFillWith(v, numDataBits);
      }
      const out = ArrayFillWith(v, numDataBits);
      return { mem, out };
    }
    static contentsFromString(stringRep, numDataBits, numWords) {
      const splitContent = isArray(stringRep) ? stringRep : stringRep.split(/\s+/);
      const mem = new Array(numWords);
      for (let i2 = 0; i2 < numWords; i2++) {
        const row = i2 >= splitContent.length ? ArrayFillWith(false, numDataBits) : valuesFromBinaryOrHexRepr(splitContent[i2], numDataBits);
        mem[i2] = row;
      }
      return mem;
    }
    toJSONBase() {
      return __spreadProps(__spreadValues({}, super.toJSONBase()), {
        bits: this.numDataBits === RAMDef.aults.bits ? void 0 : this.numDataBits,
        lines: this.numWords === RAMDef.aults.lines ? void 0 : this.numWords,
        showContent: !this.canShowContent() ? void 0 : this._showContent !== RAMDef.aults.showContent ? this._showContent : void 0,
        displayRadix: this._displayRadix !== RAMDef.aults.displayRadix ? this._displayRadix : void 0,
        content: this.contentRepr(" ", true)
      });
    }
    contentRepr(delim, trimEnd) {
      const cells = [];
      const useHex = this.numDataBits >= 8;
      const hexWidth = Math.ceil(this.numDataBits / 4);
      for (let addr = 0; addr < this.numWords; addr++) {
        const word = this.value.mem[addr];
        const wordRepr = useHex && allBooleans(word) ? hexStringRepr(word, hexWidth) : binaryStringRepr(word);
        cells.push(wordRepr);
      }
      if (trimEnd) {
        let numToSkip = 0;
        for (let addr = this.numWords - 1; addr >= 0; addr--) {
          if (isAllZeros(cells[addr])) {
            numToSkip++;
          } else {
            break;
          }
        }
        if (numToSkip > 0) {
          cells.splice(this.numWords - numToSkip, numToSkip);
        }
      }
      const result = cells.length === 0 ? void 0 : cells.join(delim);
      return result;
    }
    currentAddress() {
      const addrBits = this.inputValues(this.inputs.Addr);
      const [__, addr] = displayValuesFromArray(addrBits, false);
      return addr;
    }
    propagateValue(newValue) {
      this.outputValues(this.outputs.Q, newValue.out);
    }
    canShowContent() {
      return this.numWords <= 64 && this.numDataBits <= 16;
    }
    doSetShowContent(showContent) {
      this._showContent = showContent;
      this.requestRedraw({ why: "show content changed" });
    }
    doDraw(g, ctx) {
      this.doDrawDefault(g, ctx, (ctx2, { width, height }) => {
        const mem = this.value.mem;
        const addr = this.currentAddress();
        let contentBottom, labelCenter;
        if (!this._showContent || !this.canShowContent() || this.parent.editor.options.hideMemoryContent) {
          g.font = `bold 18px sans-serif`;
          g.fillStyle = COLOR_COMPONENT_BORDER;
          g.textAlign = "center";
          fillTextVAlign(g, TextVAlign.middle, this.moduleName, this.posX, this.posY - 6);
          g.font = `11px sans-serif`;
          const numWordsStr = this.numWords >= 1024 ? `${this.numWords / 1024}k` : this.numWords.toString();
          fillTextVAlign(g, TextVAlign.middle, `${numWordsStr} \xD7 ${this.numDataBits} bits`, this.posX, this.posY + 12);
          labelCenter = this.posX;
          contentBottom = this.posY + 25;
        } else {
          const isVertical = Orientation.isVertical(this.orient);
          const canUseTwoCols = isVertical;
          const addressedContentHeight = this._displayRadix !== void 0 ? 12 : 0;
          const contentCenterY = this.posY - addressedContentHeight / 2;
          const [availWidth, availHeight] = !isVertical ? [width - 42, height - 30 - addressedContentHeight] : [height - 66, width - 30 - addressedContentHeight];
          const arrowWidth = 10;
          let useTwoCols = false;
          let cellHeight = Math.floor((availHeight - addressedContentHeight) * 2 / this.numWords) / 2;
          if (cellHeight <= 2 && canUseTwoCols) {
            useTwoCols = true;
            cellHeight = Math.floor((availHeight - addressedContentHeight) * 4 / this.numWords) / 2;
          }
          if (!useTwoCols) {
            const cellWidth = Math.floor((availWidth - arrowWidth) * 2 / this.numDataBits) / 2;
            labelCenter = this.posX + 3;
            contentBottom = drawMemoryCells(g, mem, this.numDataBits, addr, 0, this.numWords, labelCenter, contentCenterY, cellWidth, cellHeight);
          } else {
            const cellWidth = Math.floor((availWidth / 2 - 2 * arrowWidth) * 2 / this.numDataBits) / 2;
            labelCenter = this.posX;
            contentBottom = drawMemoryCells(g, mem, this.numDataBits, addr, 0, this.numWords / 2, this.posX + 2 - 38, contentCenterY, cellWidth, cellHeight);
            drawMemoryCells(g, mem, this.numDataBits, addr, this.numWords / 2, this.numWords, this.posX + 2 + 38, contentCenterY, cellWidth, cellHeight);
          }
        }
        if (this._displayRadix !== void 0) {
          const word = isUnknown(addr) ? Unknown : displayValuesFromArray(mem[addr], false)[1];
          const repr = formatWithRadix(word, this._displayRadix, this.numDataBits, true);
          g.fillStyle = COLOR_COMPONENT_BORDER;
          g.textAlign = "center";
          fillTextVAlign(g, TextVAlign.top, `${repr}`, labelCenter, contentBottom + 3);
        }
      });
    }
    doSetDisplayRadix(additionalReprRadix) {
      this._displayRadix = additionalReprRadix;
      this.requestRedraw({ why: "additional display radix changed" });
    }
    doSetMem(mem) {
      const addr = this.currentAddress();
      const out = isUnknown(addr) ? ArrayFillWith(Unknown, this.numDataBits) : mem[addr];
      this.doSetValue({ mem, out }, true);
    }
    makeComponentSpecificContextMenuItems() {
      const s = S.Components.RAM.contextMenu;
      const sg = S.Components.Generic.contextMenu;
      const ss = S.Components.Display.contextMenu;
      const makeItemShowRadix = /* @__PURE__ */ __name((radix, desc) => {
        const icon2 = this._displayRadix === radix ? "check" : "none";
        return MenuData.item(icon2, desc, () => this.doSetDisplayRadix(radix));
      }, "makeItemShowRadix");
      const editContentItem = ["mid", MenuData.item("memcontent", s.EditContent, () => {
        const current = this.contentRepr(" ", false);
        const promptReturnValue = window.prompt(s.EditContentPrompt, current);
        if (promptReturnValue !== null) {
          this.doSetMem(RAM.contentsFromString(promptReturnValue, this.numDataBits, this.numWords));
        }
      })];
      const saveContentItem = ["mid", MenuData.item("download", s.SaveContent, () => {
        var _a;
        const blob = new Blob([this.contentRepr("\n", false)], { type: "text/plain" });
        const filename = this.parent.editor.documentDisplayName + "." + ((_a = this.ref) != null ? _a : this.moduleName.toLowerCase()) + "-content.txt";
        (0, import_file_saver2.saveAs)(blob, filename);
      })];
      const loadContentItem = ["mid", MenuData.item("open", s.LoadContent, () => {
        this.parent.editor.runFileChooser("text/plain", (file) => __async(this, null, function* () {
          const content = yield file.text();
          this.doSetMem(RAM.contentsFromString(content, this.numDataBits, this.numWords));
        }));
      })];
      const swapROMRAMItem = ["mid", MenuData.item("replace", s.SwapROMRAM, () => {
        const isROM = this instanceof ROM;
        const repr = this.toNodelessJSON();
        repr.type = isROM ? "ram" : "rom";
        const otherDef = isROM ? RAMDef : ROMDef;
        const newComp = otherDef.makeFromJSON(this.parent, repr);
        if (newComp === void 0) {
          console.warn("Could not swap ROM/RAM from repr:", repr);
          return InteractionResult.NoChange;
        }
        this.replaceWithComponent(newComp);
        return InteractionResult.SimpleChange;
      })];
      const additionalDisplayItems = ["mid", MenuData.submenu("eye", s.SelectedDataDisplay, [
        makeItemShowRadix(void 0, ss.DisplayNone),
        MenuData.sep(),
        makeItemShowRadix(2, ss.DisplayAsBinary),
        makeItemShowRadix(16, ss.DisplayAsHexadecimal),
        makeItemShowRadix(10, ss.DisplayAsDecimal),
        makeItemShowRadix(-10, ss.DisplayAsSignedDecimal),
        makeItemShowRadix(8, ss.DisplayAsOctal)
      ])];
      const icon = this._showContent ? "check" : "none";
      const toggleShowContentItems = !this.canShowContent() ? [] : [
        ["mid", MenuData.item(
          icon,
          sg.ShowContent,
          () => this.doSetShowContent(!this._showContent)
        )]
      ];
      return [
        ...this.makeSpecificROMRAMItems(),
        additionalDisplayItems,
        ...toggleShowContentItems,
        ["mid", MenuData.sep()],
        editContentItem,
        saveContentItem,
        loadContentItem,
        ["mid", MenuData.sep()],
        swapROMRAMItem,
        ["mid", MenuData.sep()],
        this.makeChangeParamsContextMenuItem("memlines", sg.ParamNumWords, this.numWords, "lines"),
        this.makeChangeParamsContextMenuItem("outputs", S.Components.Generic.contextMenu.ParamNumBits, this.numDataBits, "bits"),
        ...this.makeForceOutputsContextMenuItem(true)
      ];
    }
    makeSpecificROMRAMItems() {
      return [];
    }
  };
  __name(ROMRAMBase, "ROMRAMBase");
  function drawMemoryCells(g, mem, numDataBits, addr, start2, end2, centerX, centerY, cellWidth, cellHeight) {
    const numCellsToDraw = end2 - start2;
    const contentTop = centerY - numCellsToDraw / 2 * cellHeight;
    const contentLeft = centerX - numDataBits / 2 * cellWidth;
    const contentRight = contentLeft + numDataBits * cellWidth;
    const contentBottom = contentTop + numCellsToDraw * cellHeight;
    g.fillStyle = COLOR_EMPTY;
    g.fillRect(contentLeft, contentTop, contentRight - contentLeft, contentBottom - contentTop);
    for (let i2 = start2; i2 < end2; i2++) {
      for (let j = 0; j < numDataBits; j++) {
        const v = mem[i2][numDataBits - j - 1];
        if (v !== false) {
          g.fillStyle = colorForLogicValue(v);
          g.fillRect(contentLeft + j * cellWidth, contentTop + i2 * cellHeight, cellWidth, cellHeight);
        }
      }
    }
    g.strokeStyle = COLOR_COMPONENT_BORDER;
    g.lineWidth = 0.5;
    for (let i2 = 1; i2 < numCellsToDraw; i2++) {
      const y = contentTop + i2 * cellHeight;
      strokeSingleLine(g, contentLeft, y, contentRight, y);
    }
    for (let j = 1; j < numDataBits; j++) {
      const x = contentLeft + j * cellWidth;
      strokeSingleLine(g, x, contentTop, x, contentBottom);
    }
    const borderLineWidth = 2;
    g.lineWidth = borderLineWidth;
    g.strokeRect(contentLeft - borderLineWidth / 2, contentTop - borderLineWidth / 2, contentRight - contentLeft + borderLineWidth, contentBottom - contentTop + borderLineWidth);
    if (!isUnknown(addr) && addr >= start2 && addr < end2) {
      const arrowY = contentTop + (addr - start2) * cellHeight + cellHeight / 2;
      const arrowRight = contentLeft - 3;
      const arrowWidth = 8;
      const arrowHalfHeight = 3;
      g.beginPath();
      g.moveTo(arrowRight, arrowY);
      g.lineTo(arrowRight - arrowWidth, arrowY + arrowHalfHeight);
      g.lineTo(arrowRight - arrowWidth + 2, arrowY);
      g.lineTo(arrowRight - arrowWidth, arrowY - arrowHalfHeight);
      g.closePath();
      g.fillStyle = COLOR_COMPONENT_BORDER;
      g.fill();
    }
    return contentBottom;
  }
  __name(drawMemoryCells, "drawMemoryCells");
  var ROMDef = defineParametrizedComponent("rom", true, true, __spreadValues({
    variantName: ({ bits, lines }) => `rom-${lines}x${bits}`,
    idPrefix: "rom"
  }, ROMRAMDef));
  var ROM = class extends ROMRAMBase {
    constructor(parent, params, saved) {
      super(parent, ROMDef, params, saved);
    }
    toJSON() {
      return super.toJSONBase();
    }
    get moduleName() {
      return "ROM";
    }
    doRecalcValue() {
      const { mem } = this.value;
      const addr = this.currentAddress();
      const out = isUnknown(addr) ? ArrayFillWith(Unknown, this.numDataBits) : mem[addr];
      return { mem, out };
    }
    makeTooltip() {
      const s = S.Components.ROM.tooltip;
      return tooltipContent(s.title, mods(
        div(s.desc.expand({ numWords: this.numWords, numDataBits: this.numDataBits }))
        // TODO more info
      ));
    }
  };
  __name(ROM, "ROM");
  ROMDef.impl = ROM;

  // simulator/src/components/RAM.ts
  var RAMDef = defineParametrizedComponent("ram", true, true, __spreadProps(__spreadValues({
    variantName: ({ bits, lines }) => `ram-${lines}x${bits}`,
    idPrefix: "ram"
  }, ROMRAMDef), {
    repr: __spreadProps(__spreadValues({}, ROMRAMDef.repr), {
      trigger: typeOrUndefined(t30.keyof(EdgeTrigger))
    }),
    valueDefaults: __spreadProps(__spreadValues({}, ROMRAMDef.valueDefaults), {
      trigger: EdgeTrigger.rising
    }),
    makeNodes: (params, defaults) => {
      const base = ROMRAMDef.makeNodes(params, defaults);
      const { numDataBits, gridHeight } = params;
      const bottomOffset = Math.ceil((gridHeight + 1) / 2);
      const clockYOffset = bottomOffset - 2;
      const s = S.Components.Generic;
      return {
        ins: {
          Clock: [-7, clockYOffset, "w", s.InputClockDesc, { isClock: true }],
          WE: [-2, bottomOffset, "s", s.InputWriteEnableDesc],
          Clr: [2, bottomOffset, "s", s.InputClearDesc, { prefersSpike: true }],
          D: groupVertical("w", -7, 0, numDataBits),
          Addr: base.ins.Addr
        },
        outs: base.outs
      };
    }
  }));
  var RAM = class extends ROMRAMBase {
    constructor(parent, params, saved) {
      var _a;
      super(parent, RAMDef, params, saved);
      this._trigger = RAMDef.aults.trigger;
      this._lastClock = Unknown;
      this._trigger = (_a = saved == null ? void 0 : saved.trigger) != null ? _a : RAMDef.aults.trigger;
    }
    toJSON() {
      return __spreadProps(__spreadValues({}, super.toJSONBase()), {
        trigger: this._trigger !== RAMDef.aults.trigger ? this._trigger : void 0
      });
    }
    get moduleName() {
      return "RAM";
    }
    get trigger() {
      return this._trigger;
    }
    doSetTrigger(trigger) {
      this._trigger = trigger;
      this.requestRedraw({ why: "trigger changed", invalidateTests: true });
    }
    doRecalcValue() {
      const clear = this.inputs.Clr.value;
      const numWords = this.numWords;
      if (clear === true) {
        return RAM.valueFilledWith(false, numWords, this.numDataBits);
      }
      const addr = this.currentAddress();
      const prevClock = this._lastClock;
      const clock = this._lastClock = this.inputs.Clock.value;
      const oldState = this.value;
      const we = this.inputs.WE.value;
      if (we !== true || !Flipflop.isClockTrigger(this.trigger, prevClock, clock)) {
        const out = isUnknown(addr) ? ArrayFillWith(Unknown, this.numDataBits) : oldState.mem[addr];
        return { mem: oldState.mem, out };
      }
      if (isUnknown(addr)) {
        return RAM.valueFilledWith(Unknown, numWords, this.numDataBits);
      }
      const newData = this.inputValues(this.inputs.D).map(LogicValue.filterHighZ);
      const newState = new Array(numWords);
      for (let i2 = 0; i2 < numWords; i2++) {
        if (i2 === addr) {
          newState[i2] = newData;
        } else {
          newState[i2] = oldState.mem[i2];
        }
      }
      return { mem: newState, out: newData };
    }
    makeTooltip() {
      const s = S.Components.RAM.tooltip;
      return tooltipContent(s.title, mods(
        div(s.desc.expand({ numWords: this.numWords, numDataBits: this.numDataBits }))
        // TODO more info
      ));
    }
    override() {
      return [
        ...makeTriggerItems(this._trigger, this.doSetTrigger.bind(this)),
        ["mid", MenuData.sep()]
      ];
    }
  };
  __name(RAM, "RAM");
  RAMDef.impl = RAM;

  // simulator/src/components/Random.ts
  var t32 = __toESM(require_lib());

  // simulator/src/components/Register.ts
  var t31 = __toESM(require_lib());
  var RegisterBaseDef = defineAbstractParametrizedComponent({
    button: { imgWidth: 50 },
    repr: {
      bits: typeOrUndefined(t31.number),
      showContent: typeOrUndefined(t31.boolean),
      trigger: typeOrUndefined(t31.keyof(EdgeTrigger)),
      content: typeOrUndefined(t31.string)
    },
    valueDefaults: {
      showContent: true,
      trigger: EdgeTrigger.rising
    },
    params: {
      bits: param(4, [2, 4, 8, 16])
    },
    validateParams: ({ bits }) => ({
      numBits: bits
    }),
    size: ({ numBits }) => ({
      gridWidth: 7,
      gridHeight: numBits === 2 ? 11 : Math.max(15, 5 + numBits)
    }),
    makeNodes: ({ numBits, gridHeight }) => {
      const bottomOffset = (gridHeight + 1) / 2;
      const clockYOffset = bottomOffset - 2;
      const topOffset = -bottomOffset;
      const s = S.Components.Generic;
      return {
        ins: {
          Clock: [-5, clockYOffset, "w", s.InputClockDesc, { isClock: true }],
          Pre: [0, topOffset, "n", s.InputPresetDesc, { prefersSpike: true }],
          Clr: [0, bottomOffset, "s", s.InputClearDesc, { prefersSpike: true }]
        },
        outs: {
          Q: groupVertical("e", 5, 0, numBits)
        }
      };
    },
    initialValue: (saved, { numBits }) => {
      let content;
      if (saved === void 0 || (content = saved.content) === void 0) {
        return ArrayFillWith(false, numBits);
      }
      return valuesFromBinaryOrHexRepr(content, numBits);
    }
  });
  var RegisterBase = class extends ParametrizedComponentBase {
    constructor(parent, SubclassDef, params, saved) {
      var _a, _b;
      super(parent, SubclassDef.with(params), saved);
      this._isInInvalidState = false;
      this._lastClock = Unknown;
      this.numBits = params.numBits;
      this._showContent = (_a = saved == null ? void 0 : saved.showContent) != null ? _a : RegisterDef.aults.showContent;
      this._trigger = (_b = saved == null ? void 0 : saved.trigger) != null ? _b : RegisterDef.aults.trigger;
    }
    toJSONBase() {
      return __spreadProps(__spreadValues({
        bits: this.numBits === RegisterDef.aults.bits ? void 0 : this.numBits
      }, super.toJSONBase()), {
        showContent: this._showContent !== RegisterDef.aults.showContent ? this._showContent : void 0,
        trigger: this._trigger !== RegisterDef.aults.trigger ? this._trigger : void 0,
        content: this.contentRepr(true)
      });
    }
    contentRepr(undefinedIfTrivial) {
      const content = this.value;
      const hexWidth = Math.ceil(this.numBits / 4);
      const repr = allBooleans(content) ? hexStringRepr(content, hexWidth) : binaryStringRepr(content);
      return undefinedIfTrivial && isAllZeros(repr) ? void 0 : repr;
    }
    get trigger() {
      return this._trigger;
    }
    doRecalcValue() {
      const prevClock = this._lastClock;
      const clock = this._lastClock = this.inputs.Clock.value;
      const { isInInvalidState, newState } = Flipflop.doRecalcValueForSyncComponent(
        this,
        prevClock,
        clock,
        this.inputs.Pre.value,
        this.inputs.Clr.value
      );
      this._isInInvalidState = isInInvalidState;
      return newState;
    }
    makeInvalidState() {
      return ArrayFillWith(false, this.numBits);
    }
    makeStateFromMainValue(val) {
      return ArrayFillWith(val, this.numBits);
    }
    propagateValue(newValue) {
      this.outputValues(this.outputs.Q, newValue);
    }
    doSetShowContent(showContent) {
      this._showContent = showContent;
      this.requestRedraw({ why: "show content changed" });
    }
    doSetTrigger(trigger) {
      this._trigger = trigger;
      this.requestRedraw({ why: "trigger changed", invalidateTests: true });
    }
    doDraw(g, ctx) {
      this.doDrawDefault(g, ctx, (ctx2) => {
        if (this._showContent && !this.parent.editor.options.hideMemoryContent) {
          RegisterBase.drawStoredValues(g, ctx2, this.outputs.Q, this.posX, Orientation.isVertical(this.orient));
        } else {
          this.doDrawGenericCaption(g);
        }
      });
    }
    static drawStoredValues(g, ctx, outputs, posX, swapHeightWidth) {
      const cellHeight = useCompact(outputs.length) ? GRID_STEP : 2 * GRID_STEP;
      for (const output of outputs) {
        FlipflopOrLatch.drawStoredValue(g, output.value, ...ctx.rotatePoint(posX, output.posYInParentTransform), cellHeight, swapHeightWidth);
      }
    }
    makeComponentSpecificContextMenuItems() {
      const s = S.Components.Generic.contextMenu;
      const icon = this._showContent ? "check" : "none";
      const toggleShowContentItem = MenuData.item(
        icon,
        s.ShowContent,
        () => this.doSetShowContent(!this._showContent)
      );
      return [
        this.makeChangeParamsContextMenuItem("outputs", s.ParamNumBits, this.numBits, "bits"),
        ...this.makeRegisterSpecificContextMenuItems(),
        ["mid", MenuData.sep()],
        ...makeTriggerItems(this._trigger, this.doSetTrigger.bind(this)),
        ["mid", MenuData.sep()],
        ["mid", toggleShowContentItem],
        ...this.makeForceOutputsContextMenuItem(true)
      ];
    }
    makeRegisterSpecificContextMenuItems() {
      return [];
    }
  };
  __name(RegisterBase, "RegisterBase");
  var RegisterDef = defineParametrizedComponent("reg", true, true, __spreadProps(__spreadValues({
    variantName: ({ bits }) => `reg-${bits}`,
    idPrefix: "reg"
  }, RegisterBaseDef), {
    repr: __spreadProps(__spreadValues({}, RegisterBaseDef.repr), {
      inc: typeOrUndefined(t31.boolean),
      saturating: typeOrUndefined(t31.boolean)
    }),
    valueDefaults: __spreadProps(__spreadValues({}, RegisterBaseDef.valueDefaults), {
      saturating: false
    }),
    params: {
      bits: RegisterBaseDef.params.bits,
      inc: paramBool()
    },
    validateParams: ({ bits, inc }) => ({
      numBits: bits,
      hasIncDec: inc
    }),
    makeNodes: (params, defaults) => {
      const base = RegisterBaseDef.makeNodes(params, defaults);
      const baseClear = base.ins.Clr;
      const bottomOffset = base.ins.Clr[1];
      return {
        ins: __spreadValues(__spreadProps(__spreadValues({}, base.ins), {
          D: groupVertical("w", -5, 0, params.numBits)
        }), !params.hasIncDec ? {} : {
          Clr: [2, bottomOffset, "s", baseClear[3], baseClear[4]],
          // move Clr to the right
          Inc: [-2, bottomOffset, "s"],
          Dec: [0, bottomOffset, "s"]
        }),
        outs: base.outs
      };
    }
  }));
  var Register = class extends RegisterBase {
    constructor(parent, params, saved) {
      var _a;
      super(parent, RegisterDef, params, saved);
      this.hasIncDec = params.hasIncDec;
      this._saturating = this.hasIncDec && ((_a = saved == null ? void 0 : saved.saturating) != null ? _a : RegisterDef.aults.saturating);
    }
    toJSON() {
      return __spreadProps(__spreadValues({}, this.toJSONBase()), {
        inc: this.hasIncDec === RegisterDef.aults.inc ? void 0 : this.hasIncDec,
        saturating: this._saturating === RegisterDef.aults.saturating ? void 0 : this._saturating
      });
    }
    makeTooltip() {
      const s = S.Components.Register.tooltip;
      return tooltipContent(s.title, mods(
        div(s.desc.expand({ numBits: this.numBits }))
        // TODO more info
      ));
    }
    makeStateAfterClock() {
      var _a, _b, _c, _d;
      const inc = (_b = (_a = this.inputs.Inc) == null ? void 0 : _a.value) != null ? _b : false;
      const dec = (_d = (_c = this.inputs.Dec) == null ? void 0 : _c.value) != null ? _d : false;
      if (isUnknown(inc) || isUnknown(dec) || isHighImpedance(inc) || isHighImpedance(dec)) {
        return ArrayFillWith(false, this.numBits);
      }
      if (inc || dec) {
        if (inc && dec) {
          return this.value;
        }
        const [__, val] = displayValuesFromArray(this.value, false);
        if (isUnknown(val)) {
          return ArrayFillWith(Unknown, this.numBits);
        }
        let newVal;
        if (inc) {
          newVal = val + 1;
          if (newVal >= __pow(2, this.numBits)) {
            if (this._saturating) {
              return ArrayFillWith(true, this.numBits);
            }
            return ArrayFillWith(false, this.numBits);
          }
        } else {
          newVal = val - 1;
          if (newVal < 0) {
            if (this._saturating) {
              return ArrayFillWith(false, this.numBits);
            }
            return ArrayFillWith(true, this.numBits);
          }
        }
        return Counter.decimalToNBits(newVal, this.numBits);
      }
      return this.inputValues(this.inputs.D).map(LogicValue.filterHighZ);
    }
    doDrawGenericCaption(g) {
      g.font = `bold 15px sans-serif`;
      g.fillStyle = COLOR_COMPONENT_BORDER;
      g.textAlign = "center";
      fillTextVAlign(g, TextVAlign.middle, "Reg.", this.posX, this.posY - 8);
      g.font = `11px sans-serif`;
      fillTextVAlign(g, TextVAlign.middle, `${this.numBits} bits`, this.posX, this.posY + 10);
    }
    doSetSaturating(saturating) {
      this._saturating = saturating;
      this.requestRedraw({ why: "saturating changed", invalidateTests: true });
    }
    makeRegisterSpecificContextMenuItems() {
      const s = S.Components.Register.contextMenu;
      const toggleSaturatingItem = !this.hasIncDec ? [] : [
        ["mid", MenuData.item(
          this._saturating ? "check" : "none",
          s.Saturating,
          () => this.doSetSaturating(!this._saturating)
        )]
      ];
      return [
        this.makeChangeBooleanParamsContextMenuItem(s.ParamHasIncDec, this.hasIncDec, "inc"),
        ...toggleSaturatingItem
      ];
    }
  };
  __name(Register, "Register");
  RegisterDef.impl = Register;

  // simulator/src/components/Random.ts
  var RandomDef = defineParametrizedComponent("rand", true, true, {
    variantName: ({ bits }) => `rand-${bits}`,
    idPrefix: "rand",
    button: { imgWidth: 32 },
    repr: {
      bits: typeOrUndefined(t32.number),
      prob1: typeOrUndefined(t32.number),
      showProb: typeOrUndefined(t32.boolean),
      trigger: typeOrUndefined(t32.keyof(EdgeTrigger)),
      name: ComponentNameRepr
    },
    valueDefaults: {
      prob1: 0.5,
      showProb: false,
      trigger: EdgeTrigger.rising
    },
    params: {
      bits: param(1, [1, 2, 3, 4, 7, 8, 16])
    },
    validateParams: ({ bits }) => ({
      numBits: bits
    }),
    size: ({ numBits }) => ({
      gridWidth: 4,
      gridHeight: 4 + (useCompact(numBits) ? numBits / 2 : numBits) * 2
    }),
    makeNodes: ({ numBits, gridHeight }) => {
      const s = S.Components.Generic;
      const clockY = gridHeight / 2 - 1;
      return {
        ins: {
          Clock: [-3, clockY, "w", s.InputClockDesc, { isClock: true }]
        },
        outs: {
          Out: groupVertical("e", 3, 0, numBits)
        }
      };
    },
    initialValue: (saved, { numBits }) => ArrayFillWith(false, numBits)
  });
  var Random = class extends ParametrizedComponentBase {
    constructor(parent, params, saved) {
      var _a, _b, _c;
      super(parent, RandomDef.with(params), saved);
      this._lastClock = Unknown;
      this.numBits = params.numBits;
      this._prob1 = (saved == null ? void 0 : saved.prob1) !== void 0 ? Math.max(0, Math.min(1, saved.prob1)) : RandomDef.aults.prob1;
      this._showProb = (_a = saved == null ? void 0 : saved.showProb) != null ? _a : RandomDef.aults.showProb;
      this._trigger = (_b = saved == null ? void 0 : saved.trigger) != null ? _b : RandomDef.aults.trigger;
      this._name = (_c = saved == null ? void 0 : saved.name) != null ? _c : void 0;
    }
    toJSON() {
      return __spreadProps(__spreadValues({}, super.toJSONBase()), {
        bits: this.numBits === RandomDef.aults.bits ? void 0 : this.numBits,
        name: this._name,
        prob1: this._prob1 !== RandomDef.aults.prob1 ? this._prob1 : void 0,
        showProb: this._showProb !== RandomDef.aults.showProb ? this._showProb : void 0,
        trigger: this._trigger !== RandomDef.aults.trigger ? this._trigger : void 0
      });
    }
    get allowsForcedOutputs() {
      return false;
    }
    makeTooltip() {
      const s = S.Components.Random.tooltip;
      return tooltipContent(
        s.title,
        s.desc[0] + this._prob1 + s.desc[1]
      );
    }
    doRecalcValue() {
      const prevClock = this._lastClock;
      const clock = this._lastClock = this.inputs.Clock.value;
      if (!Flipflop.isClockTrigger(this._trigger, prevClock, clock)) {
        return this.value;
      }
      const randBool = /* @__PURE__ */ __name(() => {
        return Math.random() < this._prob1;
      }, "randBool");
      return ArrayFillUsing(randBool, this.numBits);
    }
    propagateValue(newValue) {
      this.outputValues(this.outputs.Out, newValue);
    }
    doDraw(g, ctx) {
      const outputValues = this.value;
      this.doDrawDefault(g, ctx, {
        componentName: [this._name, false, () => displayValuesFromArray(outputValues, false)[1]],
        skipLabels: true,
        drawLabels: (ctx2, { top: top2 }) => {
          if (this.numBits === 1) {
            const output = this.outputs.Out[0];
            FlipflopOrLatch.drawStoredValue(g, output.value, ...ctx2.rotatePoint(this.posX, output.posYInParentTransform), 26, false);
          } else {
            RegisterBase.drawStoredValues(g, ctx2, this.outputs.Out, this.posX, Orientation.isVertical(this.orient));
          }
          if (this._showProb) {
            const isVertical = Orientation.isVertical(this.orient);
            g.fillStyle = COLOR_COMPONENT_INNER_LABELS;
            g.font = "9px sans-serif";
            const probTextLastPart = String(Math.round(this._prob1 * 100) / 100).substring(1);
            const probTextParts = ["P(1)", "=", probTextLastPart];
            if (isVertical) {
              let currentOffset = -10;
              let offset2 = Math.abs(currentOffset);
              if (this.orient === "s") {
                currentOffset = -currentOffset;
                offset2 = -offset2;
              }
              for (const part of probTextParts) {
                drawLabel(ctx2, this.orient, part, "n", this.posX - currentOffset, top2 - 1, void 0);
                currentOffset += offset2;
              }
            } else {
              const probText = probTextParts.join("\u202F");
              drawLabel(ctx2, this.orient, probText, "n", this.posX, top2, void 0);
            }
          }
        }
      });
    }
    doSetName(name2) {
      this._name = name2;
      this.requestRedraw({ why: "name changed" });
    }
    doSetShowProb(showProb) {
      this._showProb = showProb;
      this.requestRedraw({ why: "show probability changed" });
    }
    makeComponentSpecificContextMenuItems() {
      const s = S.Components.Random.contextMenu;
      const icon = this._showProb ? "check" : "none";
      const toggleShowProbItem = MenuData.item(
        icon,
        s.ShowProb,
        () => this.doSetShowProb(!this._showProb)
      );
      return [
        ["mid", toggleShowProbItem],
        ["mid", MenuData.sep()],
        this.makeChangeParamsContextMenuItem("inputs", S.Components.Generic.contextMenu.ParamNumBits, this.numBits, "bits"),
        ["mid", MenuData.sep()],
        ["mid", this.makeSetNameContextMenuItem(this._name, this.doSetName.bind(this))]
      ];
    }
    keyDown(e) {
      if (e.key === "Enter" && !e.altKey) {
        this.runSetNameDialog(this._name, this.doSetName.bind(this));
      } else {
        super.keyDown(e);
      }
    }
  };
  __name(Random, "Random");
  RandomDef.impl = Random;

  // simulator/src/components/Rectangle.ts
  var t33 = __toESM(require_lib());
  var RectangleColor = {
    grey: "grey",
    red: "red",
    blue: "blue",
    yellow: "yellow",
    green: "green",
    turquoise: "turquoise"
  };
  var CaptionPosition = {
    n: "n",
    ne: "ne",
    e: "e",
    se: "se",
    s: "s",
    sw: "sw",
    w: "w",
    nw: "nw",
    c: "c"
  };
  var RectangleDef = defineComponent("rect", {
    idPrefix: "rect",
    button: { imgWidth: 32 },
    repr: {
      w: t33.number,
      h: t33.number,
      color: typeOrUndefined(t33.keyof(RectangleColor)),
      strokeWidth: typeOrUndefined(t33.number),
      noFill: typeOrUndefined(t33.boolean),
      rounded: typeOrUndefined(t33.boolean),
      caption: typeOrUndefined(t33.string),
      captionPos: typeOrUndefined(t33.keyof(CaptionPosition)),
      captionInside: typeOrUndefined(t33.boolean),
      font: typeOrUndefined(t33.string)
    },
    valueDefaults: {
      width: 10 * GRID_STEP,
      height: 10 * GRID_STEP,
      color: RectangleColor.yellow,
      strokeWidth: 2,
      noFill: false,
      rounded: false,
      caption: void 0,
      captionPos: CaptionPosition.n,
      captionInside: false,
      font: FONT_LABEL_DEFAULT
    },
    size: { gridWidth: 10, gridHeight: 10 },
    makeNodes: () => ({})
  });
  var Rectangle = class extends ComponentBase {
    constructor(parent, saved) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
      super(parent, RectangleDef, saved);
      this._w = (_a = saved == null ? void 0 : saved.w) != null ? _a : RectangleDef.aults.width;
      this._h = (_b = saved == null ? void 0 : saved.h) != null ? _b : RectangleDef.aults.height;
      this._color = (_c = saved == null ? void 0 : saved.color) != null ? _c : RectangleDef.aults.color;
      this._strokeWidth = (_d = saved == null ? void 0 : saved.strokeWidth) != null ? _d : RectangleDef.aults.strokeWidth;
      this._noFill = (_e = saved == null ? void 0 : saved.noFill) != null ? _e : RectangleDef.aults.noFill;
      this._rounded = (_f = saved == null ? void 0 : saved.rounded) != null ? _f : RectangleDef.aults.rounded;
      this._caption = (_g = saved == null ? void 0 : saved.caption) != null ? _g : RectangleDef.aults.caption;
      this._captionPos = (_h = saved == null ? void 0 : saved.captionPos) != null ? _h : RectangleDef.aults.captionPos;
      this._captionInside = (_i = saved == null ? void 0 : saved.captionInside) != null ? _i : RectangleDef.aults.captionInside;
      this._font = (_j = saved == null ? void 0 : saved.font) != null ? _j : RectangleDef.aults.font;
    }
    toJSON() {
      return __spreadProps(__spreadValues({}, this.toJSONBase()), {
        w: this._w,
        h: this._h,
        color: this._color,
        strokeWidth: this._strokeWidth,
        noFill: this._noFill === RectangleDef.aults.noFill ? void 0 : this._noFill,
        rounded: this._rounded === RectangleDef.aults.rounded ? void 0 : this._rounded,
        caption: this._caption === RectangleDef.aults.caption ? void 0 : this._caption,
        captionPos: this._captionPos === RectangleDef.aults.captionPos ? void 0 : this._captionPos,
        captionInside: this._captionInside === RectangleDef.aults.captionInside ? void 0 : this._captionInside,
        font: this._font === RectangleDef.aults.font ? void 0 : this._font
      });
    }
    canRotate() {
      return false;
    }
    get unrotatedWidth() {
      return this._w;
    }
    get unrotatedHeight() {
      return this._h;
    }
    doRecalcValue() {
      return void 0;
    }
    get drawZIndex() {
      return DrawZIndex.Background;
    }
    doDraw(g, ctx) {
      const width = this._w;
      const height = this._h;
      const left2 = this.posX - width / 2;
      const top2 = this.posY - height / 2;
      g.beginPath();
      if (this._rounded) {
        const r = 3 * this._strokeWidth;
        g.moveTo(left2 + r, top2);
        g.lineTo(left2 + width - r, top2);
        g.quadraticCurveTo(left2 + width, top2, left2 + width, top2 + r);
        g.lineTo(left2 + width, top2 + height - r);
        g.quadraticCurveTo(left2 + width, top2 + height, left2 + width - r, top2 + height);
        g.lineTo(left2 + r, top2 + height);
        g.quadraticCurveTo(left2, top2 + height, left2, top2 + height - r);
        g.lineTo(left2, top2 + r);
        g.quadraticCurveTo(left2, top2, left2 + r, top2);
      } else {
        g.rect(left2, top2, width, height);
      }
      g.closePath();
      if (!this._noFill) {
        g.fillStyle = COLOR_RECTANGLE_BACKGROUND[this._color];
        g.fill();
      }
      if (this._caption !== void 0) {
        g.fillStyle = COLOR_COMPONENT_BORDER;
        g.font = this._font;
        const metrics = g.measureText(this._caption);
        const offsetV = (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent + this._strokeWidth) / 2 + 2;
        const margin = 2;
        const offsetH = (metrics.width + this._strokeWidth) / 2 + margin;
        const captionY = (() => {
          switch (this._captionPos) {
            case "c":
            case "w":
            case "e":
              return this.posY;
            case "n":
            case "nw":
            case "ne":
              return this.posY - this.height / 2 + (this._captionInside ? 1 : -1) * offsetV;
            case "s":
            case "se":
            case "sw":
              return this.posY + this.height / 2 + (this._captionInside ? -1 : 1) * offsetV;
          }
        })();
        const captionX = (() => {
          switch (this._captionPos) {
            case "c":
            case "n":
            case "s":
              return this.posX;
            case "w":
              return this.posX - this.width / 2 + (this._captionInside ? 1 : -1) * offsetH;
            case "nw":
            case "sw":
              return this.posX - this.width / 2 + offsetH - (this._captionInside ? 0 : 1) * (margin + this._strokeWidth);
            case "e":
              return this.posX + this.width / 2 + (this._captionInside ? -1 : 1) * offsetH;
            case "ne":
            case "se":
              return this.posX + this.width / 2 - offsetH + (this._captionInside ? 0 : 1) * (margin + this._strokeWidth);
          }
        })();
        g.textAlign = "center";
        fillTextVAlign(g, TextVAlign.middle, this._caption, captionX, captionY);
      }
      if (ctx.isMouseOver) {
        g.lineWidth = Math.max(3, this._strokeWidth);
        g.strokeStyle = ctx.borderColor;
        g.stroke();
      } else if (this._strokeWidth > 0) {
        g.lineWidth = this._strokeWidth;
        g.strokeStyle = COLOR_RECTANGLE_BORDER[this._color];
        g.stroke();
      }
    }
    doSetColor(color) {
      this._color = color;
      this.requestRedraw({ why: "color changed" });
    }
    doSetStrokeWidth(strokeWidth) {
      this._strokeWidth = strokeWidth;
      this.requestRedraw({ why: "stroke width changed", invalidateMask: true });
    }
    doSetCaption(caption) {
      this._caption = caption;
      this.requestRedraw({ why: "caption changed" });
    }
    doSetCaptionPos(captionPos) {
      this._captionPos = captionPos;
      this.requestRedraw({ why: "caption position changed" });
    }
    doSetFont(font) {
      this._font = font;
      this.requestRedraw({ why: "font changed" });
    }
    makeCurrentSizeString() {
      return `${this._w} \xD7 ${this._h}`;
    }
    makeComponentSpecificContextMenuItems() {
      const s = S.Components.Rectangle.contextMenu;
      const currentSizeStr = this.makeCurrentSizeString();
      const setSizeItem = MenuData.item("dimensions", s.Size + ` (${currentSizeStr})\u2026`, () => this.runSetSizeDialog(currentSizeStr));
      const makeSetStrokeWidthItem = /* @__PURE__ */ __name((strokeWidth, desc) => {
        const isCurrent = this._strokeWidth === strokeWidth;
        const icon = isCurrent ? "check" : "none";
        return MenuData.item(icon, desc, () => this.doSetStrokeWidth(strokeWidth));
      }, "makeSetStrokeWidthItem");
      const makeItemUseColor = /* @__PURE__ */ __name((desc, color) => {
        const isCurrent = this._color === color;
        const icon = isCurrent ? "check" : "none";
        const action = isCurrent ? () => void 0 : () => this.doSetColor(color);
        if (color !== void 0) {
          const fillColorProp = this._noFill ? "" : `background-color: ${COLOR_RECTANGLE_BACKGROUND[color]}; `;
          const roundedProp = !this._rounded ? "" : "border-radius: 4px; ";
          const borderColor = COLOR_RECTANGLE_BORDER[color];
          return MenuData.item(icon, span(title(desc), style(`display: inline-block; width: 140px; height: 18px; ${fillColorProp}${roundedProp}margin-right: 8px; border: 2px solid ${borderColor}`)), action);
        } else {
          return MenuData.item(icon, desc, action);
        }
      }, "makeItemUseColor");
      const toggleRoundedItem = MenuData.item(this._rounded ? "check" : "none", s.Rounded, () => {
        this._rounded = !this._rounded;
        this.requestRedraw({ why: "rounded changed" });
      });
      const toggleNoFillItem = MenuData.item(!this._noFill ? "check" : "none", s.WithBackgroundColor, () => {
        this._noFill = !this._noFill;
        this.requestRedraw({ why: "nofill changed" });
      });
      const setCaptionItemName = this._caption !== void 0 ? s.ChangeTitle : s.SetTitle;
      const setCaptionItem = MenuData.item("pen", setCaptionItemName, () => this.runSetCaptionDialog(), "\u21A9\uFE0E");
      const makeItemSetPlacement = /* @__PURE__ */ __name((desc, placement) => {
        const isCurrent = this._captionPos === placement;
        const icon = isCurrent ? "check" : "none";
        const action = isCurrent ? () => void 0 : () => this.doSetCaptionPos(placement);
        return MenuData.item(icon, desc, action);
      }, "makeItemSetPlacement");
      const toggleCaptionInsideItems = this._captionPos === "c" ? [] : [
        MenuData.item(this._captionInside ? "check" : "none", s.InsideFrame, () => {
          this._captionInside = !this._captionInside;
          this.requestRedraw({ why: "caption inside changed" });
        }),
        MenuData.sep()
      ];
      const setFontItem = MenuData.item("font", s.Font, () => {
        this.runSetFontDialog(this._font, RectangleDef.aults.font, this.doSetFont.bind(this));
      });
      return [
        ["mid", setSizeItem],
        ["mid", MenuData.submenu("palette", s.Color, [
          toggleNoFillItem,
          MenuData.sep(),
          makeItemUseColor(s.ColorYellow, RectangleColor.yellow),
          makeItemUseColor(s.ColorRed, RectangleColor.red),
          makeItemUseColor(s.ColorGreen, RectangleColor.green),
          makeItemUseColor(s.ColorBlue, RectangleColor.blue),
          makeItemUseColor(s.ColorTurquoise, RectangleColor.turquoise),
          makeItemUseColor(s.ColorGrey, RectangleColor.grey)
        ])],
        ["mid", MenuData.submenu("strokewidth", s.Border, [
          makeSetStrokeWidthItem(0, s.BorderNone),
          MenuData.sep(),
          makeSetStrokeWidthItem(1, s.Border1px),
          makeSetStrokeWidthItem(2, s.Border2px),
          makeSetStrokeWidthItem(3, s.Border3px),
          makeSetStrokeWidthItem(5, s.Border5px),
          makeSetStrokeWidthItem(10, s.Border10px)
        ])],
        ["mid", toggleRoundedItem],
        ["mid", MenuData.sep()],
        ["mid", setCaptionItem],
        ["mid", setFontItem],
        ["mid", MenuData.submenu("placement", s.TitlePlacement, [
          ...toggleCaptionInsideItems,
          makeItemSetPlacement(s.PlacementTop, CaptionPosition.n),
          makeItemSetPlacement(s.PlacementTopLeft, CaptionPosition.nw),
          makeItemSetPlacement(s.PlacementTopRight, CaptionPosition.ne),
          makeItemSetPlacement(s.PlacementBottom, CaptionPosition.s),
          makeItemSetPlacement(s.PlacementBottomLeft, CaptionPosition.sw),
          makeItemSetPlacement(s.PlacementBottomRight, CaptionPosition.se),
          makeItemSetPlacement(s.PlacementLeft, CaptionPosition.w),
          makeItemSetPlacement(s.PlacementRight, CaptionPosition.e),
          makeItemSetPlacement(s.PlacementCenter, CaptionPosition.c)
        ])]
      ];
    }
    runSetSizeDialog(currentSizeStr) {
      var _a, _b;
      const promptReturnValue = window.prompt(S.Components.Rectangle.contextMenu.SizePrompt, currentSizeStr);
      if (promptReturnValue !== null) {
        let match;
        if ((match = new RegExp("^(?<w>\\d*)((\\s+|( *[\xD7x,;] *))(?<h>\\d*))?$").exec(promptReturnValue)) !== null) {
          const parse = /* @__PURE__ */ __name((s, dflt) => {
            if (s === void 0) {
              return dflt;
            }
            const n = parseInt(s);
            if (isNaN(n) || n <= 0) {
              return dflt;
            }
            return n;
          }, "parse");
          const w = parse((_a = match.groups) == null ? void 0 : _a.w, this._w);
          const h = parse((_b = match.groups) == null ? void 0 : _b.h, this._h);
          this.doSetDimensions(w, h);
        }
      }
    }
    doSetDimensions(w, h) {
      this._w = w;
      this._h = h;
      this.requestRedraw({ why: "size changed", invalidateMask: true });
    }
    wrapContents(selectedComps) {
      var _a;
      if (selectedComps.size === 0) {
        return;
      }
      let left2 = Number.POSITIVE_INFINITY;
      let top2 = Number.POSITIVE_INFINITY;
      let right2 = Number.NEGATIVE_INFINITY;
      let bottom2 = Number.NEGATIVE_INFINITY;
      for (const comp of selectedComps) {
        if (comp instanceof DrawableWithPosition) {
          left2 = Math.min(left2, comp.posX - comp.width / 2);
          top2 = Math.min(top2, comp.posY - comp.height / 2);
          right2 = Math.max(right2, comp.posX + comp.width / 2);
          bottom2 = Math.max(bottom2, comp.posY + comp.height / 2);
        }
      }
      const tryX = (left2 + right2) / 2;
      const tryY = (top2 + bottom2) / 2;
      const [x, y] = (_a = this.trySetPosition(tryX, tryY, true)) != null ? _a : [tryX, tryY];
      left2 = Math.floor((left2 + Math.max(0, tryX - x)) / GRID_STEP) * GRID_STEP;
      top2 = Math.floor((top2 + Math.max(0, tryY - y)) / GRID_STEP) * GRID_STEP;
      right2 = Math.ceil((right2 + Math.max(0, x - tryX)) / GRID_STEP) * GRID_STEP;
      bottom2 = Math.ceil((bottom2 + Math.max(0, y - tryY)) / GRID_STEP) * GRID_STEP;
      const w = right2 - left2 + 4 * GRID_STEP;
      const h = bottom2 - top2 + 4 * GRID_STEP;
      this.doSetDimensions(w, h);
    }
    runSetCaptionDialog() {
      const promptReturnValue = window.prompt(S.Components.Rectangle.contextMenu.SetTitlePrompt, this._caption);
      if (promptReturnValue !== null) {
        const newCaption = promptReturnValue.length === 0 ? void 0 : promptReturnValue;
        this.doSetCaption(newCaption);
      }
    }
    mouseDoubleClicked(__e2) {
      this.runSetSizeDialog(this.makeCurrentSizeString());
      return InteractionResult.SimpleChange;
    }
    keyDown(e) {
      if (e.key === "Enter" && !e.altKey) {
        this.runSetCaptionDialog();
      } else {
        super.keyDown(e);
      }
    }
  };
  __name(Rectangle, "Rectangle");
  RectangleDef.impl = Rectangle;

  // simulator/src/components/ShiftDisplay.ts
  var t34 = __toESM(require_lib());
  var import_json54 = __toESM(require_dist());
  var ShiftDisplayDecoders_ = {
    "raw": { decodeWidth: 1, maxDisplayWidth: 16, decode: (v) => v.toString() },
    "octal": { decodeWidth: 3, maxDisplayWidth: 16, decode: (v) => v.toString() },
    "hex": { decodeWidth: 4, maxDisplayWidth: 16, decode: (v) => v.toString(16).toUpperCase() },
    "ascii": { decodeWidth: 7, maxDisplayWidth: 12, decode: (v) => DisplayAscii.numberToAscii(v) },
    "ascii8": { decodeWidth: 8, maxDisplayWidth: 12, decode: (v) => DisplayAscii.numberToAscii(v & 127) },
    "uint4": { decodeWidth: 4, maxDisplayWidth: 8, decode: (v) => v.toString() },
    "int4": { decodeWidth: 4, maxDisplayWidth: 8, decode: (v) => (v > 7 ? v - 16 : v).toString() },
    "uint8": { decodeWidth: 8, maxDisplayWidth: 4, decode: (v) => v.toString() },
    "int8": { decodeWidth: 8, maxDisplayWidth: 4, decode: (v) => (v > 127 ? v - 256 : v).toString() },
    "uint16": { decodeWidth: 16, maxDisplayWidth: 1, decode: (v) => v.toString() },
    "int16": { decodeWidth: 16, maxDisplayWidth: 1, decode: (v) => (v > 32767 ? v - 65536 : v).toString() }
  };
  var ShiftDisplayDecoders = RichStringEnum.withProps()(ShiftDisplayDecoders_);
  var ShiftDisplayDef = defineComponent("shift-display", {
    idPrefix: "shiftdisp",
    button: { imgWidth: 50 },
    repr: {
      state: typeOrUndefined(t34.string),
      decodeAs: typeOrUndefined(t34.keyof(ShiftDisplayDecoders_)),
      groupEvery: typeOrUndefined(t34.number),
      maxItems: typeOrUndefined(t34.number),
      trigger: typeOrUndefined(t34.keyof(EdgeTrigger))
    },
    valueDefaults: {
      decodeAs: "raw",
      trigger: EdgeTrigger.rising
    },
    size: { gridWidth: 25, gridHeight: 5 },
    makeNodes: () => {
      const s = S.Components.Generic;
      return {
        ins: {
          Clock: [-14, 1, "w", s.InputClockDesc, { isClock: true }],
          Clr: [-10, 3, "s", s.InputClearDesc, { prefersSpike: true }],
          D: [-14, -1, "w", s.InputDataDesc]
        }
      };
    },
    initialValue: (saved) => {
      if (saved === void 0 || saved.state === void 0) {
        return { incoming: [], decoded: [] };
      }
      const incoming = [];
      for (let i2 = 0; i2 < saved.state.length; i2++) {
        const c = saved.state.charAt(i2);
        if (c === "1") {
          incoming.push(true);
        } else if (c === "0") {
          incoming.push(false);
        } else {
          incoming.push(Unknown);
        }
      }
      return { incoming, decoded: [] };
    }
  });
  var ShiftDisplay = class extends ComponentBase {
    constructor(parent, saved) {
      var _a, _b, _c, _d;
      super(parent, ShiftDisplayDef, saved);
      this._lastClock = Unknown;
      this._decodeAs = (_a = saved == null ? void 0 : saved.decodeAs) != null ? _a : ShiftDisplayDef.aults.decodeAs;
      this._groupEvery = (_b = saved == null ? void 0 : saved.groupEvery) != null ? _b : void 0;
      this._maxItems = (_c = saved == null ? void 0 : saved.maxItems) != null ? _c : void 0;
      this._trigger = (_d = saved == null ? void 0 : saved.trigger) != null ? _d : ShiftDisplayDef.aults.trigger;
      this.redecodeAll();
    }
    toJSON() {
      const stateArray = allBitsOf(this.value).map((b2) => toLogicValueRepr(b2));
      return __spreadProps(__spreadValues({}, this.toJSONBase()), {
        state: stateArray.length === 0 ? void 0 : stateArray.join(""),
        decodeAs: this._decodeAs !== ShiftDisplayDef.aults.decodeAs ? this._decodeAs : void 0,
        groupEvery: this._groupEvery,
        maxItems: this._maxItems,
        trigger: this._trigger !== ShiftDisplayDef.aults.trigger ? this._trigger : void 0
      });
    }
    get trigger() {
      return this._trigger;
    }
    makeTooltip() {
      return tooltipContent(S.Components.ShiftDisplay.tooltip, mods(
        div(import_json54.default.stringify(this.value))
        // TODO more info
      ));
    }
    doRecalcValue() {
      var _a;
      if (this.inputs.Clr.value === true) {
        return { incoming: [], decoded: [] };
      }
      const prevClock = this._lastClock;
      const clock = this._lastClock = this.inputs.Clock.value;
      const oldValue = this.value;
      if (Flipflop.isClockTrigger(this._trigger, prevClock, clock)) {
        const newBit = this.inputs.D.value;
        const decoder = ShiftDisplayDecoders.props[this._decodeAs];
        const maxItems = (_a = this._maxItems) != null ? _a : decoder.maxDisplayWidth;
        return ShiftDisplay.valueByAddingNewBit(newBit, oldValue, decoder, maxItems);
      }
      return oldValue;
    }
    static valueByAddingNewBit(newBit, oldValue, decoder, maxItems) {
      const newIncoming = [newBit, ...oldValue.incoming];
      if (newIncoming.length < decoder.decodeWidth) {
        return { incoming: newIncoming, decoded: oldValue.decoded };
      }
      const valAsInt = displayValuesFromArray(newIncoming, true)[1];
      const decoded = isUnknown(valAsInt) ? Unknown : decoder.decode(valAsInt);
      const newDecoded = [[decoded, newIncoming], ...oldValue.decoded];
      if (newDecoded.length > maxItems) {
        newDecoded.splice(maxItems, newDecoded.length - maxItems);
      }
      return { incoming: [], decoded: newDecoded };
    }
    doSetTrigger(trigger) {
      this._trigger = trigger;
      this.requestRedraw({ why: "trigger changed", invalidateTests: true });
    }
    doDraw(g, ctx) {
      this.doDrawDefault(g, ctx, {
        drawInside: () => {
          const drawContents = /* @__PURE__ */ __name(() => {
            const text = this.makeRepresentationString();
            let toDraw;
            if (text === void 0) {
              g.fillStyle = COLOR_COMPONENT_INNER_LABELS;
              g.font = "15px sans-serif";
              toDraw = S.Components.ShiftDisplay.EmptyCaption;
            } else {
              g.fillStyle = COLOR_COMPONENT_BORDER;
              g.font = "bold 16px sans-serif";
              toDraw = text;
            }
            fillTextVAlign(g, TextVAlign.middle, toDraw, this.posX, this.posY);
          }, "drawContents");
          g.textAlign = "center";
          if (this.orient === "w") {
            ctx.inNonTransformedFrame(drawContents);
          } else {
            drawContents();
          }
        }
      });
    }
    makeRepresentationString() {
      var _a;
      const { incoming, decoded } = this.value;
      if (incoming.length === 0 && decoded.length === 0) {
        return void 0;
      }
      const decodeAs = this._decodeAs;
      const decoder = ShiftDisplayDecoders.props[decodeAs];
      const toPad = decoder.decodeWidth - incoming.length;
      const padding = repeatString("_\u202F", toPad);
      const undecodedStr = padding + displayValuesFromArray(incoming, true)[0];
      const sep = decodeAs.includes("int") ? " " : "";
      let fullDecodedStr;
      if (decoded.length === 0) {
        fullDecodedStr = "\u2026";
      } else {
        const groupEvery = (_a = this._groupEvery) != null ? _a : 0;
        if (groupEvery < 2) {
          fullDecodedStr = decoded.map((v) => v[0]).join(sep);
        } else {
          const offset2 = groupEvery - decoded.length % groupEvery;
          const decodedParts = [];
          for (let i2 = 0; i2 < decoded.length; i2++) {
            if (i2 !== 0) {
              if ((i2 + offset2) % groupEvery === 0) {
                decodedParts.push(sep + " ");
              } else {
                decodedParts.push(sep);
              }
            }
            decodedParts.push(decoded[i2][0]);
          }
          fullDecodedStr = decodedParts.join("");
        }
        if (decodeAs === "hex") {
          fullDecodedStr = "0x" + (groupEvery < 2 ? "" : " ") + fullDecodedStr;
        } else if (decodeAs === "octal") {
          fullDecodedStr = "0o" + (groupEvery < 2 ? "" : " ") + fullDecodedStr;
        }
      }
      if (decodeAs === "raw") {
        return fullDecodedStr;
      }
      return undecodedStr + " \u279F " + fullDecodedStr;
    }
    redecodeAll() {
      var _a;
      const decoder = ShiftDisplayDecoders.props[this._decodeAs];
      const allBits = allBitsOf(this.value);
      const maxItems = (_a = this._maxItems) != null ? _a : decoder.maxDisplayWidth;
      let value = { incoming: [], decoded: [] };
      for (const newBit of allBits.reverse()) {
        value = ShiftDisplay.valueByAddingNewBit(newBit, value, decoder, maxItems);
      }
      this.doSetValue(value);
    }
    doSetDecodeAs(decodeAs) {
      this._decodeAs = decodeAs;
      this.redecodeAll();
    }
    doSetGroupEvery(groupEvery) {
      this._groupEvery = groupEvery;
      this.requestRedraw({ why: "grouping changed" });
    }
    makeComponentSpecificContextMenuItems() {
      const s = S.Components.ShiftDisplay.contextMenu;
      const makeItemDecodeAs = /* @__PURE__ */ __name((decoder, desc) => {
        const isCurrent = this._decodeAs === decoder;
        const icon = isCurrent ? "check" : "none";
        return MenuData.item(icon, desc, () => this.doSetDecodeAs(decoder));
      }, "makeItemDecodeAs");
      const makeItemGroupEvery = /* @__PURE__ */ __name((groupEvery, desc) => {
        const isCurrent = this._groupEvery === groupEvery;
        const icon = isCurrent ? "check" : "none";
        return MenuData.item(icon, desc, () => this.doSetGroupEvery(groupEvery));
      }, "makeItemGroupEvery");
      return [
        ...makeTriggerItems(this._trigger, this.doSetTrigger.bind(this)),
        ["mid", MenuData.sep()],
        ["mid", MenuData.submenu("eye", s.Decoding, [
          makeItemDecodeAs("raw", s.DecodingNone),
          makeItemDecodeAs("octal", s.DecodingOctal),
          makeItemDecodeAs("hex", s.DecodingHex),
          makeItemDecodeAs("ascii", s.DecodingAscii7),
          makeItemDecodeAs("ascii8", s.DecodingAscii8),
          makeItemDecodeAs("uint4", s.DecodingUint4),
          makeItemDecodeAs("int4", s.DecodingInt4),
          makeItemDecodeAs("uint8", s.DecodingUint8),
          makeItemDecodeAs("int8", s.DecodingInt8),
          makeItemDecodeAs("uint16", s.DecodingUint16),
          makeItemDecodeAs("int16", s.DecodingInt16),
          MenuData.sep(),
          MenuData.text(s.DecodingChangeWarning)
        ])],
        ["mid", MenuData.submenu("regroup", s.Grouping, [
          makeItemGroupEvery(void 0, s.GroupingNone),
          MenuData.sep(),
          makeItemGroupEvery(2, s.GroupBy.expand({ n: 2 })),
          makeItemGroupEvery(3, s.GroupBy.expand({ n: 3 })),
          makeItemGroupEvery(4, s.GroupBy.expand({ n: 4 })),
          makeItemGroupEvery(7, s.GroupBy.expand({ n: 7 })),
          makeItemGroupEvery(8, s.GroupBy.expand({ n: 8 })),
          makeItemGroupEvery(16, s.GroupBy.expand({ n: 16 }))
        ])]
      ];
    }
  };
  __name(ShiftDisplay, "ShiftDisplay");
  ShiftDisplayDef.impl = ShiftDisplay;
  function allBitsOf({ incoming, decoded }) {
    const allBits = [...incoming];
    for (const [__stringRep, bits] of decoded) {
      allBits.push(...bits);
    }
    return allBits;
  }
  __name(allBitsOf, "allBitsOf");

  // simulator/src/components/ShiftRegister.ts
  var ShiftRegisterDef = defineParametrizedComponent("shift-reg", true, true, __spreadProps(__spreadValues({
    variantName: ({ bits }) => `shift-reg-${bits}`,
    idPrefix: "reg"
  }, RegisterBaseDef), {
    makeNodes: (params, defaults) => {
      const base = RegisterBaseDef.makeNodes(params, defaults);
      const lrYOffset = base.ins.Clock[1] - 2;
      return {
        ins: __spreadProps(__spreadValues({}, base.ins), {
          D: [-5, 0, "w"],
          L\u0305R: [-5, lrYOffset, "w"]
        }),
        outs: base.outs
      };
    }
  }));
  var ShiftRegister = class extends RegisterBase {
    constructor(parent, params, saved) {
      super(parent, ShiftRegisterDef, params, saved);
    }
    toJSON() {
      return this.toJSONBase();
    }
    makeTooltip() {
      const s = S.Components.ShiftRegister.tooltip;
      return tooltipContent(s.title, mods(
        div(s.desc.expand({ numBits: this.numBits }))
        // TODO more info egenrically from register
      ));
    }
    makeStateAfterClock() {
      const dirIsRight = this.inputs.L\u0305R.value;
      if (isUnknown(dirIsRight) || isHighImpedance(dirIsRight)) {
        return this.makeStateFromMainValue(Unknown);
      }
      const d = LogicValue.filterHighZ(this.inputs.D.value);
      const current = this.value;
      const next = dirIsRight ? [...current.slice(1), d] : [d, ...current.slice(0, -1)];
      return next;
    }
    doDrawGenericCaption(g) {
      g.font = `bold 13px sans-serif`;
      g.fillStyle = COLOR_COMPONENT_BORDER;
      g.textAlign = "center";
      fillTextVAlign(g, TextVAlign.middle, "Shift R.", this.posX, this.posY - 8);
      g.font = `11px sans-serif`;
      fillTextVAlign(g, TextVAlign.middle, `${this.numBits} bits`, this.posX, this.posY + 10);
    }
  };
  __name(ShiftRegister, "ShiftRegister");
  ShiftRegisterDef.impl = ShiftRegister;

  // simulator/src/components/TristateBuffer.ts
  var t35 = __toESM(require_lib());
  var TristateBufferDef = defineParametrizedComponent("tristate", true, true, {
    variantName: ({ bottom: bottom2 }) => `tristate${bottom2 ? "b" : ""}`,
    idPrefix: "tristate",
    button: { imgWidth: 50 },
    repr: {
      bottom: typeOrUndefined(t35.boolean)
    },
    valueDefaults: {},
    params: {
      bottom: paramBool()
    },
    validateParams: ({ bottom: bottom2 }) => {
      return { controlPinsAtBottom: bottom2 };
    },
    size: () => ({ gridWidth: 4, gridHeight: 4 }),
    makeNodes: ({ controlPinsAtBottom }) => ({
      ins: {
        In: [-4, 0, "w", { leadLength: 20 }],
        E: [
          0,
          controlPinsAtBottom ? 3 : -3,
          controlPinsAtBottom ? "s" : "n",
          "E (Enable)",
          { leadLength: 20 }
        ]
      },
      outs: {
        Out: [4, 0, "e", { leadLength: 20 }]
      }
    }),
    initialValue: () => HighImpedance
  });
  var TristateBuffer = class extends ParametrizedComponentBase {
    constructor(parent, params, saved) {
      super(parent, TristateBufferDef.with(params), saved);
      this.controlPinsAtBottom = params.controlPinsAtBottom;
    }
    toJSON() {
      return __spreadProps(__spreadValues({}, this.toJSONBase()), {
        bottom: this.controlPinsAtBottom === TristateBufferDef.aults.bottom ? void 0 : this.controlPinsAtBottom
      });
    }
    makeTooltip() {
      return tooltipContent(void 0, mods(
        div(S.Components.TristateBuffer.tooltip)
        // TODO
      ));
    }
    doRecalcValue() {
      const en = this.inputs.E.value;
      if (isUnknown(en) || isHighImpedance(en)) {
        return Unknown;
      }
      if (!en) {
        return HighImpedance;
      }
      const i2 = this.inputs.In.value;
      if (isHighImpedance(i2)) {
        return Unknown;
      }
      return i2;
    }
    propagateValue(newValue) {
      this.outputs.Out.value = newValue;
    }
    doDraw(g, ctx) {
      drawWireLineToComponent(g, this.inputs.In);
      drawWireLineToComponent(g, this.inputs.E);
      drawWireLineToComponent(g, this.outputs.Out);
      const { top: top2, bottom: bottom2 } = this.bounds();
      const gateWidth = 2 * Math.max(2, this.inputs._all.length) * GRID_STEP;
      const gateLeft = this.posX - gateWidth / 2;
      const gateRight = this.posX + gateWidth / 2;
      g.fillStyle = COLOR_BACKGROUND;
      g.strokeStyle = ctx.isMouseOver ? COLOR_MOUSE_OVER : COLOR_COMPONENT_BORDER;
      g.lineWidth = 3;
      g.beginPath();
      g.moveTo(gateLeft, top2);
      g.lineTo(gateRight, this.posY);
      g.lineTo(gateLeft, bottom2);
      g.closePath();
      g.stroke();
    }
    makeComponentSpecificContextMenuItems() {
      return [
        this.makeChangeBooleanParamsContextMenuItem(S.Components.Generic.contextMenu.ParamControlBitAtBottom, this.controlPinsAtBottom, "bottom")
      ];
    }
  };
  __name(TristateBuffer, "TristateBuffer");
  TristateBufferDef.impl = TristateBuffer;

  // simulator/src/components/TristateBufferArray.ts
  var t36 = __toESM(require_lib());
  var TristateBufferArrayDef = defineParametrizedComponent("tristate-array", true, true, {
    variantName: ({ bits, bottom: bottom2 }) => `tristate-array-${bits}${bottom2 ? "b" : ""}`,
    idPrefix: "tristate",
    button: { imgWidth: 50 },
    repr: {
      bits: typeOrUndefined(t36.number),
      bottom: typeOrUndefined(t36.boolean)
    },
    valueDefaults: {},
    params: {
      bits: param(4, [2, 4, 8, 16]),
      bottom: paramBool()
    },
    validateParams: ({ bits, bottom: bottom2 }) => ({
      numBits: bits,
      controlPinsAtBottom: bottom2
    }),
    size: ControlledInverterDef.size,
    makeNodes: ({ numBits, controlPinsAtBottom, gridHeight }) => ({
      ins: {
        In: groupVertical("w", -3, 0, numBits),
        E: [
          0,
          -(gridHeight / 2 + 1) * (controlPinsAtBottom ? -1 : 1),
          controlPinsAtBottom ? "s" : "n",
          "E (Enable)"
        ]
      },
      outs: {
        Out: groupVertical("e", 3, 0, numBits)
      }
    }),
    initialValue: (saved, { numBits }) => ArrayFillWith(HighImpedance, numBits)
  });
  var TristateBufferArray = class extends ParametrizedComponentBase {
    constructor(parent, params, saved) {
      super(parent, TristateBufferArrayDef.with(params), saved);
      this.numBits = params.numBits;
      this.controlPinsAtBottom = params.controlPinsAtBottom;
    }
    toJSON() {
      return __spreadProps(__spreadValues({}, this.toJSONBase()), {
        bits: this.numBits === TristateBufferArrayDef.aults.bits ? void 0 : this.numBits,
        bottom: this.controlPinsAtBottom === TristateBufferArrayDef.aults.bottom ? void 0 : this.controlPinsAtBottom
      });
    }
    makeTooltip() {
      const s = S.Components.TristateBufferArray.tooltip;
      return tooltipContent(s.title, mods(
        div(s.desc)
      ));
    }
    doRecalcValue() {
      const enable = this.inputs.E.value;
      if (isUnknown(enable) || isHighImpedance(enable)) {
        return ArrayFillWith(Unknown, this.numBits);
      }
      if (!enable) {
        return ArrayFillWith(HighImpedance, this.numBits);
      }
      return this.inputValues(this.inputs.In);
    }
    propagateValue(newValue) {
      this.outputValues(this.outputs.Out, newValue);
    }
    doDraw(g, ctx) {
      this.doDrawDefault(g, ctx, {
        skipLabels: true,
        drawInside: ({ top: top2, bottom: bottom2, left: left2, right: right2 }) => {
          const enable = this.inputs.E.value;
          g.lineWidth = 2;
          g.strokeStyle = colorForLogicValue(enable);
          g.beginPath();
          if (this.controlPinsAtBottom) {
            g.moveTo(this.posX, bottom2);
            g.lineTo(this.posX, this.posY + 4);
          } else {
            g.moveTo(this.posX, top2);
            g.lineTo(this.posX, this.posY - 4);
          }
          g.stroke();
          g.strokeStyle = COLOR_COMPONENT_BORDER;
          g.beginPath();
          g.moveTo(left2 + 12, this.posY - 8);
          g.lineTo(right2 - 13, this.posY);
          g.lineTo(left2 + 12, this.posY + 8);
          g.closePath();
          g.stroke();
        }
      });
    }
    makeComponentSpecificContextMenuItems() {
      const s = S.Components.Generic.contextMenu;
      return [
        this.makeChangeParamsContextMenuItem("inputs", s.ParamNumBits, this.numBits, "bits"),
        this.makeChangeBooleanParamsContextMenuItem(s.ParamControlBitAtBottom, this.controlPinsAtBottom, "bottom"),
        ...this.makeForceOutputsContextMenuItem(true)
      ];
    }
  };
  __name(TristateBufferArray, "TristateBufferArray");
  TristateBufferArrayDef.impl = TristateBufferArray;

  // simulator/src/ComponentFactory.ts
  var AllComponentDefs = [
    // in
    InputDef,
    ClockDef,
    RandomDef,
    // out
    OutputDef,
    DisplayDef,
    Display7SegDef,
    Display16SegDef,
    DisplayAsciiDef,
    DisplayBarDef,
    ShiftDisplayDef,
    // gates
    Gate1Def,
    GateNDef,
    GateArrayDef,
    TristateBufferDef,
    TristateBufferArrayDef,
    ControlledInverterDef,
    // labels & layout
    LabelDef,
    RectangleDef,
    PassthroughDef,
    // ic
    HalfAdderDef,
    AdderDef,
    ComparatorDef,
    AdderArrayDef,
    ALUDef,
    MuxDef,
    DemuxDef,
    LatchSRDef,
    FlipflopJKDef,
    FlipflopTDef,
    FlipflopDDef,
    RegisterDef,
    ShiftRegisterDef,
    ROMDef,
    RAMDef,
    CounterDef,
    DecoderDef,
    Decoder7SegDef,
    Decoder16SegDef,
    DecoderBCD4Def
  ];
  var ComponentFactory = class {
    constructor(editor) {
      this._predefinedComponents = /* @__PURE__ */ new Map();
      this._customComponents = /* @__PURE__ */ new Map();
      this.editor = editor;
      for (const maker of AllComponentDefs) {
        const key = maker.type;
        if (!maker.isValid()) {
          throw new Error(`Implementation missing for components of type '${key}'`);
        }
        if (this._predefinedComponents.has(key)) {
          throw new Error(`Duplicate component for components of type '${key}'`);
        }
        this._predefinedComponents.set(key, maker);
      }
    }
    // Component creation functions
    makeFromJSON(parent, obj_, offsetPos) {
      if (!isRecord(obj_)) {
        console.warn(`Skipping invalid non-object component: ${import_json55.default.stringify(obj_, null, 2)}`);
        return void 0;
      }
      const obj = obj_;
      if (offsetPos !== void 0) {
        if (isArray(obj.pos)) {
          obj.pos = [obj.pos[0] + offsetPos[0], obj.pos[1] + offsetPos[1]];
        }
      }
      const type7 = isString(obj.type) ? obj.type : "<unknown>";
      const maker = this.getMaker(type7);
      return maker == null ? void 0 : maker.makeFromJSON(parent, obj);
    }
    makeFromButton(parent, elem) {
      const compDataset = elem.dataset;
      const paramsStr = compDataset.params;
      const maker = this.getMaker(compDataset.type);
      const params = paramsStr === void 0 ? void 0 : import_json55.default.parse(paramsStr);
      return maker == null ? void 0 : maker.make(parent, params);
    }
    getMaker(type7) {
      let maker;
      if ((maker = this._predefinedComponents.get(type7)) !== void 0) {
        return maker;
      }
      if (Gate1Types.includes(type7)) {
        return Gate1Def;
      } else if (GateNTypes.includes(type7)) {
        return GateNDef;
      }
      const hyphenPos = type7.indexOf("-");
      if (hyphenPos !== -1) {
        const typeStart = type7.substring(0, hyphenPos);
        const typeEnd = type7.substring(hyphenPos + 1);
        if (typeEnd === "array" && GateNTypes.includes(typeStart)) {
          return GateArrayDef;
        }
        if (type7.startsWith(CustomComponentPrefix)) {
          const customId = type7.substring(CustomComponentPrefix.length);
          if ((maker = this._customComponents.get(customId)) !== void 0) {
            return maker;
          }
        }
      }
      console.warn(`Unknown component for '${type7}'`);
      return void 0;
    }
    // Custom components handling
    getCustomDef(customId) {
      return this._customComponents.get(customId);
    }
    customDefs() {
      if (this._customComponents.size === 0) {
        return void 0;
      }
      return [...this._customComponents.values()];
    }
    customDefReprs() {
      const defs = this.customDefs();
      if (defs === void 0) {
        return void 0;
      }
      return defs.map((def) => def.toJSON());
    }
    clearCustomDefs() {
      this._customComponents.clear();
    }
    getCustomComponentTypesWhichUse(id) {
      const compIds = [id];
      for (const def of this._customComponents.values()) {
        if (def.uses(id, [true, this])) {
          compIds.push(def.type);
        }
      }
      return compIds;
    }
    tryAddCustomDef(def, overwrite) {
      const customid = def.customId;
      if (!overwrite && this._customComponents.has(customid)) {
        console.warn(`Could not add custom component with duplicate id '${customid}'`);
        return void 0;
      }
      this._customComponents.set(customid, def);
      return def;
    }
    tryLoadCustomDefsFrom(defs) {
      if (defs === void 0) {
        return 0;
      }
      const validatedDefs = validateJson(defs, t37.array(CustomComponentDefRepr), "defs");
      if (validatedDefs === void 0) {
        return 0;
      }
      let numLoaded = 0;
      for (const validatedDef of validatedDefs) {
        const maker = this.tryAddCustomDef(new CustomComponentDef(validatedDef), false);
        if (maker !== void 0) {
          numLoaded++;
        }
      }
      return numLoaded;
    }
    hasCustomComponents() {
      return this._customComponents.size > 0;
    }
    makeContextMenu(id) {
      const customId = id.substring(CustomComponentPrefix.length);
      const def = this._customComponents.get(customId);
      if (def === void 0) {
        return void 0;
      }
      const s = S.Components.Custom.contextMenu;
      return [
        MenuData.item("pen", s.ChangeName, () => this.runChangeCustomComponentCaptionDialog(def)),
        MenuData.item("connect", s.ChangeCircuit, () => {
          window.alert(s.EditFromComponentMessage);
        }),
        MenuData.sep(),
        MenuData.item("trash", s.Delete, () => {
          if (this.editor.components.contains(id)) {
            window.alert(s.CannotDeleteInUse);
            return;
          }
          for (const compDef of this._customComponents.values()) {
            if (compDef.uses(def.type, false)) {
              window.alert(s.CannotDeleteInUseBy.expand({ caption: compDef.caption }));
              return;
            }
          }
          if (window.confirm(s.ConfirmDelete)) {
            this._customComponents.delete(customId);
            this.editor.updateCustomComponentButtons();
          }
        }, void 0, true)
      ];
    }
    runChangeCustomComponentCaptionDialog(def) {
      var _a;
      const s = S.Components.Custom.contextMenu;
      const oldCaption = def.caption;
      const oldType = def.type;
      while (true) {
        const newCaption = window.prompt(s.ChangeNamePrompt, oldCaption);
        if (newCaption === null || newCaption === oldCaption) {
          return;
        }
        if (newCaption.length === 0) {
          window.alert(s.ChangeNameEmpty);
          continue;
        }
        def.doSetCaption(newCaption);
        const oldDefaultCustomId = makeCustomIdFromCaption(oldCaption);
        if (def.customId === oldDefaultCustomId) {
          const newCustomId = makeCustomIdFromCaption(newCaption);
          if (!this._customComponents.has(newCustomId)) {
            this._customComponents.delete(oldDefaultCustomId);
            def.customId = newCustomId;
            const newType = def.type;
            for (const compDef of this._customComponents.values()) {
              for (const compRepr of Object.values((_a = compDef.circuit.components) != null ? _a : {})) {
                if (compRepr.type === oldType) {
                  compRepr.type = newType;
                }
              }
            }
            this._customComponents.set(newCustomId, def);
          }
        }
        break;
      }
      this.editor.updateCustomComponentButtons();
      this.editor.components.updateCustomComponents(oldType);
      this.editor.focus();
    }
    tryMakeNewCustomComponent(editor) {
      var _a;
      const s = S.Components.Custom.messages;
      const selectionAll = (_a = editor.eventMgr.currentSelection) == null ? void 0 : _a.previouslySelectedElements;
      if (selectionAll === void 0) {
        return s.EmptySelection;
      }
      const selectedComps = [...selectionAll].filter((e) => e instanceof ComponentBase);
      if (selectedComps.length === 0) {
        return s.EmptySelection;
      }
      const checkResult = this.checkComponentsForCustomDef(selectedComps);
      if (isString(checkResult)) {
        return checkResult;
      }
      const componentsToInclude = checkResult.components;
      let caption;
      const labels = componentsToInclude.filter((e) => e instanceof Label);
      if (labels.length !== 1) {
        caption = window.prompt(s.EnterCaptionPrompt);
        if (caption === null) {
          return "";
        }
      } else {
        caption = labels[0].text;
      }
      const id = makeCustomIdFromCaption(caption);
      if (this._customComponents.has(id)) {
        return s.ComponentAlreadyExists.expand({ id });
      }
      const { components, wires } = Serialization.buildComponentsAndWireObject(componentsToInclude, [], void 0);
      if (components === void 0 || wires === void 0) {
        return s.NoWires;
      }
      const customDef = new CustomComponentDef({
        id,
        caption,
        circuit: { components, wires }
      });
      const maker = this.tryAddCustomDef(customDef, false);
      if (maker === void 0) {
        return "";
      }
      const customComp = maker.make(editor);
      customComp.setSpawned();
      customComp.setPosition(editor.mouseX + customComp.unrotatedWidth / 2 - 5, editor.mouseY, true);
      editor.eventMgr.currentSelection = void 0;
      editor.eventMgr.setCurrentMouseOverComp(customComp);
      for (const comp of componentsToInclude) {
        editor.components.tryDelete(comp);
      }
      return customDef;
    }
    tryMakeNewTestCase(editor) {
      var _a;
      const checkResult = this.checkSelectionForTestCase(editor);
      if (isString(checkResult)) {
        return checkResult;
      }
      const { inputs, outputs } = checkResult;
      return (_a = this.makeTestCaseWithCurrentValues(editor, inputs, outputs, true)) != null ? _a : "";
    }
    makeTestCaseWithCurrentValues(editor, inputs, outputs, askName) {
      var _a, _b;
      const joiner = "\n \u2022 ";
      const inReprBuf = [];
      const outReprBuf = [];
      const mkDesc = /* @__PURE__ */ __name((reprBuf) => (inOut) => {
        var _a2;
        const repr = binaryStringRepr(inOut.value);
        reprBuf.push(repr);
        return `${(_a2 = inOut.ref) != null ? _a2 : "?"}${isString(inOut.name) ? ` (\u201C${inOut.name}\u201D)` : ""}: ${repr}`;
      }, "mkDesc");
      const s = S.Messages;
      const inputsStr = s.TestCaseInputToSet.expand({ n: inputs.length }) + joiner + inputs.map(mkDesc(inReprBuf)).join(joiner);
      const outputsStr = s.TestCaseOuputToCheck.expand({ n: outputs.length }) + joiner + outputs.map(mkDesc(outReprBuf)).join(joiner);
      const prompt2 = s.NewTestCaseTitle + `

${inputsStr}

${outputsStr}

` + s.NewTestCaseSetName;
      let testCaseName = inReprBuf.join(" ") + " \u2192 " + outReprBuf.join(" ");
      if (askName) {
        testCaseName = window.prompt(prompt2, testCaseName);
        if (testCaseName === null) {
          return void 0;
        }
      }
      const inMap = /* @__PURE__ */ Object.create(null);
      for (const input2 of inputs) {
        inMap[(_a = input2.ref) != null ? _a : "?"] = valuesReprForTest(input2.value);
      }
      const outMap = /* @__PURE__ */ Object.create(null);
      for (const output of outputs) {
        outMap[(_b = output.ref) != null ? _b : "?"] = valuesReprForTest(output.value);
      }
      return new TestCaseCombinational({
        in: inMap,
        out: outMap,
        name: testCaseName.length === 0 ? void 0 : testCaseName
      }, editor.components);
    }
    tryMakeAllTestCases(editor) {
      return __async(this, null, function* () {
        const checkResult = this.checkSelectionForTestCase(editor);
        if (isString(checkResult)) {
          return checkResult;
        }
        const { inputs, outputs } = checkResult;
        const s = S.Messages;
        const max3 = 6;
        const inputsByBit = [];
        let numInputs = 0;
        for (const input2 of inputs) {
          for (let i2 = 0; i2 < input2.numBits; i2++) {
            inputsByBit.push([input2, i2]);
          }
          numInputs += input2.numBits;
        }
        const setBit = /* @__PURE__ */ __name((i2, value) => {
          const [input2, bit] = inputsByBit[i2];
          const newValues = input2.value.slice();
          newValues[bit] = value;
          input2.setValue(newValues);
        }, "setBit");
        if (numInputs > max3) {
          return s.TooManyInputsForAutoTestCases.expand({ max: max3 });
        }
        const numCases = Math.pow(2, numInputs);
        if (!confirm(s.AutoTestCasesWarning.expand({ numInputs, numCases }))) {
          return "";
        }
        const result = yield editor.disableUIWhile(s.ComputingTestCases, (restoreAfter) => __async(this, null, function* () {
          for (const input2 of inputs) {
            restoreAfter.set(input2, input2.value);
          }
          const testCases = [];
          for (let i2 = 0; i2 < numCases; i2++) {
            for (let j = 0; j < numInputs; j++) {
              const value = (i2 & 1 << j) !== 0;
              setBit(j, value);
            }
            editor.recalcPropagateAndDrawIfNeeded(true);
            yield editor.waitForPropagation();
            testCases.push(this.makeTestCaseWithCurrentValues(editor, inputs, outputs, false));
          }
          return testCases;
        }));
        return result != null ? result : "";
      });
    }
    tryModifyCustomComponent(def, defRoot) {
      const s = S.Components.Custom.messages;
      const components = [...defRoot.components.all()];
      const checkResult = this.checkComponentsForCustomDef(components);
      if (isString(checkResult)) {
        return checkResult;
      }
      const newComponents = checkResult.components;
      const circuit = Serialization.buildComponentsAndWireObject(newComponents, [], void 0);
      if (circuit.components === void 0 || circuit.wires === void 0) {
        return "";
      }
      const newDef = new CustomComponentDef({
        id: def.customId,
        caption: def.caption,
        circuit: { components: circuit.components, wires: circuit.wires }
      });
      if (newDef.numInputs !== def.numInputs || newDef.numOutputs !== def.numOutputs) {
        if (!window.confirm(s.InputsOutputsChanged)) {
          return "";
        }
      }
      this.tryAddCustomDef(newDef, true);
      return void 0;
    }
    checkComponentsForCustomDef(components) {
      const s = S.Components.Custom.messages;
      const inputs = components.filter((e) => e instanceof Input);
      if (inputs.length === 0) {
        return s.NoInput;
      }
      const outputs = components.filter((e) => e instanceof Output);
      if (outputs.length === 0) {
        return s.NoOutput;
      }
      function checkNames(inOuts) {
        const names = /* @__PURE__ */ new Set();
        const missingNames = [];
        for (const inOut of inOuts) {
          const name2 = inOut.name;
          if (name2 === void 0) {
            missingNames.push(inOut);
          } else {
            if (!isString(name2) || names.has(name2)) {
              return false;
            }
            names.add(name2);
          }
        }
        for (const inOut of missingNames) {
          const prefix = inOut instanceof Input ? "In" : "Out";
          let i2 = 0, name2;
          do {
            name2 = `${prefix}${i2++}`;
          } while (names.has(name2));
          inOut.doSetName(name2);
          names.add(name2);
        }
        return true;
      }
      __name(checkNames, "checkNames");
      const namesValid = checkNames(inputs) && checkNames(outputs);
      if (!namesValid) {
        return s.InputsOutputsMustHaveNames;
      }
      const componentsToInclude = [...inputs, ...outputs];
      const queue = [];
      let comp;
      queue.push(...inputs);
      while ((comp = queue.shift()) !== void 0) {
        for (const node of comp.outputs._all) {
          for (const wire of node.outgoingWires) {
            const otherComp = wire.endNode.component;
            if (components.includes(otherComp) && !componentsToInclude.includes(otherComp)) {
              componentsToInclude.push(otherComp);
              queue.push(otherComp);
            }
          }
        }
      }
      queue.push(...outputs);
      const missingComponents = [];
      while ((comp = queue.shift()) !== void 0) {
        for (const node of comp.inputs._all) {
          const wire = node.incomingWire;
          if (wire !== null) {
            const otherComp = wire.startNode.component;
            if (!components.includes(otherComp)) {
              if (!missingComponents.includes(otherComp)) {
                missingComponents.push(otherComp);
              }
            } else {
              if (!componentsToInclude.includes(otherComp)) {
                componentsToInclude.push(otherComp);
                queue.push(otherComp);
              }
            }
          }
        }
      }
      if (missingComponents.length > 0) {
        const missingCompsStr = missingComponents.map((c) => c.toString()).join(", ");
        return s.MissingComponents.expand({ list: missingCompsStr });
      }
      const uselessComponents = components.filter(
        (c) => !componentsToInclude.includes(c) && (c.inputs._all.length !== 0 || c.outputs._all.length !== 0)
      );
      if (uselessComponents.length > 0) {
        const uselessCompsStr = uselessComponents.map((c) => c.toString()).join(", ");
        return s.UselessComponents.expand({ list: uselessCompsStr });
      }
      if (componentsToInclude.some((c) => c instanceof Clock)) {
        return s.CannotIncludeClock;
      }
      return { components: componentsToInclude, inputs, outputs };
    }
    checkSelectionForTestCase(editor) {
      var _a;
      const s = S.Components.Custom.messages;
      const selectionAll = (_a = editor.eventMgr.currentSelection) == null ? void 0 : _a.previouslySelectedElements;
      if (selectionAll === void 0) {
        return s.EmptySelection;
      }
      const components = [...selectionAll].filter((e) => e instanceof ComponentBase);
      if (components.length === 0) {
        return s.EmptySelection;
      }
      const inputs = components.filter((e) => e instanceof Input);
      if (inputs.length === 0) {
        return s.NoInput;
      }
      const outputs = components.filter((e) => e instanceof Output);
      if (outputs.length === 0) {
        return s.NoOutput;
      }
      return { inputs, outputs };
    }
  };
  __name(ComponentFactory, "ComponentFactory");
  function makeCustomIdFromCaption(caption) {
    return caption.trim().normalize("NFKD").toLowerCase().replace(/[^a-z0-9]+/g, "");
  }
  __name(makeCustomIdFromCaption, "makeCustomIdFromCaption");

  // simulator/src/ComponentMenu.ts
  var import_json56 = __toESM(require_dist());
  var withButton = "withButton";
  var ifShowOnly = "ifShowOnly";
  var componentsMenu = [{
    nameKey: "InputOutput",
    items: [
      InputDef.button({ bits: 1 }, "Input1"),
      OutputDef.button({ bits: 1 }, "Output1"),
      DisplayBarDef.button("DisplayBar", { compat: "out.bar", visible: withButton }),
      ClockDef.button("Clock"),
      InputDef.button({ bits: 4 }, ["InputN", "Input4"], { compat: "in.nibble" }),
      OutputDef.button({ bits: 4 }, ["OutputN", "Output4"], { compat: "out.nibble" }),
      DisplayDef.button({ bits: 4 }, ["DisplayN", "Display4"], { compat: "out.nibble-display" }),
      InputDef.button({ bits: 8 }, "Input8", { compat: "in.byte", visible: ifShowOnly }),
      OutputDef.button({ bits: 8 }, "Output8", { compat: "out.byte", visible: ifShowOnly }),
      DisplayDef.button({ bits: 8 }, "Display8", { compat: "out.byte-display", visible: ifShowOnly }),
      Display7SegDef.button("Display7Seg", { compat: "out.7seg", visible: withButton }),
      Display16SegDef.button("Display16Seg", { compat: "out.16seg", visible: withButton }),
      DisplayAsciiDef.button("DisplayAscii", { compat: "out.ascii", visible: withButton }),
      RandomDef.button({ bits: 1 }, "Random", { compat: "random", visible: withButton }),
      ShiftDisplayDef.button("ShiftDisplay", { compat: "out.shift-buffer", visible: withButton })
    ]
  }, {
    nameKey: "Gates",
    items: [
      Gate1Def.button({ type: "not" }, "not"),
      Gate1Def.button({ type: "buf" }, "buf", { visible: withButton }),
      TristateBufferDef.button({ bottom: false }, "tri", { compat: "tri", visible: withButton }),
      GateNDef.button({ type: "and", bits: 2 }, "and"),
      GateNDef.button({ type: "or", bits: 2 }, "or"),
      GateNDef.button({ type: "xor", bits: 2 }, "xor"),
      GateNDef.button({ type: "nand", bits: 2 }, "nand"),
      GateNDef.button({ type: "nor", bits: 2 }, "nor"),
      GateNDef.button({ type: "xnor", bits: 2 }, "xnor", { visible: withButton }),
      GateNDef.button({ type: "imply", bits: 2 }, "imply", { visible: withButton }),
      GateNDef.button({ type: "nimply", bits: 2 }, "nimply", { visible: withButton }),
      GateNDef.button({ type: "txa", bits: 2 }, ["transfer", "txa"], { visible: withButton }),
      GateNDef.button({ type: "and", bits: 3 }, "and3", { compat: "and3", visible: ifShowOnly }),
      GateNDef.button({ type: "or", bits: 3 }, "or3", { compat: "or3", visible: ifShowOnly }),
      GateNDef.button({ type: "xor", bits: 3 }, "xor3", { compat: "xor3", visible: ifShowOnly }),
      GateNDef.button({ type: "nand", bits: 3 }, "nand3", { compat: "nand3", visible: ifShowOnly }),
      GateNDef.button({ type: "nor", bits: 3 }, "nor3", { compat: "nor3", visible: ifShowOnly }),
      GateNDef.button({ type: "xnor", bits: 3 }, "xnor3", { compat: "xnor3", visible: ifShowOnly }),
      GateNDef.button({ type: "and", bits: 4 }, "and4", { compat: "and4", visible: ifShowOnly }),
      GateNDef.button({ type: "or", bits: 4 }, "or4", { compat: "or4", visible: ifShowOnly }),
      GateNDef.button({ type: "xor", bits: 4 }, "xor4", { compat: "xor4", visible: ifShowOnly }),
      GateNDef.button({ type: "nand", bits: 4 }, "nand4", { compat: "nand4", visible: ifShowOnly }),
      GateNDef.button({ type: "nor", bits: 4 }, "nor4", { compat: "nor4", visible: ifShowOnly }),
      GateNDef.button({ type: "xnor", bits: 4 }, "xnor4", { compat: "xnor4", visible: ifShowOnly }),
      ControlledInverterDef.button({ bits: 4, bottom: false }, "ControlledInverter", { compat: "switched-inverter", visible: withButton }),
      GateArrayDef.button({ type: "and", bits: 4 }, "GateArray", { compat: "quad-gate", visible: withButton }),
      TristateBufferArrayDef.button({ bits: 4, bottom: false }, "TristateBufferArray", { visible: withButton })
    ]
  }, {
    nameKey: "Layout",
    items: [
      LabelDef.button("Label"),
      RectangleDef.button("Rectangle", { compat: "label.rect" }),
      PassthroughDef.button({ bits: 1 }, "Passthrough1"),
      PassthroughDef.button({ bits: 4 }, "PassthroughN")
    ]
  }, {
    nameKey: "Components",
    items: [
      HalfAdderDef.button("HalfAdder"),
      AdderDef.button("Adder"),
      ComparatorDef.button("Comparator", { compat: "comparator", visible: withButton }),
      AdderArrayDef.button({ bits: 4 }, "AdderArray"),
      ALUDef.button({ bits: 4, ext: false }, "ALU"),
      MuxDef.button({ from: 4, to: 2, bottom: false }, "Mux"),
      MuxDef.button({ from: 8, to: 4, bottom: false }, "Mux", { visible: ifShowOnly }),
      DemuxDef.button({ from: 2, to: 4, bottom: false }, "Demux"),
      LatchSRDef.button("LatchSR"),
      FlipflopJKDef.button("FlipflopJK", { compat: "flipflop-jk", visible: withButton }),
      FlipflopTDef.button("FlipflopT", { compat: "flipflop-t", visible: withButton }),
      FlipflopDDef.button("FlipflopD", { compat: "flipflop-d" }),
      RegisterDef.button({ bits: 4, inc: false }, "Register", { compat: "register" }),
      ShiftRegisterDef.button({ bits: 4 }, "ShiftRegister", { compat: "shift-register" }),
      CounterDef.button({ bits: 4 }, "Counter"),
      RAMDef.button({ lines: 16, bits: 4 }, "RAM"),
      ROMDef.button({ lines: 16, bits: 4 }, "ROM", { visible: withButton }),
      DecoderDef.button({ bits: 2 }, "Decoder", { compat: "decoder" }),
      Decoder7SegDef.button("Decoder7Seg", { compat: "decoder-7seg" }),
      Decoder16SegDef.button("Decoder16Seg", { compat: "decoder-16seg", visible: withButton }),
      DecoderBCD4Def.button("DecoderBCD4", { compat: "decoder-bcd4", visible: withButton })
    ]
  }];
  var ComponentMenu = class {
    constructor(editor, parent) {
      this.editor = editor;
      this.parent = parent;
      var _a;
      const showOnly = editor.options.showOnly;
      this._htmlSections = [];
      this._restrictedToGateTypes = showOnly === void 0 ? void 0 : /* @__PURE__ */ new Set();
      const showOnlyBuf = showOnly === void 0 ? void 0 : [...showOnly];
      let lastSectionNonEmpty = false;
      for (const section of componentsMenu) {
        const { allButtons, buttonsShowWithMore, buttonsShowWithURLParam, accessibleGateTypes } = makeButtons(section, showOnlyBuf);
        const htmlSection = this.makeSection(section.nameKey, allButtons, buttonsShowWithMore, buttonsShowWithURLParam, showOnlyBuf, lastSectionNonEmpty);
        for (const type7 of accessibleGateTypes) {
          (_a = this._restrictedToGateTypes) == null ? void 0 : _a.add(type7);
        }
        if (htmlSection !== void 0) {
          this._htmlSections.push(htmlSection);
          lastSectionNonEmpty = true;
        }
      }
      if (showOnlyBuf !== void 0 && showOnlyBuf.filter((s) => !s.endsWith("*")).length > 0) {
        console.log(`ERROR Supposed to show unknown elems: ${showOnlyBuf.join("; ")}`);
      }
    }
    allFixedButtons() {
      return this._htmlSections.flatMap((s) => s.buttons);
    }
    allCustomButtons() {
      return this._customComponentSection === void 0 ? [] : this._customComponentSection.buttons;
    }
    allowGateType(type7) {
      var _a, _b;
      return (_b = (_a = this._restrictedToGateTypes) == null ? void 0 : _a.has(type7)) != null ? _b : true;
    }
    updateCustomComponentButtons(defs) {
      const oldSec = this._customComponentSection;
      if (oldSec !== void 0) {
        if (oldSec.header !== void 0) {
          oldSec.header.remove();
        }
        if (oldSec.separator !== void 0) {
          oldSec.separator.remove();
        }
        for (const button2 of oldSec.buttons) {
          button2.remove();
        }
        if (oldSec.showMoreLink !== void 0) {
          oldSec.showMoreLink.remove();
        }
      }
      this._customComponentSection = defs === void 0 ? void 0 : this.makeCustomComponentSection(defs);
    }
    setCustomComponentsHidden(ids) {
      const section = this._customComponentSection;
      if (section === void 0) {
        return;
      }
      let anyVisible = false;
      for (const button2 of section.buttons) {
        const show = !ids.includes(button2.dataset.type);
        anyVisible || (anyVisible = show);
        setVisible(button2, show);
      }
      setVisible(section.header, anyVisible);
      if (section.separator !== void 0) {
        setVisible(section.separator, anyVisible);
      }
    }
    makeCustomComponentSection(defs) {
      const showOnly = this.editor.options.showOnly;
      const showOnlyBuf = showOnly === void 0 ? void 0 : [...showOnly];
      const allButtons = [];
      const buttonsShowWithMore = [];
      for (const def of defs) {
        const type7 = def.type;
        const icon = makeSvgHolder(
          "svgimg",
          "custom",
          def.makeButtonSVG(),
          CustomComponentImageWidth,
          CustomComponentImageHeight
        );
        const caption = def.caption;
        const { compButton, hiddenNow } = makeButton(
          type7,
          false,
          [type7],
          showOnlyBuf,
          icon,
          caption,
          caption + S.Components.Custom.MenuButtonSuffix,
          void 0,
          true
        );
        if (hiddenNow) {
          buttonsShowWithMore.push(compButton);
        }
        allButtons.push(compButton);
      }
      const makeSeparator = this._htmlSections.length > 0;
      return this.makeSection("Custom", allButtons, buttonsShowWithMore, [], showOnlyBuf, makeSeparator);
    }
    makeSection(nameKey, allButtons, buttonsShowWithMore, buttonsShowWithURLParam, showOnlyBuf, makeSeparator) {
      const numShowWithMoreButton = buttonsShowWithMore.length;
      const numAdded = allButtons.length;
      const numVisible = numAdded - numShowWithMoreButton - buttonsShowWithURLParam.length;
      if (numVisible === 0) {
        return void 0;
      }
      let separator = void 0;
      if (makeSeparator) {
        separator = div(
          style("height: 20px"),
          raw("&nbsp;")
        ).render();
        this.parent.appendChild(separator);
      }
      const header = div(
        cls("leftToolbarHeader"),
        S.ComponentBar.SectionNames[nameKey]
      ).render();
      this.parent.appendChild(header);
      for (const compButton of allButtons) {
        this.parent.appendChild(compButton);
      }
      let showMoreLink = void 0;
      if (numShowWithMoreButton !== 0 && showOnlyBuf === void 0) {
        let moreShown = false;
        const names = [S.ComponentBar.Labels.More + " \u2193", S.ComponentBar.Labels.Less + " \u2191"];
        showMoreLink = a(cls("leftToolbarMore"), names[0]).render();
        showMoreLink.addEventListener("click", () => {
          moreShown = !moreShown;
          for (const button2 of buttonsShowWithMore) {
            if (moreShown) {
              button2.style.removeProperty("padding");
              button2.style.removeProperty("border");
              button2.style.removeProperty("margin-bottom");
              button2.style.removeProperty("max-height");
              button2.style.removeProperty("overflow");
            } else {
              button2.style.padding = "0";
              button2.style.border = "0";
              button2.style.marginBottom = "0";
              button2.style.maxHeight = "0";
              button2.style.overflow = "hidden";
            }
          }
          showMoreLink.innerHTML = names[Number(moreShown)];
        });
        this.parent.appendChild(showMoreLink);
      }
      return { separator, header, buttons: allButtons, showMoreLink };
    }
  };
  __name(ComponentMenu, "ComponentMenu");
  function makeButtons(section, showOnlyBuf) {
    var _a, _b, _c;
    const allButtons = [];
    const buttonsShowWithMore = [];
    const buttonsShowWithURLParam = [];
    const accessibleGateTypes = /* @__PURE__ */ new Set();
    for (const item of section.items) {
      const normallyHidden = item.visible !== void 0 && item.visible !== "always";
      const [stringsKey, img2] = isString(item.visual) ? [item.visual, item.visual] : item.visual;
      const compStrings = S.ComponentBar.Components.props[stringsKey];
      const [titleStr, captionStr] = isString(compStrings) ? [compStrings, void 0] : compStrings;
      const { compButton, hiddenByShowOnly, hiddenNow } = makeButton(
        item.type,
        normallyHidden,
        componentIdsFor(item),
        showOnlyBuf,
        makeImage(img2, item.width),
        captionStr,
        titleStr,
        (_a = item.params) == null ? void 0 : _a.params,
        false
      );
      if (hiddenNow) {
        const targetArray = item.visible === "withButton" ? buttonsShowWithMore : buttonsShowWithURLParam;
        targetArray.push(compButton);
      }
      allButtons.push(compButton);
      const isGate = item.type.startsWith(GateTypePrefix);
      let gateType;
      if (isGate && !hiddenByShowOnly && (gateType = (_c = (_b = item.params) == null ? void 0 : _b.params) == null ? void 0 : _c.type) !== void 0) {
        accessibleGateTypes.add(gateType);
      }
    }
    return { allButtons, buttonsShowWithMore, buttonsShowWithURLParam, accessibleGateTypes };
  }
  __name(makeButtons, "makeButtons");
  function makeButton(typeStr, normallyHidden, componentIds, showOnlyBuf, buttonIcon, captionStr, titleStr, params, isCustom) {
    const hiddenByShowOnly = showOnlyBuf !== void 0 ? !shouldShow(componentIds, showOnlyBuf) : false;
    const hiddenNow = showOnlyBuf !== void 0 ? hiddenByShowOnly : normallyHidden;
    const buttonStyle = !hiddenNow ? "" : "max-height: 0; transition: all 0.25s ease-out; overflow: hidden; padding: 0; border: 0; margin-bottom: 0;";
    const extraClasses = hiddenNow ? " sim-component-button-extra" : "";
    const customClasses = isCustom ? " sim-component-button-custom" : "";
    const caption = captionStr === void 0 ? emptyMod : span(cls("barLabel"), captionStr);
    const buttonTitle = title(titleStr === void 0 ? "" : titleStr + ` 
(\u201C${componentIds[0]}\u201D)`);
    const compButton = button(
      type("button"),
      style(buttonStyle),
      cls(`list-group-item list-group-item-action sim-component-button${extraClasses}${customClasses}`),
      buttonIcon,
      caption,
      buttonTitle
    ).render();
    const compDataset = compButton.dataset;
    compDataset.type = typeStr;
    compDataset.componentId = componentIds[0];
    if (params !== void 0) {
      compDataset.params = import_json56.default.stringify(params);
    }
    return { compButton, hiddenByShowOnly, hiddenNow };
  }
  __name(makeButton, "makeButton");
  function shouldShow(componentIds, showOnly) {
    let visible = false;
    for (const componentId of componentIds) {
      for (const showOnlySpec of showOnly) {
        const [isMatch, isWildcard] = matchesSpec(showOnlySpec, componentId);
        if (isMatch) {
          visible = true;
          if (!isWildcard) {
            const ind = showOnly.indexOf(componentId);
            showOnly.splice(ind, 1);
          }
          break;
        }
      }
    }
    return visible;
    function matchesSpec(showOnlySpec, componentId) {
      if (showOnlySpec === componentId) {
        return [true, false];
      }
      if (showOnlySpec.endsWith("*") && componentId.startsWith(showOnlySpec.slice(0, -1))) {
        return [true, true];
      }
      return [false, false];
    }
    __name(matchesSpec, "matchesSpec");
  }
  __name(shouldShow, "shouldShow");
  function componentIdsFor(item) {
    const ids = [];
    const defAndParams = item.params;
    const type7 = item.type;
    if (defAndParams === void 0) {
      ids.push(type7);
    } else {
      const def = defAndParams.def;
      const variants = def.variantName(defAndParams.params);
      if (isArray(variants)) {
        ids.push(...variants);
      } else {
        if (deepObjectEquals(defAndParams.params, def.defaultParams)) {
          ids.push(type7);
        } else {
        }
        ids.push(variants);
      }
    }
    if (item.compat !== void 0) {
      ids.push(item.compat);
    }
    return ids;
  }
  __name(componentIdsFor, "componentIdsFor");

  // simulator/src/MessageBar.ts
  var MessageBar = class {
    constructor(editor) {
      this._currentTimeout = void 0;
      this.msgBox = div(cls("msgBar")).render();
      this.root = div(
        cls("msgZone"),
        this.msgBox
      ).render();
      editor.html.mainCanvas.insertAdjacentElement("afterend", this.root);
      this.hideNow = this.hideNow.bind(this);
    }
    hideNow() {
      this._currentTimeout = void 0;
      this.root.classList.remove("visible");
    }
    /**
     * @param duration If 0, the message will not disappear automatically (unless replaced by another auto-hiding message)
     */
    showMessage(msg, duration) {
      if (this._currentTimeout !== void 0) {
        clearTimeout(this._currentTimeout);
        this._currentTimeout = void 0;
      }
      this.msgBox.innerHTML = "";
      applyModifierTo(this.msgBox, msg);
      this.root.classList.add("visible");
      if (duration > 0) {
        this._currentTimeout = setTimeout(this.hideNow, duration);
      }
      return this.hideNow;
    }
  };
  __name(MessageBar, "MessageBar");

  // simulator/src/MoveManager.ts
  var MoveManager = class {
    constructor(editor) {
      this._movingDrawables = /* @__PURE__ */ new Set();
      this.editor = editor;
    }
    areDrawablesMoving() {
      return this._movingDrawables.size > 0;
    }
    getSingleMovingWaypoint() {
      if (this._movingDrawables.size === 1) {
        const drawable = this._movingDrawables.values().next().value;
        if (drawable instanceof Waypoint) {
          return drawable;
        }
      }
      return void 0;
    }
    getSingleMovingComponentWithAnchors() {
      if (this._movingDrawables.size === 1) {
        const drawable = this._movingDrawables.values().next().value;
        if (drawable instanceof DrawableWithPosition && drawable.anchor !== void 0 || drawable instanceof ComponentBase && drawable.anchoredDrawables.length !== 0) {
          return drawable;
        }
      }
      return void 0;
    }
    setDrawableMoving(comp, e) {
      this.changeMovingDrawables(() => {
        this._movingDrawables.add(comp);
      }, e);
    }
    setDrawableStoppedMoving(comp, e) {
      this.changeMovingDrawables(() => {
        this._movingDrawables.delete(comp);
      }, e);
    }
    changeMovingDrawables(change, e) {
      const emptyBefore = this._movingDrawables.size === 0;
      change();
      const emptyAfter = this._movingDrawables.size === 0;
      if (emptyBefore !== emptyAfter) {
        this.editor.updateCursor(e);
        this.editor.editTools.redrawMgr.requestRedraw({ why: "started or stopped moving drawables", invalidateMask: true });
      }
    }
    clear() {
      this._movingDrawables.clear();
    }
    dump() {
      var _a, _b;
      const num = this._movingDrawables.size;
      if (num === 0) {
        console.log("No moving drawables");
      } else {
        console.log(`There are ${num} moving drawables:`);
        for (const drawable of this._movingDrawables) {
          const className = drawable.constructor.name;
          if (drawable instanceof ComponentBase) {
            console.log(className + " - " + ((_b = (_a = drawable.outputs._all[0]) == null ? void 0 : _a.id) != null ? _b : "?"));
          } else {
            console.log(className);
          }
        }
      }
    }
  };
  __name(MoveManager, "MoveManager");

  // simulator/src/Tests.ts
  var Tests = class {
    aluOps() {
      function* nibbles() {
        for (const a2 of [false, true]) {
          for (const b2 of [false, true]) {
            for (const c of [false, true]) {
              for (const d of [false, true]) {
                yield [a2, b2, c, d];
              }
            }
          }
        }
      }
      __name(nibbles, "nibbles");
      function representationsOf(v) {
        const [str, uint_] = displayValuesFromArray(v, true);
        const uint = uint_;
        const sint = uint < 8 ? uint : uint - 16;
        return [str, uint, sint];
      }
      __name(representationsOf, "representationsOf");
      let totalTests = 0;
      let failedTests = 0;
      const verbose = false;
      for (const a2 of nibbles()) {
        for (const b2 of nibbles()) {
          for (const cin of [false, true]) {
            const [a_str, a_uint, a_sint] = representationsOf(a2);
            const [b_str, b_uint, b_sint] = representationsOf(b2);
            a2.reverse();
            b2.reverse();
            const { s: sum, v: v_sum, cout: c_sum } = doALUAdd(a2, b2, cin);
            const { s: diff, v: v_diff, cout: c_diff } = doALUSub(a2, b2, cin);
            a2.reverse();
            b2.reverse();
            sum.reverse();
            diff.reverse();
            const [sum_str, sum_uint, sum_sint] = representationsOf(sum);
            const [diff_str, diff_uint, diff_sint] = representationsOf(diff);
            const should_sum_uint = a_uint + b_uint + Number(cin);
            const should_c_sum = should_sum_uint > 15;
            let carryError = false;
            if (should_c_sum) {
              carryError = sum_uint === should_sum_uint || c_sum !== true;
            } else {
              carryError = sum_uint !== should_sum_uint || c_sum !== false;
            }
            if (carryError) {
              console.log(`ERROR carry - ${a_uint} (${a_str}) + ${b_uint} (${b_str}) + ${Number(cin)} = ${sum_uint} (${sum_str}) (c=${c_sum})`);
              failedTests++;
            } else if (verbose) {
              console.log(`carry - ${a_uint} (${a_str}) + ${b_uint} (${b_str}) + ${Number(cin)} = ${sum_uint} (${sum_str}) (c=${c_sum})`);
            }
            totalTests++;
            const should_diff_uint = a_uint - b_uint - Number(cin);
            let borrowError = false;
            if (a_uint - Number(cin) < b_uint) {
              borrowError = diff_uint === should_diff_uint || c_diff !== true;
            } else {
              borrowError = diff_uint !== should_diff_uint || c_diff !== false;
            }
            if (borrowError) {
              console.log(`ERROR borrow - ${a_uint} (${a_str}) - ${b_uint} (${b_str}) - ${Number(cin)} = ${diff_uint} (${diff_str}) (c=${c_diff})`);
              failedTests++;
            } else if (verbose) {
              console.log(`borrow - ${a_uint} (${a_str}) - ${b_uint} (${b_str}) - ${Number(cin)} = ${diff_uint} (${diff_str}) (c=${c_diff})`);
            }
            totalTests++;
            const should_sum_sint = a_sint + b_sint + Number(cin);
            const should_v_sum = should_sum_sint > 7 || should_sum_sint < -8;
            let overflowError = false;
            if (should_v_sum) {
              overflowError = sum_sint === should_sum_sint || v_sum !== true;
            } else {
              overflowError = sum_sint !== should_sum_sint || v_sum !== false;
            }
            if (overflowError) {
              console.log(`ERROR overflow - ${a_sint} (${a_str}) + ${b_sint} (${b_str}) + ${Number(cin)} = ${sum_sint} (${sum_str}) (v=${v_sum})`);
              failedTests++;
            } else if (verbose) {
              console.log(`overflow - ${a_sint} (${a_str}) + ${b_sint} (${b_str}) + ${Number(cin)} = ${sum_sint} (${sum_str}) (v=${v_sum})`);
            }
            totalTests++;
            const should_diff_sint = a_sint - b_sint - Number(cin);
            const should_v_diff = should_diff_sint > 7 || should_diff_sint < -8;
            let overflowError2 = false;
            if (should_v_diff) {
              overflowError2 = diff_sint === should_diff_sint || v_diff !== true;
            } else {
              overflowError2 = diff_sint !== should_diff_sint || v_diff !== false;
            }
            if (overflowError2) {
              console.log(`ERROR overflow - ${a_sint} (${a_str}) - ${b_sint} (${b_str}) - ${Number(cin)} = ${diff_sint} (${diff_str}) (v=${v_diff})`);
              failedTests++;
            } else if (verbose) {
              console.log(`overflow - ${a_sint} (${a_str}) - ${b_sint} (${b_str}) - ${Number(cin)} = ${diff_sint} (${diff_str}) (v=${v_diff})`);
            }
            totalTests++;
          }
        }
      }
      console.log(`Tests: ${totalTests} total, ${failedTests} failed, ${totalTests - failedTests} passed`);
    }
  };
  __name(Tests, "Tests");

  // simulator/src/TestsPalette.ts
  var TestsPalette = class {
    constructor(editor) {
      this.editor = editor;
      this.testSuites = /* @__PURE__ */ new Map();
      this._isDisplayingResults = false;
      this._skipUpdates = false;
      const s = S.Tests;
      const testsTitleElem = div(cls("toolbar-title"), s.Title).render();
      editor.eventMgr.registerTitleDragListenersOn(testsTitleElem, () => {
        editor.setTestsPaletteVisible(false);
      });
      this.suiteContainer = div(cls("noselect"), style("width: 100%")).render();
      this.scroller = div(style("width: 100%; font-size: 80%; overflow-y: auto; min-height: 28px; resize: vertical"), this.suiteContainer).render();
      this.rootElem = div(
        cls("sim-toolbar-right"),
        style("display: none"),
        data("prev-display")("block"),
        testsTitleElem,
        this.scroller
      ).render();
    }
    updateMaxHeight() {
      const maxHeight = Math.min(this.suiteContainer.clientHeight, this.editor.html.mainCanvas.clientHeight - 38);
      this.scroller.style.maxHeight = maxHeight + "px";
    }
    setVisible(visible) {
      setVisible(this.rootElem, visible);
      if (visible) {
        this.updateMaxHeight();
      }
    }
    clearAllSuites() {
      this.suiteContainer.innerHTML = "";
      this.testSuites.clear();
    }
    update() {
      this.clearAllSuites();
      const parentSuites = this.editor.editorRoot.testSuites;
      for (const suite of parentSuites.suites) {
        this.addTestSuite(suite);
      }
      this.editor.didLoadTests(parentSuites);
    }
    addTestSuite(testSuite) {
      const numExisting = this.testSuites.size;
      const ui = new TestSuiteUI(this.editor, this, testSuite);
      ui.expanded = numExisting === 0;
      this.testSuites.set(testSuite, ui);
      this.suiteContainer.appendChild(ui.rootElem);
      return ui;
    }
    getOrMakeUIFor(testSuite) {
      var _a;
      return (_a = this.testSuites.get(testSuite)) != null ? _a : this.addTestSuite(testSuite);
    }
    setDisplayingResults() {
      this._isDisplayingResults = true;
    }
    clearDisplayedResults() {
      if (this._isDisplayingResults && !this._skipUpdates) {
        console.log("Clearing displayed results");
        this.update();
        this._isDisplayingResults = false;
      }
    }
    skipUpdatesWhile(f) {
      return __async(this, null, function* () {
        this._skipUpdates = true;
        try {
          return yield f();
        } finally {
          this._skipUpdates = false;
        }
      });
    }
    runAllTestSuites() {
      return __async(this, null, function* () {
        for (const testSuiteUI of this.testSuites.values()) {
          yield testSuiteUI.runTestCases();
        }
      });
    }
  };
  __name(TestsPalette, "TestsPalette");
  var TestSuiteUI = class {
    constructor(editor, palette, testSuite) {
      this.editor = editor;
      this.palette = palette;
      this.testSuite = testSuite;
      this._expanded = false;
      var _a;
      const s = S.Tests;
      this.htmlResults = testSuite.testCases.map((tc) => this.makeTestCaseUI(tc));
      const runAllIcon = makeIcon("play");
      style("position: relative; top: -2px;").applyTo(runAllIcon);
      this.runTestCasesButton = span(
        cls("sim-mode-link"),
        style("flex: none; font-size: 85%; opacity: 0.9; margin: -2px 0 -2px 4px; padding: 2px 4px 0 0;"),
        title(s.RunTestSuite),
        runAllIcon,
        s.Run
      ).render();
      this.runTestCasesButton.addEventListener("click", () => this.runTestCases());
      this.header = div(
        cls("test-suite test-disclosable expanded"),
        style("display: flex"),
        span(style("flex: auto"), (_a = testSuite.name) != null ? _a : s.DefaultTestSuiteName),
        this.runTestCasesButton
      ).render();
      this.content = div(cls("test-cases"), style("display: block"), ...this.htmlResults.map((p) => p.container)).render();
      this.header.addEventListener("click", (e) => {
        if (e.target === this.header) {
          this.expanded = !this.expanded;
        }
      });
      this.rootElem = div(this.header, this.content).render();
    }
    makeTestCaseUI(testCase) {
      var _a;
      const s = S.Tests;
      const editButton = span(
        cls("sim-mode-link testcase-change-button"),
        style("flex: none; font-size: 80%; opacity: 0.85; margin: -1px; padding: 1px"),
        title(s.EditTestCaseName),
        makeIcon("pen")
      ).render();
      const deleteButton = span(
        cls("sim-mode-link testcase-change-button"),
        style("flex: none; font-size: 80%; opacity: 0.85; margin: -1px; padding: 1px"),
        title(s.DeleteTestCase),
        makeIcon("trash")
      ).render();
      const nameSpan = span(style("flex: auto"), (_a = testCase.name) != null ? _a : s.DefaultTestCaseName).render();
      const line = div(
        cls("test-disclosable testcase-button"),
        nameSpan,
        editButton,
        deleteButton
      ).render();
      const details = div(cls("testcase-details"), style("display: none"), this.makeTestCaseDetailsTable(testCase)).render();
      const toggle = /* @__PURE__ */ __name((force) => {
        const expanded = line.classList.toggle("expanded", force);
        setVisible(details, expanded);
        this.palette.updateMaxHeight();
      }, "toggle");
      line.addEventListener("click", () => {
        toggle();
      });
      const container = div(cls("testcase wait"), line, details).render();
      editButton.addEventListener("click", (e) => {
        var _a2;
        e.stopPropagation();
        if (!UIPermissions.canModifyTestCases(this.editor)) {
          window.alert(S.Messages.NoPermission);
          return;
        }
        const newName = window.prompt(s.EnterNewTestCaseName, (_a2 = testCase.name) != null ? _a2 : "");
        if (newName === null || newName.length === 0) {
          return;
        }
        testCase.name = newName;
        nameSpan.textContent = newName;
      });
      deleteButton.addEventListener("click", (e) => {
        if (!UIPermissions.canModifyTestCases(this.editor)) {
          window.alert(S.Messages.NoPermission);
          return;
        }
        this.editor.removeTestCase(testCase);
        e.stopPropagation();
      });
      return { line, details, container, toggle };
    }
    get expanded() {
      return this._expanded;
    }
    set expanded(expanded) {
      this._expanded = this.header.classList.toggle("expanded", expanded);
      setVisible(this.content, this._expanded);
      this.palette.updateMaxHeight();
    }
    runTestCases() {
      return __async(this, null, function* () {
        const oldExpanded = this.expanded;
        setHidden(this.runTestCasesButton, true);
        try {
          const testResult = yield this.editor.runTestSuite(this.testSuite, { fast: true });
          if (testResult !== void 0 && testResult.isAllPass()) {
            this.expanded = oldExpanded;
          }
        } finally {
          setHidden(this.runTestCasesButton, false);
        }
      });
    }
    setRunning(i2) {
      if (!this._expanded) {
        this.expanded = true;
      }
      const htmlResult = this.htmlResults[i2];
      htmlResult.container.className = "testcase running";
      htmlResult.toggle(true);
    }
    setResult(i2, result) {
      const htmlResult = this.htmlResults[i2];
      if (result._tag === "fail") {
        htmlResult.details.innerHTML = "";
        htmlResult.details.appendChild(this.makeTestCaseDetailsTable(this.testSuite.testCases[i2], result));
      } else {
        htmlResult.toggle();
      }
      htmlResult.container.className = "testcase " + result._tag;
      this.palette.setDisplayingResults();
    }
    makeComponentRefSpan(elem) {
      var _a;
      const compStr = isString(elem) ? elem : isString(elem.name) ? elem.name : (_a = elem.ref) != null ? _a : "?";
      const link = a(compStr, href("#")).render();
      link.addEventListener("click", () => {
        this.editor.highlight(elem);
      });
      return link;
    }
    makeTestCaseDetailsTable(testCase, failed) {
      const s = S.Tests;
      const tableBody = tbody().render();
      const ins = [...testCase.in];
      const outs = [...testCase.out];
      for (let i2 = 0; i2 < Math.max(ins.length, outs.length); i2++) {
        const inStr = i2 >= ins.length ? "" : mods(this.makeComponentRefSpan(ins[i2][0]), `: ${ins[i2][1]}`);
        let outStr = "";
        if (i2 < outs.length) {
          const [output, expectedRepr] = outs[i2];
          let outValue = String(expectedRepr);
          if (failed !== void 0) {
            const mismatch = failed.mismatches.find((m) => m.output === output);
            if (mismatch !== void 0) {
              outValue = mods(span(cls("testcase-wrongvalue"), `${reprForLogicValues(mismatch.actual, false)}`), ` \u2260 ${outValue}`);
            }
          }
          outStr = mods(this.makeComponentRefSpan(output), `: `, outValue);
        }
        tr(td(inStr), td(outStr)).applyTo(tableBody);
      }
      const setTheseInputsButton = span(
        cls("sim-mode-link"),
        style("margin: 2px; padding: 3px"),
        title(s.SetTheseInputs),
        makeIcon("setinput")
      ).render();
      setTheseInputsButton.addEventListener("click", () => __async(this, null, function* () {
        testCase.tryFixReferences(this.editor.components);
        this.palette.skipUpdatesWhile(() => __async(this, null, function* () {
          this.editor.trySetInputsAndRecalc(testCase.in);
          yield this.editor.waitForPropagation();
        }));
      }));
      return table(
        cls("testcase-table"),
        thead(tr(th(s.SetInputs, setTheseInputsButton), th(s.WantedOutputs))),
        tableBody
      ).render();
    }
  };
  __name(TestSuiteUI, "TestSuiteUI");

  // simulator/src/Timeline.ts
  function areStatesEqual(s1, s2) {
    return s1.hasCallbacks === s2.hasCallbacks && s1.enablesPause === s2.enablesPause && s1.isPaused === s2.isPaused && s1.enablesPause === s2.enablesPause && s1.nextStepDesc === s2.nextStepDesc;
  }
  __name(areStatesEqual, "areStatesEqual");
  var Timeline = class {
    constructor(editor) {
      // public callback function
      this.onStateChanged = /* @__PURE__ */ __name((__) => null, "onStateChanged");
      this.editor = editor;
      this.reset();
    }
    reset() {
      this._epochStart = this.unadjustedTime();
      this._sortedNextCallbackTimes = [];
      this._schedule = {};
      this._numCallbacksEnablingPause = 0;
      if (this._nextTimeout !== void 0) {
        clearTimeout(this._nextTimeout.handle);
        this._nextTimeout = void 0;
      }
      this._fixedLogicalTime = void 0;
      this._pausedSince = void 0;
    }
    get isPaused() {
      return this._pausedSince !== void 0;
    }
    get nextTickDesc() {
      var _a;
      if (this._sortedNextCallbackTimes.length === 0) {
        return void 0;
      }
      const nextTime = this._sortedNextCallbackTimes[0];
      const nextCallbacks = this._schedule[nextTime];
      if (nextCallbacks.length === 1) {
        return nextCallbacks[0].desc;
      }
      const counts = /* @__PURE__ */ new Map();
      for (const c of nextCallbacks) {
        counts.set(c.desc, ((_a = counts.get(c.desc)) != null ? _a : 0) + 1);
      }
      return [...counts.entries()].map(([desc, count]) => `${count} \xD7 ${desc}`).join("\n");
    }
    get state() {
      const hasCallbacks = this._sortedNextCallbackTimes.length > 0;
      const enablesPause = this._numCallbacksEnablingPause > 0;
      const isPaused = this.isPaused;
      const canStep = isPaused && hasCallbacks;
      const nextStepDesc = !canStep ? void 0 : this.nextTickDesc;
      return { hasCallbacks, enablesPause, isPaused, nextStepDesc };
    }
    unadjustedTime() {
      return (/* @__PURE__ */ new Date()).getTime();
    }
    logicalTime() {
      if (this._fixedLogicalTime !== void 0) {
        return this._fixedLogicalTime;
      }
      if (this._pausedSince !== void 0) {
        return this._pausedSince - this._epochStart;
      }
      return this.unadjustedTime() - this._epochStart;
    }
    hasPendingCallbacksNow() {
      return this._sortedNextCallbackTimes.length > 0 && this._sortedNextCallbackTimes[0] <= this.logicalTime();
    }
    scheduleAt(time, callback, desc, enablesPause) {
      const callbackRec = { callback, desc, enablesPause };
      this._numCallbacksEnablingPause += enablesPause ? 1 : 0;
      if (time in this._schedule) {
        this._schedule[time].push(callbackRec);
      } else {
        if (time < this.logicalTime()) {
          console.log(`WARNING Scheduling this in the past (${time - this.logicalTime()} ms), may behave strangely: ` + desc);
        }
        let i2 = 0;
        do {
          if (i2 >= this._sortedNextCallbackTimes.length) {
            this._sortedNextCallbackTimes.push(time);
            break;
          }
          if (time < this._sortedNextCallbackTimes[i2]) {
            this._sortedNextCallbackTimes.splice(i2, 0, time);
            break;
          }
          i2++;
        } while (true);
        this._schedule[time] = [callbackRec];
        if (i2 === 0) {
          this.rescheduleNextIfNeeded();
        }
      }
      this.fireStateChangedIfNeeded();
    }
    rescheduleNextIfNeeded() {
      if (this._sortedNextCallbackTimes.length === 0) {
        if (this._nextTimeout !== void 0) {
          clearTimeout(this._nextTimeout.handle);
          this._nextTimeout = void 0;
        }
      } else {
        const tickTime = this._sortedNextCallbackTimes[0];
        if (this._nextTimeout !== void 0) {
          if (this._nextTimeout.tickTime <= tickTime) {
            return;
          } else {
            clearTimeout(this._nextTimeout.handle);
            this._nextTimeout = void 0;
          }
        }
        const now = this.logicalTime();
        const waitDuration = tickTime - now;
        const handle = setTimeout(() => this.nextTickCallback(), waitDuration);
        this._nextTimeout = { handle, tickTime };
      }
    }
    nextTickCallback() {
      this._nextTimeout = void 0;
      if (this._pausedSince !== void 0) {
        return;
      }
      this.handleNextTick();
    }
    handleNextTick() {
      const wantedTime = this._sortedNextCallbackTimes.shift();
      if (wantedTime === void 0) {
        return;
      }
      const now = this.logicalTime();
      const callbacks = this._schedule[wantedTime];
      const late = now - wantedTime;
      if (late > 100) {
        this._epochStart += late;
      }
      const runAllCallbacks = /* @__PURE__ */ __name(() => {
        let elem;
        this._fixedLogicalTime = wantedTime;
        while ((elem = callbacks.shift()) !== void 0) {
          const { callback, desc, enablesPause } = elem;
          this._numCallbacksEnablingPause -= enablesPause ? 1 : 0;
          try {
            callback();
          } catch (err) {
            console.log(`ERROR running callback '${desc}': ` + err);
          }
        }
        this._fixedLogicalTime = void 0;
      }, "runAllCallbacks");
      this.editor.wrapHandler(runAllCallbacks)();
      delete this._schedule[wantedTime];
      this.rescheduleNextIfNeeded();
      this.fireStateChangedIfNeeded();
    }
    pause() {
      if (this._pausedSince !== void 0) {
        return;
      }
      if (this._nextTimeout !== void 0) {
        clearTimeout(this._nextTimeout.handle);
        this._nextTimeout = void 0;
      }
      this._pausedSince = this.unadjustedTime();
      this.fireStateChangedIfNeeded();
    }
    play() {
      if (this._pausedSince === void 0) {
        return;
      }
      this._epochStart += this.unadjustedTime() - this._pausedSince;
      this._pausedSince = void 0;
      this.editor.editTools.redrawMgr.requestRedraw({ why: "timeline-play", invalidateTests: true });
      this.rescheduleNextIfNeeded();
      this.fireStateChangedIfNeeded();
    }
    step() {
      if (this._pausedSince === void 0 || this._sortedNextCallbackTimes.length === 0) {
        return;
      }
      const nextTickTime = this._sortedNextCallbackTimes[0];
      const currentPauseTime = this.logicalTime();
      this._epochStart -= nextTickTime - currentPauseTime;
      this.handleNextTick();
      this.fireStateChangedIfNeeded();
    }
    fireStateChangedIfNeeded() {
      const newState = this.state;
      if (this._lastSentState === void 0 || !areStatesEqual(this._lastSentState, newState)) {
        this.onStateChanged(newState);
        this._lastSentState = newState;
      }
    }
  };
  __name(Timeline, "Timeline");

  // simulator/src/TopBar.ts
  var TopBar = class {
    constructor(editor) {
      this.editor = editor;
      this._showingCompactUI = false;
      this._showingCircuitName = false;
      this._customComponentShown = void 0;
      this._showingTimelineUI = false;
      const s = S.TopBar;
      this.alwaysShowCircuitName = editor.isSingleton;
      this.dirtyIndicator = this.makeLabel(mods(style("margin: 3px 3px 0 -2px; font-size: 20pt"), "\u2022", title(s.DirtyTooltip)));
      this.circuitNameLabel = this.makeLink(mods("", title(s.CircuitNameTooltip)), this.runSetCircuitNameDialog.bind(this));
      this.mainCircuitTab = this.makeTab(
        this.circuitNameLabel
      );
      this.customComponentChevron = this.makeLabel("\u276F");
      this.customComponentChevron.style.fontSize = "14pt";
      this.customComponentNameLabel = this.makeLink(mods("", title(s.CustomComponentCaptionTooltip)), this.runSetCustomComponentCaptionDialog.bind(this));
      this.customComponentNameLabel.style.fontWeight = "bolder";
      this.closeCustomComponentButton = this.makeButton("close", s.CloseCircuit, () => editor.tryCloseCustomComponentEditor());
      this.closeCustomComponentButton.style.padding = "0";
      this.customComponentTab = this.makeTab(
        this.closeCustomComponentButton,
        this.customComponentNameLabel
      );
      this.circuitNameGroup = div(
        cls("path"),
        style("flex: none; display: flex; align-items: stretch; margin: -3px 0 -3px -5px; padding: 3px 5px"),
        this.dirtyIndicator,
        this.mainCircuitTab,
        this.customComponentChevron,
        this.customComponentTab
      ).render();
      this.undoButton = this.makeButtonWithLabel(
        "undo",
        s.Undo,
        () => this.editor.editTools.undoMgr.undo()
      );
      this.redoButton = this.makeButtonWithLabel(
        "redo",
        s.Redo,
        () => this.editor.editTools.undoMgr.redoOrRepeat()
      );
      this.resetButton = this.makeButtonWithLabel(
        "reset",
        s.Reset,
        () => this.editor.resetCircuit()
      );
      this.openButton = this.makeButtonWithLabel(
        "open",
        s.Open,
        this.openHandler.bind(this)
      );
      this.downloadButton = this.makeButtonWithLabel(
        "download",
        s.Download,
        this.saveHandler.bind(this)
      );
      this.screenshotButton = this.makeButtonWithLabel(
        "screenshot",
        s.Screenshot,
        this.screenshotHandler.bind(this)
      );
      this.timelineButtonSep = this.makeSep();
      this.pauseButton = this.makeButtonWithLabel(
        "pause",
        s.TimelinePause,
        () => this.editor.timeline.pause()
      );
      this.playButton = this.makeButtonWithLabel(
        "play",
        s.TimelinePlay,
        () => this.editor.timeline.play()
      );
      this.stepButton = this.makeButtonWithLabel(
        "step",
        s.TimelineStep,
        () => this.editor.timeline.step()
      );
      this.timeLabel = this.makeLabel(s.TimeLabel + "0");
      this.timeLabel.style.fontSize = "8pt";
      this.designButton = this.makeButtonWithLabel(
        "mouse",
        s.Design,
        () => this.editor.setCurrentMouseAction("edit")
      );
      this.deleteButton = this.makeButtonWithLabel(
        "trash",
        s.Delete,
        () => this.editor.setCurrentMouseAction("delete")
      );
      this.testsButton = this.makeButtonWithLabel(
        "check",
        s.Tests,
        () => this.editor.setTestsPaletteVisible(!this.testsButton.classList.contains("active"))
      );
      this.flexibleSep = div(style("flex: auto")).render();
      this.moveButton = this.makeButton(
        "move",
        s.Move[1],
        () => this.editor.setCurrentMouseAction("move")
      );
      this.zoomLevelInput = input(
        type("number"),
        style("margin: 0 2px 0 0; width: 4em; background-color: inherit;"),
        attr("min", "0"),
        attr("step", "10"),
        attr("value", String(editor.options.zoom)),
        attr("title", S.Settings.zoomLevel)
      ).render();
      this.zoomLevelInput.addEventListener(
        "change",
        editor.wrapHandler(this.zoomLevelHandler.bind(this))
      );
      const zoomControl = this.makeLabel(mods(
        this.zoomLevelInput,
        S.Settings.zoomLevelField[1]
      ));
      this.root = div(
        cls("topBar"),
        style("flex:none; height: 30px; padding: 3px 5px; display: flex; align-items: stretch;"),
        this.circuitNameGroup,
        this.undoButton,
        this.redoButton,
        this.makeSep(),
        this.resetButton,
        this.makeSep(),
        this.openButton,
        this.downloadButton,
        this.screenshotButton,
        this.timelineButtonSep,
        this.pauseButton,
        this.playButton,
        this.stepButton,
        this.timeLabel,
        this.makeSep(true),
        this.designButton,
        this.deleteButton,
        this.makeSep(),
        this.testsButton,
        this.flexibleSep,
        this.moveButton,
        zoomControl
      ).render();
      editor.html.centerCol.insertAdjacentElement("afterbegin", this.root);
      const undoMgr = editor.editTools.undoMgr;
      undoMgr.onStateChanged = (newState) => this.setUndoButtonsEnabled(newState);
      this.setUndoButtonsEnabled(undoMgr.state);
      editor.timeline.onStateChanged = (newState) => this.setTimelineButtonsVisible(newState);
      this.setTimelineButtonsVisible(editor.timeline.state);
      this.setDirty(false);
      window.addEventListener("resize", this.updateCompactMode.bind(this));
      this.setEditingCustomComponent(void 0);
      this.setCircuitName(editor.documentDisplayName);
      this.updateCompactMode();
    }
    // Handlers
    runSetCircuitNameDialog() {
      var _a;
      const currentValue = (_a = this.editor.options.name) != null ? _a : "";
      const newName = window.prompt(S.TopBar.SetCircuitName, currentValue);
      if (newName === null || newName === currentValue) {
        return;
      }
      this.editor.setCircuitName(newName);
      this.editor.editTools.undoMgr.takeSnapshot();
    }
    runSetCustomComponentCaptionDialog() {
      if (this._customComponentShown === void 0) {
        return;
      }
      this.editor.factory.runChangeCustomComponentCaptionDialog(this._customComponentShown);
    }
    openHandler() {
      this.editor.runFileChooser("text/plain|image/png|application/json|application/json5", (file) => {
        this.editor.tryLoadFrom(file);
      });
    }
    saveHandler(e) {
      if (e.altKey && this.editor.factory.hasCustomComponents()) {
        Serialization.saveLibraryToFile(this.editor);
      } else {
        Serialization.saveCircuitToFile(this.editor);
      }
    }
    screenshotHandler(e) {
      const editor = this.editor;
      if (e.altKey) {
        editor.download(editor.toSVG(true), ".svg");
      } else {
        editor.download(editor.toPNG(true), ".png");
      }
    }
    zoomLevelHandler() {
      const zoom = this.zoomLevelInput.valueAsNumber;
      this.editor.setZoomLevel(zoom);
    }
    // Visibility methods
    updateCompactMode() {
      const getSepWidth = /* @__PURE__ */ __name(() => this.flexibleSep.getBoundingClientRect().width, "getSepWidth");
      const MinSepWidth = 5;
      const sepWidth = getSepWidth();
      if (!this._showingCompactUI) {
        if (sepWidth <= MinSepWidth) {
          this._showingCompactUI = true;
          this.root.classList.add("compact");
        }
      } else {
        if (sepWidth > MinSepWidth) {
          this.root.classList.remove("compact");
          if (getSepWidth() <= MinSepWidth) {
            this.root.classList.add("compact");
          } else {
            this._showingCompactUI = false;
          }
        }
      }
    }
    getActiveTabCoords() {
      const tab = this._customComponentShown !== void 0 ? this.customComponentTab : this.mainCircuitTab;
      const rect = tab.getBoundingClientRect();
      return [rect.left, rect.right];
    }
    setButtonStateFromMode(state, mode) {
      setDisplay(this.root, state.showComponentsAndEditControls);
      setVisible(this.resetButton, state.showReset);
      const showUndoRedo = mode >= 2 /* CONNECT */;
      setVisible(this.undoButton, showUndoRedo);
      setVisible(this.redoButton, showUndoRedo);
      const showToolButtons = state.showComponentsAndEditControls === "show";
      setVisible(this.designButton, showToolButtons);
      setVisible(this.deleteButton, showToolButtons);
      setVisible(this.moveButton, showToolButtons);
      this.updateCompactMode();
    }
    setCircuitName(name2) {
      let show = true;
      if (name2 !== void 0) {
        this.circuitNameLabel.textContent = name2;
      } else {
        if (this.alwaysShowCircuitName) {
          this.circuitNameLabel.textContent = this.editor.documentDisplayName;
        } else {
          show = false;
          this.circuitNameLabel.textContent = "";
        }
      }
      this._showingCircuitName = show;
      setVisible(this.circuitNameLabel, show);
      setVisible(this.dirtyIndicator, show);
      this.updateCircuitNameUI();
    }
    updateCircuitNameUI() {
      setVisible(this.circuitNameGroup, this._showingCircuitName || this._customComponentShown !== void 0);
      this.updateCompactMode();
    }
    setZoomLevel(zoom) {
      this.zoomLevelInput.value = String(zoom);
    }
    setDirty(dirty) {
      this.dirtyIndicator.style.visibility = dirty ? "inherit" : "hidden";
      setEnabled(this.resetButton, dirty);
    }
    setEditingCustomComponent(customDef) {
      const showSubcircuitUI = customDef !== void 0;
      setVisible(this.customComponentChevron, showSubcircuitUI);
      setVisible(this.customComponentTab, showSubcircuitUI);
      setActive(this.mainCircuitTab, !showSubcircuitUI);
      setActive(this.customComponentTab, showSubcircuitUI);
      if (showSubcircuitUI) {
        this.circuitNameLabel.style.removeProperty("font-weight");
        this.customComponentNameLabel.textContent = customDef.caption;
      } else {
        this.circuitNameLabel.style.fontWeight = "bolder";
        this.customComponentNameLabel.textContent = "";
      }
      this._customComponentShown = customDef;
      this.updateCircuitNameUI();
    }
    updateCustomComponentCaption() {
      if (this._customComponentShown !== void 0) {
        this.customComponentNameLabel.textContent = this._customComponentShown.caption;
        this.updateCompactMode();
      }
    }
    setTimelineButtonsVisible({ enablesPause, hasCallbacks, isPaused, nextStepDesc }) {
      const showTimelineUI = enablesPause || this.editor.options.allowPausePropagation && hasCallbacks;
      this._showingTimelineUI = showTimelineUI;
      if (showTimelineUI) {
        setVisible(this.timelineButtonSep, true);
        setVisible(this.playButton, isPaused);
        setVisible(this.pauseButton, !isPaused);
        setVisible(this.stepButton, nextStepDesc !== void 0);
        this.stepButton.title = S.TopBar.TimelineStep[1] + "\n" + (nextStepDesc != null ? nextStepDesc : "");
        setVisible(this.timeLabel, isPaused);
        this.updateTimeLabelIfNeeded();
      } else {
        setVisible(this.timelineButtonSep, false);
        setVisible(this.playButton, false);
        setVisible(this.pauseButton, false);
        setVisible(this.stepButton, false);
        setVisible(this.timeLabel, false);
      }
      this.updateCompactMode();
    }
    setUndoButtonsEnabled({ canUndo, canRedoOrRepeat }) {
      setEnabled(this.undoButton, canUndo);
      setEnabled(this.redoButton, canRedoOrRepeat);
    }
    updateTimeLabelIfNeeded() {
      if (!this._showingTimelineUI) {
        return;
      }
      const t38 = this.editor.timeline.logicalTime();
      const ms = t38 % 1e3;
      const s = Math.floor(t38 / 1e3) % 60;
      const m = Math.floor(t38 / 6e4) % 60;
      const h = Math.floor(t38 / 36e5);
      this.timeLabel.textContent = S.TopBar.TimeLabel + (h === 0 ? "" : h + ":") + (m < 10 ? "0" + m : m) + ":" + (s < 10 ? "0" + s : s) + "." + (ms < 100 ? ms < 10 ? "00" : "0" : "") + ms;
    }
    updateActiveTool(tool) {
      setActive(this.designButton, tool === "edit");
      setActive(this.deleteButton, tool === "delete");
      setActive(this.moveButton, tool === "move");
    }
    updateTestPaletteVisible(visible) {
      this.testsButton.classList.toggle("active", visible);
    }
    setTestPaletteButtonVisible(numHint) {
      const visible = numHint !== 0;
      if (visible) {
        const newCaption = numHint > 0 ? S.TopBar.Tests[0] + ` (${numHint})` : S.TopBar.Tests[0];
        this.setCaption(this.testsButton, newCaption);
      }
      setVisible(this.testsButton, visible);
    }
    // Factory methods
    makeTab(...modifiers) {
      return div(cls("barTab"), ...modifiers).render();
    }
    makeButtonWithLabel(icon, labelTooltip, handler) {
      return this.makeButton(icon, labelTooltip[1], handler, labelTooltip[0]);
    }
    makeButton(icon, tooltip, handler, label2) {
      const labelSpan = label2 === void 0 ? emptyMod : span(cls("btnLabel"), label2);
      const but = button(
        i(cls("svgicon"), raw(inlineIconSvgFor(icon))),
        title(tooltip),
        labelSpan
      ).render();
      but.addEventListener("click", this.editor.wrapHandler(handler));
      return but;
    }
    makeLabel(label2) {
      return span(cls("barLabel"), label2).render();
    }
    makeLink(label2, handler) {
      const link = a(cls("barLabel"), label2).render();
      link.addEventListener("click", this.editor.wrapHandler(handler));
      return link;
    }
    makeSep(fat = false) {
      const classes = fat ? "sep fat" : "sep";
      return div(cls(classes)).render();
    }
    setCaption(button2, caption) {
      const label2 = button2.querySelector(".btnLabel");
      if (label2 !== null) {
        label2.textContent = caption;
      }
    }
  };
  __name(TopBar, "TopBar");

  // node_modules/@popperjs/core/lib/enums.js
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  // node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }
  __name(getNodeName, "getNodeName");

  // node_modules/@popperjs/core/lib/dom-utils/getWindow.js
  function getWindow(node) {
    if (node == null) {
      return window;
    }
    if (node.toString() !== "[object Window]") {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
  }
  __name(getWindow, "getWindow");

  // node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  __name(isElement, "isElement");
  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }
  __name(isHTMLElement, "isHTMLElement");
  function isShadowRoot(node) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }
  __name(isShadowRoot, "isShadowRoot");

  // node_modules/@popperjs/core/lib/modifiers/applyStyles.js
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name2) {
      var style2 = state.styles[name2] || {};
      var attributes = state.attributes[name2] || {};
      var element = state.elements[name2];
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(name3) {
        var value = attributes[name3];
        if (value === false) {
          element.removeAttribute(name3);
        } else {
          element.setAttribute(name3, value === true ? "" : value);
        }
      });
    });
  }
  __name(applyStyles, "applyStyles");
  function effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name2) {
        var element = state.elements[name2];
        var attributes = state.attributes[name2] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name2) ? state.styles[name2] : initialStyles[name2]);
        var style2 = styleProperties.reduce(function(style3, property) {
          style3[property] = "";
          return style3;
        }, {});
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style2);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  __name(effect, "effect");
  var applyStyles_default = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect,
    requires: ["computeStyles"]
  };

  // node_modules/@popperjs/core/lib/utils/getBasePlacement.js
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }
  __name(getBasePlacement, "getBasePlacement");

  // node_modules/@popperjs/core/lib/utils/math.js
  var max2 = Math.max;
  var min2 = Math.min;
  var round = Math.round;

  // node_modules/@popperjs/core/lib/utils/userAgent.js
  function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
      return uaData.brands.map(function(item) {
        return item.brand + "/" + item.version;
      }).join(" ");
    }
    return navigator.userAgent;
  }
  __name(getUAString, "getUAString");

  // node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }
  __name(isLayoutViewport, "isLayoutViewport");

  // node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && isHTMLElement(element)) {
      scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
    }
    var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width = clientRect.width / scaleX;
    var height = clientRect.height / scaleY;
    return {
      width,
      height,
      top: y,
      right: x + width,
      bottom: y + height,
      left: x,
      x,
      y
    };
  }
  __name(getBoundingClientRect, "getBoundingClientRect");

  // node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element);
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }
    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width,
      height
    };
  }
  __name(getLayoutRect, "getLayoutRect");

  // node_modules/@popperjs/core/lib/dom-utils/contains.js
  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;
      do {
        if (next && parent.isSameNode(next)) {
          return true;
        }
        next = next.parentNode || next.host;
      } while (next);
    }
    return false;
  }
  __name(contains, "contains");

  // node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
  function getComputedStyle2(element) {
    return getWindow(element).getComputedStyle(element);
  }
  __name(getComputedStyle2, "getComputedStyle");

  // node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }
  __name(isTableElement, "isTableElement");

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : (
      // $FlowFixMe[prop-missing]
      element.document
    )) || window.document).documentElement;
  }
  __name(getDocumentElement, "getDocumentElement");

  // node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || // DOM Element detected
      (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element)
    );
  }
  __name(getParentNode, "getParentNode");

  // node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle2(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  __name(getTrueOffsetParent, "getTrueOffsetParent");
  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());
    if (isIE && isHTMLElement(element)) {
      var elementCss = getComputedStyle2(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle2(currentNode);
      if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  __name(getContainingBlock, "getContainingBlock");
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }
  __name(getOffsetParent, "getOffsetParent");

  // node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }
  __name(getMainAxisFromPlacement, "getMainAxisFromPlacement");

  // node_modules/@popperjs/core/lib/utils/within.js
  function within(min3, value, max3) {
    return max2(min3, min2(value, max3));
  }
  __name(within, "within");
  function withinMaxClamp(min3, value, max3) {
    var v = within(min3, value, max3);
    return v > max3 ? max3 : v;
  }
  __name(withinMaxClamp, "withinMaxClamp");

  // node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  __name(getFreshSideObject, "getFreshSideObject");

  // node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }
  __name(mergePaddingObject, "mergePaddingObject");

  // node_modules/@popperjs/core/lib/utils/expandToHashMap.js
  function expandToHashMap(value, keys) {
    return keys.reduce(function(hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }
  __name(expandToHashMap, "expandToHashMap");

  // node_modules/@popperjs/core/lib/modifiers/arrow.js
  var toPaddingObject = /* @__PURE__ */ __name(function toPaddingObject2(padding, state) {
    padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  }, "toPaddingObject");
  function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name2 = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
      return;
    }
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min3 = paddingObject[minProp];
    var max3 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset2 = within(min3, center, max3);
    var axisProp = axis;
    state.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
  }
  __name(arrow, "arrow");
  function effect2(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      return;
    }
    state.elements.arrow = arrowElement;
  }
  __name(effect2, "effect");
  var arrow_default = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect2,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };

  // node_modules/@popperjs/core/lib/utils/getVariation.js
  function getVariation(placement) {
    return placement.split("-")[1];
  }
  __name(getVariation, "getVariation");

  // node_modules/@popperjs/core/lib/modifiers/computeStyles.js
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref, win) {
    var x = _ref.x, y = _ref.y;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x * dpr) / dpr || 0,
      y: round(y * dpr) / dpr || 0
    };
  }
  __name(roundOffsetsByDPR, "roundOffsetsByDPR");
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
      x,
      y
    }) : {
      x,
      y
    };
    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2)) {
        offsetParent = getDocumentElement(popper2);
        if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          offsetParent[heightProp]
        );
        y -= offsetY - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          offsetParent[widthProp]
        );
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x,
      y
    }, getWindow(popper2)) : {
      x,
      y
    };
    x = _ref4.x;
    y = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  __name(mapToStyles, "mapToStyles");
  function computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration,
      isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  __name(computeStyles, "computeStyles");
  var computeStyles_default = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };

  // node_modules/@popperjs/core/lib/modifiers/eventListeners.js
  var passive = {
    passive: true
  };
  function effect3(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance.update, passive);
      }
    };
  }
  __name(effect3, "effect");
  var eventListeners_default = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: /* @__PURE__ */ __name(function fn() {
    }, "fn"),
    effect: effect3,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
  var hash = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash[matched];
    });
  }
  __name(getOppositePlacement, "getOppositePlacement");

  // node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
  var hash2 = {
    start: "end",
    end: "start"
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash2[matched];
    });
  }
  __name(getOppositeVariationPlacement, "getOppositeVariationPlacement");

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }
  __name(getWindowScroll, "getWindowScroll");

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }
  __name(getWindowScrollBarX, "getWindowScrollBarX");

  // node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
  function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      var layoutViewport = isLayoutViewport();
      if (layoutViewport || !layoutViewport && strategy === "fixed") {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x + getWindowScrollBarX(element),
      y
    };
  }
  __name(getViewportRect, "getViewportRect");

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max2(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max2(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;
    if (getComputedStyle2(body || html).direction === "rtl") {
      x += max2(html.clientWidth, body ? body.clientWidth : 0) - width;
    }
    return {
      width,
      height,
      x,
      y
    };
  }
  __name(getDocumentRect, "getDocumentRect");

  // node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }
  __name(isScrollParent, "isScrollParent");

  // node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
  function getScrollParent2(node) {
    if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
      return node.ownerDocument.body;
    }
    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }
    return getScrollParent2(getParentNode(node));
  }
  __name(getScrollParent2, "getScrollParent");

  // node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent2(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target2 = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target2);
    return isBody ? updatedList : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target2)))
    );
  }
  __name(listScrollParents, "listScrollParents");

  // node_modules/@popperjs/core/lib/utils/rectToClientRect.js
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }
  __name(rectToClientRect, "rectToClientRect");

  // node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, false, strategy === "fixed");
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  __name(getInnerBoundingClientRect, "getInnerBoundingClientRect");
  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  __name(getClientRectFromMixedType, "getClientRectFromMixedType");
  function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
      return [];
    }
    return clippingParents2.filter(function(clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
  }
  __name(getClippingParents, "getClippingParents");
  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      accRect.top = max2(rect.top, accRect.top);
      accRect.right = min2(rect.right, accRect.right);
      accRect.bottom = min2(rect.bottom, accRect.bottom);
      accRect.left = max2(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }
  __name(getClippingRect, "getClippingRect");

  // node_modules/@popperjs/core/lib/utils/computeOffsets.js
  function computeOffsets(_ref) {
    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference2.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
          break;
        default:
      }
    }
    return offsets;
  }
  __name(computeOffsets, "computeOffsets");

  // node_modules/@popperjs/core/lib/utils/detectOverflow.js
  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset2 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset2[axis] * multiply;
      });
    }
    return overflowOffsets;
  }
  __name(detectOverflow, "detectOverflow");

  // node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements2.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements2;
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a2, b2) {
      return overflows[a2] - overflows[b2];
    });
  }
  __name(computeAutoPlacement, "computeAutoPlacement");

  // node_modules/@popperjs/core/lib/modifiers/flip.js
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  __name(getExpandedFallbackPlacements, "getExpandedFallbackPlacements");
  function flip(_ref) {
    var state = _ref.state, options = _ref.options, name2 = _ref.name;
    if (state.modifiersData[name2]._skip) {
      return;
    }
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements2[0];
    for (var i2 = 0; i2 < placements2.length; i2++) {
      var placement = placements2[i2];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = /* @__PURE__ */ __name(function _loop2(_i2) {
        var fittingPlacement = placements2.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i2).every(function(check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      }, "_loop");
      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break")
          break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name2]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  __name(flip, "flip");
  var flip_default = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };

  // node_modules/@popperjs/core/lib/modifiers/hide.js
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  __name(getSideOffsets, "getSideOffsets");
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  __name(isAnySideFullyClipped, "isAnySideFullyClipped");
  function hide(_ref) {
    var state = _ref.state, name2 = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name2] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  __name(hide, "hide");
  var hide_default = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
  };

  // node_modules/@popperjs/core/lib/modifiers/offset.js
  function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
      placement
    })) : offset2, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  __name(distanceAndSkiddingToXY, "distanceAndSkiddingToXY");
  function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name2 = _ref2.name;
    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data2 = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
      return acc;
    }, {});
    var _data$state$placement = data2[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name2] = data2;
  }
  __name(offset, "offset");
  var offset_default = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };

  // node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
  function popperOffsets(_ref) {
    var state = _ref.state, name2 = _ref.name;
    state.modifiersData[name2] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  __name(popperOffsets, "popperOffsets");
  var popperOffsets_default = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getAltAxis.js
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  __name(getAltAxis, "getAltAxis");

  // node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
  function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name2 = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary,
      rootBoundary,
      padding,
      altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data2 = {
      x: 0,
      y: 0
    };
    if (!popperOffsets2) {
      return;
    }
    if (checkMainAxis) {
      var _offsetModifierState$;
      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset2 = popperOffsets2[mainAxis];
      var min3 = offset2 + overflow[mainSide];
      var max3 = offset2 - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset2 + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min2(min3, tetherMin) : min3, offset2, tether ? max2(max3, tetherMax) : max3);
      popperOffsets2[mainAxis] = preventedOffset;
      data2[mainAxis] = preventedOffset - offset2;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2;
      var _mainSide = mainAxis === "x" ? top : left;
      var _altSide = mainAxis === "x" ? bottom : right;
      var _offset = popperOffsets2[altAxis];
      var _len = altAxis === "y" ? "height" : "width";
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets2[altAxis] = _preventedOffset;
      data2[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name2] = data2;
  }
  __name(preventOverflow, "preventOverflow");
  var preventOverflow_default = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
  };

  // node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  __name(getHTMLElementScroll, "getHTMLElementScroll");

  // node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }
  __name(getNodeScroll, "getNodeScroll");

  // node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  __name(isElementScaled, "isElementScaled");
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }
  __name(getCompositeRect, "getCompositeRect");

  // node_modules/@popperjs/core/lib/utils/orderModifiers.js
  function order(modifiers) {
    var map = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
      map.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    __name(sort, "sort");
    modifiers.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  __name(order, "order");
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }
  __name(orderModifiers, "orderModifiers");

  // node_modules/@popperjs/core/lib/utils/debounce.js
  function debounce(fn2) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve(fn2());
          });
        });
      }
      return pending;
    };
  }
  __name(debounce, "debounce");

  // node_modules/@popperjs/core/lib/utils/mergeByName.js
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }
  __name(mergeByName, "mergeByName");

  // node_modules/@popperjs/core/lib/createPopper.js
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  __name(areValidElements, "areValidElements");
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return /* @__PURE__ */ __name(function createPopper2(reference2, popper2, options) {
      if (options === void 0) {
        options = defaultOptions;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state,
        setOptions: /* @__PURE__ */ __name(function setOptions(setOptionsAction) {
          var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions, state.options, options2);
          state.scrollParents = {
            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m) {
            return m.enabled;
          });
          runModifierEffects();
          return instance.update();
        }, "setOptions"),
        // Sync update  it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: /* @__PURE__ */ __name(function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
          if (!areValidElements(reference3, popper3)) {
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper3)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          for (var index = 0; index < state.orderedModifiers.length; index++) {
            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
            if (typeof fn2 === "function") {
              state = fn2({
                state,
                options: _options,
                name: name2,
                instance
              }) || state;
            }
          }
        }, "forceUpdate"),
        // Async and optimistically optimized update  it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce(function() {
          return new Promise(function(resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: /* @__PURE__ */ __name(function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }, "destroy")
      };
      if (!areValidElements(reference2, popper2)) {
        return instance;
      }
      instance.setOptions(options).then(function(state2) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref) {
          var name2 = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref.effect;
          if (typeof effect4 === "function") {
            var cleanupFn = effect4({
              state,
              name: name2,
              instance,
              options: options2
            });
            var noopFn = /* @__PURE__ */ __name(function noopFn2() {
            }, "noopFn");
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      __name(runModifierEffects, "runModifierEffects");
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn2) {
          return fn2();
        });
        effectCleanupFns = [];
      }
      __name(cleanupModifierEffects, "cleanupModifierEffects");
      return instance;
    }, "createPopper");
  }
  __name(popperGenerator, "popperGenerator");

  // node_modules/@popperjs/core/lib/popper.js
  var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
  var createPopper = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });

  // simulator/src/UIEventManager.ts
  function setDragStartData(e, dragStartX, dragStartY) {
    const _e = e;
    _e.dragStartX = dragStartX;
    _e.dragStartY = dragStartY;
  }
  __name(setDragStartData, "setDragStartData");
  var EditorSelection = class {
    constructor(currentlyDrawnRect) {
      this.currentlyDrawnRect = currentlyDrawnRect;
      /**
       * The elements that are selected, independently of the potential
       * rectangle that is currently drawn
       */
      this.previouslySelectedElements = /* @__PURE__ */ new Set();
    }
    toggle(elem) {
      if (this.previouslySelectedElements.has(elem)) {
        this.previouslySelectedElements.delete(elem);
      } else {
        this.previouslySelectedElements.add(elem);
      }
    }
    finishCurrentRect(editor) {
      let rect;
      if ((rect = this.currentlyDrawnRect) !== void 0) {
        for (const comp of editor.components.all()) {
          if (comp.isInRect(rect)) {
            this.toggle(comp);
          }
        }
        for (const wire of editor.linkMgr.wires) {
          for (const point of wire.waypoints) {
            if (point.isInRect(rect)) {
              this.toggle(point);
            }
          }
        }
        this.currentlyDrawnRect = void 0;
      }
    }
    isSelected(component) {
      const prevSelected = this.previouslySelectedElements.has(component);
      const rect = this.currentlyDrawnRect;
      if (rect === void 0) {
        return prevSelected;
      } else {
        const inverted = component.isInRect(rect);
        return inverted ? !prevSelected : prevSelected;
      }
    }
  };
  __name(EditorSelection, "EditorSelection");
  var UIEventManager = class {
    constructor(editor) {
      this._currentMouseOverComp = null;
      this._currentMouseOverPopper = null;
      this._currentMouseDownData = null;
      this._startHoverTimeoutHandle = null;
      this._startDragTimeoutHandle = null;
      this._lastTouchEnd = void 0;
      this.currentSelection = void 0;
      this.editor = editor;
      this._currentAction = "edit";
      this._currentHandlers = new EditHandlers(editor);
    }
    get currentMouseOverComp() {
      return this._currentMouseOverComp;
    }
    get currentMouseDownData() {
      return this._currentMouseDownData;
    }
    setHandlersFor(action, ...params) {
      if (action === this._currentAction) {
        return false;
      }
      this._currentAction = action;
      const newHandlers = (() => {
        switch (action) {
          case "delete":
            return new DeleteHandlers(this.editor);
          case "move":
            return new MoveHandlers(this.editor);
          case "setanchor":
            return new SetAnchorHandlers(this.editor, ...params);
          case "edit":
          default:
            return new EditHandlers(this.editor);
        }
      })();
      this._currentHandlers.unmount();
      this._currentHandlers = newHandlers;
      setColorMouseOverIsDanger(action === "delete");
      return true;
    }
    setStartDragTimeout(startMouseDownData, e) {
      const _e = e;
      _e._savedOffsetX = _e.offsetX;
      _e._savedOffsetY = _e.offsetY;
      _e._savedTarget = _e.target;
      this._startDragTimeoutHandle = setTimeout(
        this.editor.wrapHandler(() => {
          let fireDrag = true;
          const endMouseDownData = this._currentMouseDownData;
          if (endMouseDownData !== null) {
            endMouseDownData.fireMouseClickedOnFinish = false;
            if (endMouseDownData.triggeredContextMenu) {
              fireDrag = false;
            }
          }
          if (fireDrag) {
            const [dragStartX, dragStartY] = this.editor.offsetXY(e, true);
            setDragStartData(e, dragStartX, dragStartY);
            if (startMouseDownData.mainComp instanceof Drawable) {
              this._currentHandlers.mouseDraggedOn(startMouseDownData.mainComp, e);
            }
            for (const comp of startMouseDownData.selectionComps) {
              this._currentHandlers.mouseDraggedOn(comp, e);
            }
          }
        }),
        500
      );
    }
    clearStartDragTimeout() {
      if (this._startDragTimeoutHandle !== null) {
        clearTimeout(this._startDragTimeoutHandle);
        this._startDragTimeoutHandle = null;
      }
    }
    clearHoverTimeoutHandle() {
      if (this._startHoverTimeoutHandle !== null) {
        clearTimeout(this._startHoverTimeoutHandle);
        this._startHoverTimeoutHandle = null;
      }
    }
    setCurrentMouseOverComp(comp) {
      if (comp !== this._currentMouseOverComp) {
        this.clearPopperIfNecessary();
        this.clearHoverTimeoutHandle();
        this._currentMouseOverComp = comp;
        if (comp !== null) {
          this._startHoverTimeoutHandle = setTimeout(() => {
            this._currentHandlers.mouseHoverOn(comp);
            this._startHoverTimeoutHandle = null;
          }, 1200);
        }
        this.editor.editTools.redrawMgr.requestRedraw({ why: "mouseover changed" });
      }
    }
    currentSelectionEmpty() {
      return this.currentSelection === void 0 || this.currentSelection.previouslySelectedElements.size === 0;
    }
    updateMouseOver([x, y], pullingWire, settingAnchor) {
      const findMouseOver = /* @__PURE__ */ __name(() => {
        const prevMouseOver = this._currentMouseOverComp;
        if (prevMouseOver !== null && prevMouseOver.drawZIndex !== 0) {
          const rejectThis = prevMouseOver instanceof Wire || settingAnchor && !(prevMouseOver instanceof ComponentBase);
          if (!rejectThis && prevMouseOver.isOver(x, y)) {
            return this._currentMouseOverComp;
          }
        }
        const root = this.editor.editorRoot;
        if (!pullingWire) {
          for (const comp of root.components.withZIndex(DrawZIndex.Overlay)) {
            if (comp.isOver(x, y)) {
              return comp;
            }
          }
        }
        for (const comp of root.components.withZIndex(DrawZIndex.Normal)) {
          let nodeOver = null;
          if (!settingAnchor) {
            for (const node of comp.allNodes()) {
              if (node.isOver(x, y)) {
                nodeOver = node;
                break;
              }
            }
          }
          if (nodeOver !== null && (!pullingWire || root.linkMgr.isValidNodeToConnect(nodeOver))) {
            return nodeOver;
          }
          if (!pullingWire && comp.isOver(x, y)) {
            return comp;
          }
        }
        if (!pullingWire && !settingAnchor) {
          for (const wire of root.linkMgr.wires) {
            for (const waypoint of wire.waypoints) {
              if (waypoint.isOver(x, y)) {
                return waypoint;
              }
            }
            if (wire.isOver(x, y)) {
              return wire;
            }
          }
        }
        if (!pullingWire) {
          for (const comp of root.components.withZIndex(DrawZIndex.Background)) {
            if (comp.isOver(x, y)) {
              return comp;
            }
          }
        }
        return null;
      }, "findMouseOver");
      this.setCurrentMouseOverComp(findMouseOver());
    }
    selectAll() {
      const sel = new EditorSelection(void 0);
      this.currentSelection = sel;
      const root = this.editor.editorRoot;
      for (const comp of root.components.all()) {
        sel.previouslySelectedElements.add(comp);
      }
      for (const wire of root.linkMgr.wires) {
        for (const waypoint of wire.waypoints) {
          sel.previouslySelectedElements.add(waypoint);
        }
      }
      this.editor.editTools.redrawMgr.requestRedraw({ why: "selected all" });
    }
    toggleSelect(comp) {
      let sel;
      if ((sel = this.currentSelection) === void 0) {
        sel = new EditorSelection(void 0);
        this.currentSelection = sel;
      }
      sel.toggle(comp);
      this.editor.editTools.redrawMgr.requestRedraw({ why: "toggled selection" });
    }
    clearPopperIfNecessary() {
      if (this._currentMouseOverPopper !== null) {
        const [popper2, removeListener] = this._currentMouseOverPopper;
        removeListener();
        popper2.destroy();
        this._currentMouseOverPopper = null;
        this.editor.html.tooltipElem.style.display = "none";
      }
    }
    makePopper(tooltipHtml, rect) {
      const { tooltipContents, tooltipElem, mainCanvas } = this.editor.html;
      tooltipContents.innerHTML = "";
      tooltipHtml.applyTo(tooltipContents);
      tooltipElem.style.removeProperty("display");
      const popper2 = createPopper({
        getBoundingClientRect: rect,
        contextElement: mainCanvas
      }, tooltipElem, {
        placement: "right",
        modifiers: [{ name: "offset", options: { offset: [4, 8] } }]
      });
      const scrollParent = getScrollParent(mainCanvas);
      const scrollListener = /* @__PURE__ */ __name(() => popper2.update(), "scrollListener");
      scrollParent.addEventListener("scroll", scrollListener);
      const removeListener = /* @__PURE__ */ __name(() => scrollParent.removeEventListener("scroll", scrollListener), "removeListener");
      this._currentMouseOverPopper = [popper2, removeListener];
      tooltipElem.setAttribute("data-show", "");
      popper2.update();
    }
    registerCanvasListenersOn(canvas2) {
      const editor = this.editor;
      const returnFalse = /* @__PURE__ */ __name(() => false, "returnFalse");
      canvas2.ondragenter = returnFalse;
      canvas2.ondragover = returnFalse;
      canvas2.ondragend = returnFalse;
      canvas2.ondrop = (e) => {
        var _a;
        if (e.dataTransfer === null) {
          return false;
        }
        e.preventDefault();
        const file = (_a = e.dataTransfer.files) == null ? void 0 : _a[0];
        if (file !== void 0) {
          editor.tryLoadFrom(file);
        } else {
          const dataItems = e.dataTransfer.items;
          if (dataItems !== void 0) {
            for (const dataItem of dataItems) {
              if (dataItem.kind === "string" && (dataItem.type === "application/json" || dataItem.type === "application/json5" || dataItem.type === "text/plain")) {
                dataItem.getAsString((content) => {
                  e.dataTransfer.dropEffect = "copy";
                  editor.loadCircuitOrLibrary(content);
                });
                break;
              }
            }
          }
        }
        return false;
      };
      canvas2.addEventListener("touchstart", editor.wrapHandler((e) => {
        if (this.editor.mode >= 2 /* CONNECT */) {
          e.preventDefault();
        }
        this._mouseDownTouchStart(e);
      }));
      canvas2.addEventListener("touchmove", editor.wrapHandler((e) => {
        if (this.editor.mode >= 2 /* CONNECT */) {
          e.preventDefault();
        }
        this._mouseMoveTouchMove(e);
      }));
      canvas2.addEventListener("touchend", editor.wrapHandler((e) => {
        e.preventDefault();
        this._mouseUpTouchEnd(e);
        this.setCurrentMouseOverComp(null);
        this.editor.focus();
      }));
      canvas2.addEventListener("mousedown", editor.wrapHandler((e) => {
        this._mouseDownTouchStart(e);
      }));
      canvas2.addEventListener("mousemove", editor.wrapHandler((e) => {
        this._mouseMoveTouchMove(e);
        this.editor.updateCursor(e);
      }));
      canvas2.addEventListener("mouseleave", editor.wrapHandler(() => {
        this.clearPopperIfNecessary();
      }));
      canvas2.addEventListener("mouseup", editor.wrapHandler((e) => {
        this._mouseUpTouchEnd(e);
        this.updateMouseOver(this.editor.offsetXY(e), false, false);
        this.editor.updateCursor(e);
        this.editor.focus();
      }));
      canvas2.addEventListener("contextmenu", editor.wrapHandler((e) => {
        e.preventDefault();
        if (this.editor.mode >= 2 /* CONNECT */ && this._currentMouseOverComp !== null) {
          this._currentHandlers.contextMenuOn(this._currentMouseOverComp, e);
        }
      }));
      canvas2.addEventListener("keyup", editor.wrapHandler((e) => {
        var _a;
        if (targetIsFieldOrOtherInput(e)) {
          return;
        }
        switch (e.key) {
          case "Escape": {
            let handled;
            handled = editor.eventMgr.tryDeleteComponentsWhere((comp) => comp.state === 0 /* SPAWNING */, false) > 0;
            if (!handled) {
              handled = editor.linkMgr.tryCancelWireOrAnchor();
            }
            if (!handled && this.editor.editorRoot instanceof CustomComponent) {
              handled = this.editor.tryCloseCustomComponentEditor();
            }
            if (!handled) {
              handled = editor.setCurrentMouseAction("edit");
            }
            if (handled) {
              e.preventDefault();
            }
            return;
          }
          case "Backspace":
          case "Delete": {
            let selComp;
            if ((selComp = (_a = this.currentSelection) == null ? void 0 : _a.previouslySelectedElements) !== void 0 && selComp.size !== 0) {
              let anyDeleted = false;
              for (const comp of selComp) {
                anyDeleted = editor.eventMgr.tryDeleteDrawable(comp).isChange || anyDeleted;
              }
              if (anyDeleted) {
                editor.editTools.undoMgr.takeSnapshot();
              }
            } else if ((selComp = this.currentMouseOverComp) !== null) {
              const result = editor.eventMgr.tryDeleteDrawable(selComp);
              editor.editTools.undoMgr.takeSnapshot(result);
            }
            e.preventDefault();
            return;
          }
          case "e":
            editor.setCurrentMouseAction("edit");
            e.preventDefault();
            return;
          case "d":
            editor.setCurrentMouseAction("delete");
            e.preventDefault();
            return;
          case "m":
            editor.setCurrentMouseAction("move");
            e.preventDefault();
            return;
          case "t":
            if (editor.editorRoot.testSuites.totalCases() > 0) {
              editor.setTestsPaletteVisible(true);
              editor.editTools.testsPalette.runAllTestSuites();
              e.preventDefault();
              return;
            }
        }
      }));
      canvas2.addEventListener("keydown", editor.wrapHandler((e) => {
        const ctrlOrCommand = e.ctrlKey || e.metaKey;
        const keyLower = e.key.toLowerCase();
        const shift = e.shiftKey || keyLower !== e.key;
        switch (keyLower) {
          case "a":
            if (ctrlOrCommand && editor.mode >= 2 /* CONNECT */ && !targetIsFieldOrOtherInput(e)) {
              this.selectAll();
              e.preventDefault();
            }
            return;
          case "s":
            if (ctrlOrCommand && editor.isSingleton) {
              editor.saveCurrentStateToUrl();
              e.preventDefault();
            }
            return;
          case "z":
            if (ctrlOrCommand && !targetIsFieldOrOtherInput(e)) {
              if (shift) {
                editor.editTools.undoMgr.redoOrRepeat();
              } else {
                editor.editTools.undoMgr.undo();
              }
              e.preventDefault();
            }
            return;
          case "y":
            if (ctrlOrCommand && !targetIsFieldOrOtherInput(e)) {
              editor.editTools.undoMgr.redoOrRepeat();
              e.preventDefault();
            }
            return;
          case "x":
            if (ctrlOrCommand && !targetIsFieldOrOtherInput(e)) {
              editor.cut();
              e.preventDefault();
            }
            return;
          case "c":
            if (ctrlOrCommand && !targetIsFieldOrOtherInput(e)) {
              if (editor.copy()) {
                e.preventDefault();
              }
            }
            return;
          case "v":
            if (ctrlOrCommand && !targetIsFieldOrOtherInput(e)) {
              editor.paste();
              e.preventDefault();
            }
            return;
          case "g":
            if (ctrlOrCommand && editor.mode >= 2 /* CONNECT */) {
              editor.makeGroupWithSelection();
              e.preventDefault();
            }
            return;
          case "arrowright":
            if (this.moveSelection(ctrlOrCommand ? 1 : GRID_STEP / 2, 0, e.altKey)) {
              return;
            }
            break;
          case "arrowleft":
            if (this.moveSelection(ctrlOrCommand ? -1 : -GRID_STEP / 2, 0, e.altKey)) {
              return;
            }
            break;
          case "arrowdown":
            if (this.moveSelection(0, ctrlOrCommand ? 1 : GRID_STEP / 2, e.altKey)) {
              return;
            }
            break;
          case "arrowup":
            if (this.moveSelection(0, ctrlOrCommand ? -1 : -GRID_STEP / 2, e.altKey)) {
              return;
            }
            break;
        }
        if (this._currentMouseOverComp !== null) {
          this._currentMouseOverComp.keyDown(e);
        }
      }));
    }
    moveSelection(dx, dy, snapToGrid) {
      const sel = this.currentSelection;
      if (sel === void 0 || sel.previouslySelectedElements.size === 0) {
        return false;
      }
      for (const comp of sel.previouslySelectedElements) {
        if (comp instanceof DrawableWithDraggablePosition) {
          comp.setPosition(comp.posX + dx, comp.posY + dy, snapToGrid);
        }
      }
      return true;
    }
    registerTitleDragListenersOn(title2, closeHandler) {
      let isDragging = false;
      let startX, startY, startTop, startRight;
      title2.addEventListener("mousedown", (e) => {
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        const parent = title2.parentElement;
        const computedStyle = window.getComputedStyle(parent);
        startTop = parseInt(computedStyle.top, 10);
        startRight = parseInt(computedStyle.right, 10);
        title2.style.cursor = "grabbing";
        e.preventDefault();
      });
      document.addEventListener("mousemove", (e) => {
        if (!isDragging) {
          return;
        }
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        const parent = title2.parentElement;
        parent.style.top = `${startTop + deltaY}px`;
        parent.style.right = `${startRight - deltaX}px`;
      });
      document.addEventListener("mouseup", () => {
        if (isDragging) {
          isDragging = false;
          title2.style.removeProperty("cursor");
        }
      });
      if (closeHandler) {
        const closeButton = makeIcon("close");
        closeButton.classList.add("close-palette");
        closeButton.addEventListener("click", closeHandler);
        title2.appendChild(closeButton);
      }
    }
    _mouseDownTouchStart(e) {
      this.clearHoverTimeoutHandle();
      this.clearPopperIfNecessary();
      if (this._currentMouseDownData === null) {
        const xy = this.editor.offsetXY(e);
        this.updateMouseOver(xy, false, false);
        if (this._currentMouseOverComp !== null) {
          const { wantsDragEvents } = this._currentHandlers.mouseDownOn(this._currentMouseOverComp, e);
          if (wantsDragEvents) {
            const selectedComps = this.currentSelection === void 0 ? [] : [...this.currentSelection.previouslySelectedElements];
            for (const comp of selectedComps) {
              if (comp !== this._currentMouseOverComp) {
                this._currentHandlers.mouseDownOn(comp, e);
              }
            }
            const mouseDownData = {
              mainComp: this._currentMouseOverComp,
              selectionComps: selectedComps,
              firedMouseDraggedAlready: false,
              fireMouseClickedOnFinish: true,
              initialXY: xy,
              triggeredContextMenu: false
            };
            this._currentMouseDownData = mouseDownData;
            this.setStartDragTimeout(mouseDownData, e);
          }
          this.editor.editTools.redrawMgr.requestRedraw({ why: "mousedown" });
        } else {
          this._currentMouseDownData = {
            mainComp: this.editor.html.canvasContainer,
            selectionComps: [],
            // ignore selection
            firedMouseDraggedAlready: false,
            fireMouseClickedOnFinish: true,
            initialXY: xy,
            triggeredContextMenu: false
          };
          this._currentHandlers.mouseDownOnBackground(e);
        }
        this.editor.updateCursor(e);
      } else {
      }
    }
    _mouseMoveTouchMove(e) {
      if (this._currentMouseDownData !== null) {
        if (this._currentMouseDownData.triggeredContextMenu) {
          this._currentMouseDownData = null;
        } else {
          const initialXY = this._currentMouseDownData.initialXY;
          setDragStartData(e, initialXY[0], initialXY[1]);
          if (this._currentMouseDownData.mainComp instanceof Drawable) {
            let fireDragEvent = (
              // if we fired a drag event already for this "click session", we go on
              this._currentMouseDownData.firedMouseDraggedAlready
            );
            if (!fireDragEvent) {
              const d2 = distSquared(...this.editor.offsetXY(e), ...this._currentMouseDownData.initialXY);
              fireDragEvent = isNaN(d2) || d2 >= 5 * 5;
            }
            if (fireDragEvent) {
              this.clearStartDragTimeout();
              this._currentMouseDownData.fireMouseClickedOnFinish = false;
              this._currentHandlers.mouseDraggedOn(this._currentMouseDownData.mainComp, e);
              for (const comp of this._currentMouseDownData.selectionComps) {
                if (comp !== this._currentMouseDownData.mainComp) {
                  this._currentHandlers.mouseDraggedOn(comp, e);
                }
              }
              this._currentMouseDownData.firedMouseDraggedAlready = true;
            }
          } else {
            this._currentHandlers.mouseDraggedOnBackground(e);
          }
        }
      } else {
        const linkMgr = this.editor.editorRoot.linkMgr;
        this.updateMouseOver(this.editor.offsetXY(e), linkMgr.isAddingWire, linkMgr.isSettingAnchor);
      }
    }
    _mouseUpTouchEnd(e) {
      var _a, _b, _c, _d;
      const mouseUpTarget = (_b = (_a = this._currentMouseDownData) == null ? void 0 : _a.mainComp) != null ? _b : this._currentMouseOverComp;
      if (mouseUpTarget instanceof Drawable) {
        if (this._startDragTimeoutHandle !== null) {
          clearTimeout(this._startDragTimeoutHandle);
          this._startDragTimeoutHandle = null;
        }
        let change = this._currentHandlers.mouseUpOn(mouseUpTarget, e);
        for (const comp of (_d = (_c = this._currentMouseDownData) == null ? void 0 : _c.selectionComps) != null ? _d : []) {
          if (comp !== mouseUpTarget) {
            const newChange = this._currentHandlers.mouseUpOn(comp, e);
            change = InteractionResult.merge(change, newChange);
          }
        }
        const mouseDownData = this._currentMouseDownData;
        const fireMouseClicked = mouseDownData === null ? false : mouseDownData.fireMouseClickedOnFinish && !mouseDownData.triggeredContextMenu;
        if (fireMouseClicked) {
          let newChange;
          if (this.isDoubleClick(mouseUpTarget, e)) {
            newChange = this._currentHandlers.mouseDoubleClickedOn(mouseUpTarget, e);
            if (!newChange.isChange) {
              newChange = this._currentHandlers.mouseClickedOn(mouseUpTarget, e);
            }
          } else {
            newChange = this._currentHandlers.mouseClickedOn(mouseUpTarget, e);
          }
          change = InteractionResult.merge(change, newChange);
        }
        if (change.isChange) {
          this.editor.editTools.undoMgr.takeSnapshot(change);
        }
      } else {
        this._currentHandlers.mouseUpOnBackground(e);
      }
      this._currentMouseDownData = null;
      this.editor.editTools.redrawMgr.requestRedraw({ why: "mouseup" });
    }
    isDoubleClick(clickedComp, e) {
      if ("offsetX" in e) {
        return e.detail === 2;
      } else {
        const oldLastTouchEnd = this._lastTouchEnd;
        const now = (/* @__PURE__ */ new Date()).getTime();
        this._lastTouchEnd = [clickedComp, now];
        if (oldLastTouchEnd === void 0) {
          return false;
        }
        const [lastComp, lastTime] = oldLastTouchEnd;
        const elapsedTimeMillis = now - lastTime;
        const isDoubleTouch = lastComp === clickedComp && elapsedTimeMillis > 0 && elapsedTimeMillis < 300;
        if (isDoubleTouch) {
          this._lastTouchEnd = void 0;
        }
        return isDoubleTouch;
      }
    }
    registerButtonListenersOn(componentButtons, isCustomElement) {
      const editor = this.editor;
      for (const compButton of componentButtons) {
        const buttonMouseDownTouchStart = /* @__PURE__ */ __name((e) => {
          this.editor.setCurrentMouseAction("edit");
          e.preventDefault();
          this.editor.eventMgr.currentSelection = void 0;
          const newComponent = editor.factory.makeFromButton(editor.editorRoot, compButton);
          if (newComponent === void 0) {
            return;
          }
          this._currentMouseOverComp = newComponent;
          const { wantsDragEvents } = this._currentHandlers.mouseDownOn(newComponent, e);
          if (wantsDragEvents) {
            this._currentMouseDownData = {
              mainComp: this._currentMouseOverComp,
              selectionComps: [],
              // ignore selection when dragging new component
              firedMouseDraggedAlready: false,
              fireMouseClickedOnFinish: false,
              initialXY: [NaN, NaN],
              triggeredContextMenu: false
            };
          }
          const [x, y] = editor.offsetXY(e, true);
          setDragStartData(e, x, y);
          this._currentHandlers.mouseDraggedOn(newComponent, e);
        }, "buttonMouseDownTouchStart");
        compButton.addEventListener("mousedown", editor.wrapHandler((e) => {
          if (e.button === 2 || e.button === 0 && e.ctrlKey) {
            return;
          }
          buttonMouseDownTouchStart(e);
        }));
        compButton.addEventListener("touchstart", editor.wrapHandler((e) => {
          buttonMouseDownTouchStart(e);
        }));
        compButton.addEventListener("touchmove", editor.wrapHandler((e) => {
          e.preventDefault();
          this._mouseMoveTouchMove(e);
        }));
        compButton.addEventListener("touchend", editor.wrapHandler((e) => {
          e.preventDefault();
          this._mouseUpTouchEnd(e);
          this.setCurrentMouseOverComp(null);
        }));
        compButton.addEventListener("contextmenu", editor.wrapHandler((e) => {
          e.preventDefault();
          e.stopPropagation();
          if (isCustomElement && this.editor.mode >= 3 /* DESIGN */) {
            this._currentHandlers.contextMenuOnButton(compButton.dataset, e);
          }
        }));
      }
    }
    tryDeleteDrawable(comp) {
      if (comp instanceof ComponentBase) {
        const ref = comp.ref;
        if (this.editor.editorRoot.testSuites.hasReferenceTo(ref)) {
          if (!window.confirm(S.Tests.ComponentUsedInTestSuite.expand({ ref }))) {
            return InteractionResult.NoChange;
          }
        }
        const numDeleted = this.tryDeleteComponentsWhere((c) => c === comp, true);
        return InteractionResult.fromBoolean(numDeleted !== 0);
      } else if (comp instanceof Wire) {
        return this.editor.editorRoot.linkMgr.deleteWire(comp);
      } else if (comp instanceof Waypoint) {
        comp.removeFromParent();
        return InteractionResult.SimpleChange;
      }
      return InteractionResult.NoChange;
    }
    tryDeleteComponentsWhere(cond, onlyOne) {
      const numDeleted = this.editor.editorRoot.components.tryDeleteWhere(cond, onlyOne).length;
      if (numDeleted > 0) {
        this.clearPopperIfNecessary();
        this.editor.editTools.redrawMgr.requestRedraw({ why: "component(s) deleted", invalidateMask: true, invalidateTests: true });
      }
      return numDeleted;
    }
  };
  __name(UIEventManager, "UIEventManager");
  var ToolHandlers = class {
    constructor(editor) {
      this.editor = editor;
    }
    mouseHoverOn(__comp) {
    }
    mouseDownOn(__comp, __e2) {
      return { wantsDragEvents: true };
    }
    mouseDraggedOn(__comp, __e2) {
    }
    mouseUpOn(__comp, __e2) {
      return InteractionResult.NoChange;
    }
    mouseClickedOn(__comp, __e2) {
      return InteractionResult.NoChange;
    }
    mouseDoubleClickedOn(__comp, __e2) {
      return InteractionResult.NoChange;
    }
    contextMenuOn(__comp, __e2) {
      return false;
    }
    contextMenuOnButton(__props, __e2) {
    }
    mouseDownOnBackground(__e2) {
    }
    mouseDraggedOnBackground(__e2) {
    }
    mouseUpOnBackground(__e2) {
    }
    unmount() {
    }
  };
  __name(ToolHandlers, "ToolHandlers");
  var EditHandlers = class extends ToolHandlers {
    constructor(editor) {
      super(editor);
      this._openedContextMenu = null;
    }
    mouseHoverOn(comp) {
      const editor = this.editor;
      editor.eventMgr.clearPopperIfNecessary();
      if (editor.options.hideTooltips) {
        return;
      }
      if (comp instanceof ComponentBase && comp.state === 2 /* DEAD */) {
        return;
      }
      const tooltip = comp.makeTooltip();
      if (tooltip !== void 0) {
        const rect = /* @__PURE__ */ __name(() => {
          const containerRect = editor.html.canvasContainer.getBoundingClientRect();
          const f = editor.actualZoomFactor;
          const [cx, cy, w, h] = comp instanceof DrawableWithPosition ? [comp.posX * f, comp.posY * f, comp.width * f, comp.height * f] : [editor.mouseX, editor.mouseY, 4, 4];
          return new DOMRect(containerRect.x + cx - w / 2, containerRect.y + cy - h / 2, w, h);
        }, "rect");
        editor.eventMgr.makePopper(tooltip, rect);
      }
    }
    mouseDownOn(comp, e) {
      return comp.mouseDown(e);
    }
    mouseDraggedOn(comp, e) {
      comp.mouseDragged(e);
    }
    mouseUpOn(comp, e) {
      const change = comp.mouseUp(e);
      this.editor.editorRoot.linkMgr.tryCancelWireOrAnchor();
      return change;
    }
    mouseClickedOn(comp, e) {
      return comp.mouseClicked(e);
    }
    mouseDoubleClickedOn(comp, e) {
      return comp.mouseDoubleClicked(e);
    }
    contextMenuOn(comp, e) {
      return this.showContextMenu(comp.makeContextMenu(), e);
    }
    contextMenuOnButton(props, e) {
      return this.showContextMenu(this.editor.factory.makeContextMenu(props.type), e);
    }
    mouseDownOnBackground(e) {
      const editor = this.editor;
      const eventMgr = editor.eventMgr;
      const currentSelection = eventMgr.currentSelection;
      if (currentSelection !== void 0) {
        const allowSelection = editor.mode >= 2 /* CONNECT */;
        if (e.shiftKey && allowSelection) {
          if (currentSelection.currentlyDrawnRect !== void 0) {
            console.log("unexpected defined current rect when about to begin a new one");
          }
          const [left2, top2] = editor.offsetXY(e);
          const rect = new DOMRect(left2, top2, 1, 1);
          currentSelection.currentlyDrawnRect = rect;
        } else {
          eventMgr.currentSelection = void 0;
        }
        editor.editTools.redrawMgr.requestRedraw({ why: "selection rect changed" });
      }
    }
    mouseDraggedOnBackground(e) {
      const editor = this.editor;
      const allowSelection = editor.mode >= 2 /* CONNECT */;
      if (allowSelection) {
        const eventMgr = editor.eventMgr;
        const currentSelection = eventMgr.currentSelection;
        const [x, y] = editor.offsetXY(e);
        if (currentSelection === void 0) {
          const rect = new DOMRect(x, y, 1, 1);
          eventMgr.currentSelection = new EditorSelection(rect);
        } else {
          const rect = currentSelection.currentlyDrawnRect;
          if (rect === void 0) {
            console.log("trying to update a selection rect that is not defined");
          } else {
            rect.width = x - rect.x;
            rect.height = y - rect.y;
            editor.editTools.redrawMgr.requestRedraw({ why: "selection rect changed" });
          }
        }
      }
    }
    mouseUpOnBackground(__e2) {
      const editor = this.editor;
      editor.linkMgr.tryCancelWireOrAnchor();
      const eventMgr = editor.eventMgr;
      const currentSelection = eventMgr.currentSelection;
      if (currentSelection !== void 0) {
        currentSelection.finishCurrentRect(this.editor);
        editor.editTools.redrawMgr.requestRedraw({ why: "selection rect changed" });
      }
    }
    showContextMenu(menuData, e) {
      const hideMenu = /* @__PURE__ */ __name(() => {
        if (this._openedContextMenu !== null) {
          this._openedContextMenu.classList.remove("show-menu");
          this._openedContextMenu.innerHTML = "";
          this._openedContextMenu = null;
        }
      }, "hideMenu");
      hideMenu();
      if (menuData !== void 0) {
        const currentMouseDownData = this.editor.eventMgr.currentMouseDownData;
        if (currentMouseDownData !== null) {
          currentMouseDownData.triggeredContextMenu = true;
        }
        let hasContentJustifyingSeparator = false;
        const defToElem = /* @__PURE__ */ __name((item) => {
          var _a;
          function mkButton(spec, shortcut, danger) {
            return button(
              type("button"),
              cls(`menu-btn${danger ? " danger" : ""}`),
              spec.icon === void 0 ? spec.caption : mods(
                makeIcon(spec.icon),
                span(cls("menu-text"), spec.caption)
              ),
              shortcut === void 0 ? emptyMod : span(cls("menu-shortcut"), shortcut)
            );
          }
          __name(mkButton, "mkButton");
          hasContentJustifyingSeparator || (hasContentJustifyingSeparator = item._tag !== "sep");
          switch (item._tag) {
            case "sep":
              if (hasContentJustifyingSeparator) {
                hasContentJustifyingSeparator = false;
                return li(cls("menu-separator")).render();
              } else {
                return emptyMod;
              }
            case "text":
              return li(cls("menu-item-static"), item.caption).render();
            case "item": {
              const but = mkButton(item, item.shortcut, (_a = item.danger) != null ? _a : false).render();
              but.addEventListener("click", this.editor.wrapHandler((itemEvent) => __async(this, null, function* () {
                const result = yield Promise.resolve(item.action(itemEvent, e));
                this.editor.editTools.undoMgr.takeSnapshot(result);
                this.editor.focus();
              })));
              return li(cls("menu-item"), but).render();
            }
            case "submenu": {
              return li(
                cls("menu-item submenu"),
                mkButton(item, void 0, false),
                ul(
                  cls("menu"),
                  ...item.items.map(defToElem)
                )
              ).render();
            }
          }
        }, "defToElem");
        const items = menuData.map(defToElem);
        const mainContextMenu = this.editor.html.mainContextMenu;
        applyModifiersTo(mainContextMenu, items);
        const em = e;
        mainContextMenu.classList.add("show-menu");
        let menuTop = em.pageY;
        mainContextMenu.style.top = menuTop + "px";
        mainContextMenu.style.left = em.pageX + "px";
        let needsScrollY = false;
        const menuRect = mainContextMenu.getBoundingClientRect();
        const hOverflow = window.innerHeight - menuRect.bottom;
        if (hOverflow < 0) {
          menuTop += Math.min(0, hOverflow);
          if (menuTop < 5) {
            menuTop = 5;
            needsScrollY = true;
          }
          mainContextMenu.style.top = menuTop + "px";
        }
        if (needsScrollY) {
          mainContextMenu.style.setProperty("max-height", window.innerHeight - 10 + "px");
          mainContextMenu.style.setProperty("overflow-y", "scroll");
        } else {
          mainContextMenu.style.removeProperty("max-height");
          mainContextMenu.style.removeProperty("overflow-y");
        }
        this._openedContextMenu = mainContextMenu;
        const clickHandler = /* @__PURE__ */ __name(() => {
          hideMenu();
          document.removeEventListener("click", clickHandler);
        }, "clickHandler");
        setTimeout(() => {
          document.addEventListener("click", clickHandler, false);
        }, 200);
        return true;
      }
      return false;
    }
  };
  __name(EditHandlers, "EditHandlers");
  var DeleteHandlers = class extends ToolHandlers {
    constructor(editor) {
      super(editor);
    }
    mouseClickedOn(comp, __) {
      return this.editor.eventMgr.tryDeleteDrawable(comp);
    }
  };
  __name(DeleteHandlers, "DeleteHandlers");
  var SetAnchorHandlers = class extends ToolHandlers {
    constructor(editor, from) {
      super(editor);
      this._from = from;
      editor.linkMgr.startSettingAnchorFrom(from);
    }
    unmount() {
      this.editor.linkMgr.tryCancelSetAnchor();
    }
    finish() {
      this.editor.setCurrentMouseAction("edit");
    }
    mouseClickedOn(comp, __) {
      let result = InteractionResult.NoChange;
      if (comp instanceof ComponentBase) {
        result = this.editor.linkMgr.trySetAnchor(this._from, comp);
      } else {
        this.editor.linkMgr.tryCancelSetAnchor();
      }
      this.finish();
      return result;
    }
    mouseUpOnBackground(__) {
      this.editor.linkMgr.tryCancelSetAnchor();
      this.finish();
    }
  };
  __name(SetAnchorHandlers, "SetAnchorHandlers");
  var MoveHandlers = class extends ToolHandlers {
    constructor(editor) {
      super(editor);
    }
    mouseDownOnBackground(e) {
      for (const comp of this.editor.components.all()) {
        comp.mouseDown(e);
      }
      for (const wire of this.editor.linkMgr.wires) {
        for (const waypoint of wire.waypoints) {
          waypoint.mouseDown(e);
        }
      }
    }
    mouseDraggedOnBackground(e) {
      for (const comp of this.editor.components.all()) {
        comp.mouseDragged(e);
      }
      for (const wire of this.editor.linkMgr.wires) {
        for (const waypoint of wire.waypoints) {
          waypoint.mouseDragged(e);
        }
      }
    }
    mouseUpOnBackground(e) {
      for (const comp of this.editor.components.all()) {
        comp.mouseUp(e);
      }
      for (const wire of this.editor.linkMgr.wires) {
        for (const waypoint of wire.waypoints) {
          waypoint.mouseUp(e);
        }
      }
    }
  };
  __name(MoveHandlers, "MoveHandlers");

  // simulator/src/UndoManager.ts
  var MAX_UNDO_SNAPSHOTS = 100;
  var UndoManager = class {
    constructor(editor) {
      this._undoSnapshots = [];
      this._redoSnapshots = [];
      // public callback function
      this.onStateChanged = /* @__PURE__ */ __name((__) => null, "onStateChanged");
      this.editor = editor;
    }
    get state() {
      return {
        canUndo: this.canUndo(),
        canRedoOrRepeat: this.canRedoOrRepeat()
      };
    }
    canUndo() {
      return this._undoSnapshots.length > 1;
    }
    canRedoOrRepeat() {
      return this._redoSnapshots.length > 0 || this._undoSnapshots.length > 0 && this._undoSnapshots[this._undoSnapshots.length - 1].repeatAction !== void 0;
    }
    takeSnapshot(interactionResult) {
      var _a;
      const isChange = (_a = interactionResult == null ? void 0 : interactionResult.isChange) != null ? _a : true;
      if (!isChange) {
        return;
      }
      const repeatAction = interactionResult === void 0 ? void 0 : interactionResult._tag === "RepeatableChange" ? interactionResult.repeat : void 0;
      this.doTakeSnapshot(repeatAction);
    }
    doTakeSnapshot(repeatAction) {
      const now = Date.now();
      const dataObject = this.editor.save();
      const jsonStr = Serialization.stringifyObject(dataObject, true);
      this._undoSnapshots.push({ time: now, circuitStr: jsonStr, repeatAction });
      while (this._undoSnapshots.length > MAX_UNDO_SNAPSHOTS) {
        this._undoSnapshots.shift();
      }
      if (this._redoSnapshots.length > 0) {
        this._redoSnapshots = [];
      }
      this.fireStateChangedIfNeeded();
    }
    undo() {
      if (!this.canUndo()) {
        this.editor.showMessage(S.Messages.NothingToUndo);
        return;
      }
      const stateNow = this._undoSnapshots.pop();
      const prevState = this._undoSnapshots[this._undoSnapshots.length - 1];
      this._redoSnapshots.push(stateNow);
      this.loadSnapshot(prevState);
      this.editor.showMessage(S.Messages.DidUndo);
      this.fireStateChangedIfNeeded();
    }
    redoOrRepeat() {
      if (!this.canRedoOrRepeat()) {
        this.editor.showMessage(S.Messages.NothingToRedo);
        return;
      }
      const snapshot = this._redoSnapshots.pop();
      if (snapshot !== void 0) {
        this._undoSnapshots.push(snapshot);
        this.loadSnapshot(snapshot);
        this.editor.showMessage(S.Messages.DidRedo);
      } else {
        const repeatAction = this._undoSnapshots[this._undoSnapshots.length - 1].repeatAction;
        if (repeatAction !== void 0) {
          const result = repeatAction();
          const newRepeatAction = result === false ? void 0 : result === true ? repeatAction : result;
          this.doTakeSnapshot(newRepeatAction);
          this.editor.showMessage(S.Messages.DidRepeat);
        }
      }
      this.fireStateChangedIfNeeded();
    }
    dump() {
      function printStack(name2, stack) {
        const title2 = name2 + (stack.length === 0 ? " (empty)" : "");
        console.group(title2);
        for (let i2 = stack.length - 1; i2 >= 0; i2--) {
          const snapshot = stack[i2];
          const timeStr = new Date(snapshot.time).toISOString();
          console.log(timeStr + "	" + snapshot.circuitStr);
        }
        console.groupEnd();
      }
      __name(printStack, "printStack");
      printStack("Undo stack", this._undoSnapshots);
      printStack("Redo stack", this._redoSnapshots);
    }
    loadSnapshot(snapshot) {
      Serialization.loadCircuitOrLibrary(this.editor, snapshot.circuitStr, { isUndoRedoAction: true });
    }
    fireStateChangedIfNeeded() {
      const newState = this.state;
      if (this._lastSentState === void 0 || !areStatesEqual2(this._lastSentState, newState)) {
        this.onStateChanged(newState);
        this._lastSentState = newState;
      }
    }
  };
  __name(UndoManager, "UndoManager");
  function areStatesEqual2(s1, s2) {
    return s1.canUndo === s2.canUndo && s1.canRedoOrRepeat === s2.canRedoOrRepeat;
  }
  __name(areStatesEqual2, "areStatesEqual");

  // simulator/src/gallery.ts
  var gallery = {
    CharacterComparator: {
      "v": 5,
      "in": [
        { "pos": [50, 130], "id": 0, "val": 1 },
        { "pos": [50, 160], "id": 1, "val": 1 },
        { "pos": [50, 190], "id": 2, "val": 1 },
        { "pos": [50, 220], "id": 3, "val": 0 },
        { "pos": [50, 250], "id": 4, "val": 1 },
        { "pos": [50, 280], "id": 13, "val": 0 },
        { "pos": [50, 310], "id": 14, "val": 1 },
        { "pos": [50, 360], "id": 15, "val": 1 },
        { "pos": [50, 390], "id": 16, "val": 0 },
        { "pos": [50, 420], "id": 17, "val": 1 },
        { "pos": [50, 450], "id": 18, "val": 0 },
        { "pos": [50, 480], "id": 19, "val": 1 },
        { "pos": [50, 510], "id": 20, "val": 0 },
        { "pos": [50, 540], "id": 21, "val": 1 }
      ],
      "out": [
        { "pos": [870, 310], "id": 5 },
        { "type": "ascii", "pos": [180, 60], "id": [6, 7, 8, 9, 10, 11, 12] },
        { "type": "ascii", "pos": [180, 620], "id": [22, 23, 24, 25, 26, 27, 28] }
      ],
      "gates": [
        { "type": "XOR", "pos": [360, 140], "in": [29, 30], "out": 31 },
        { "type": "XOR", "pos": [360, 200], "in": [32, 33], "out": 34 },
        { "type": "XOR", "pos": [360, 260], "in": [35, 36], "out": 37 },
        { "type": "XOR", "pos": [360, 320], "in": [38, 39], "out": 40 },
        { "type": "XOR", "pos": [360, 380], "in": [41, 42], "out": 43 },
        { "type": "XOR", "pos": [360, 440], "in": [44, 45], "out": 46 },
        { "type": "XOR", "pos": [360, 500], "in": [47, 48], "out": 49 },
        { "type": "OR", "pos": [470, 170], "in": [68, 69], "out": 70 },
        { "type": "OR", "pos": [500, 280], "in": [71, 72], "out": 73 },
        { "type": "OR", "pos": [490, 410], "in": [74, 75], "out": 76 },
        { "type": "OR", "pos": [630, 250], "in": [77, 78], "out": 79 },
        { "type": "OR", "pos": [630, 410], "in": [80, 81], "out": 82 },
        { "type": "OR", "pos": [730, 310], "in": [83, 84], "out": 85 },
        { "type": "NOT", "pos": [800, 310], "in": 50, "out": 51 }
      ],
      "wires": [
        [0, 6],
        [1, 7],
        [2, 8],
        [3, 9],
        [4, 10],
        [13, 11],
        [14, 12],
        [15, 22],
        [16, 23],
        [17, 24],
        [18, 25],
        [19, 26],
        [20, 27],
        [21, 28],
        [0, 29],
        [15, 30],
        [79, 83],
        [82, 84],
        [31, 68],
        [34, 69],
        [37, 71],
        [40, 72],
        [43, 74],
        [46, 75],
        [49, 81],
        [76, 80],
        [73, 78],
        [70, 77],
        [85, 50],
        [51, 5],
        [1, 32],
        [16, 33],
        [2, 35],
        [17, 36],
        [18, 39],
        [3, 38],
        [4, 41],
        [19, 42],
        [13, 44],
        [20, 45],
        [21, 48],
        [14, 47]
      ]
    },
    Counters: {
      "v": 5,
      "in": [
        { "type": "clock", "pos": [70, 40], "id": 0, "name": "bit 0", "period": 2e3, "phase": 1e3, "showLabel": false },
        { "type": "clock", "pos": [70, 80], "id": 10, "name": "bit 1", "period": 4e3, "phase": 2e3, "showLabel": false },
        { "type": "clock", "pos": [70, 120], "id": 23, "name": "bit 2", "period": 8e3, "phase": 4e3, "showLabel": false },
        { "type": "clock", "pos": [70, 160], "id": 24, "name": "bit 3", "period": 16e3, "phase": 8e3, "showLabel": false },
        { "type": "clock", "pos": [430, 30], "id": 5, "period": 500, "phase": 250, "showLabel": false },
        { "type": "clock", "pos": [430, 70], "id": 6, "period": 1e3, "phase": 500, "showLabel": false },
        { "type": "clock", "pos": [430, 110], "id": 7, "period": 2e3, "phase": 1e3, "showLabel": false },
        { "type": "clock", "pos": [430, 150], "id": 8, "period": 4e3, "phase": 2e3, "showLabel": false },
        { "type": "clock", "pos": [430, 190], "id": 9, "period": 8e3, "phase": 4e3, "showLabel": false },
        { "type": "clock", "pos": [430, 230], "id": 11, "period": 16e3, "phase": 8e3, "showLabel": false },
        { "type": "clock", "pos": [430, 270], "id": 12, "period": 32e3, "phase": 16e3, "showLabel": false }
      ],
      "out": [
        { "type": "display", "bits": 4, "pos": [240, 90], "id": [1, 2, 3, 4] },
        { "type": "ascii", "pos": [580, 150], "id": [13, 14, 15, 16, 17, 18, 19] }
      ],
      "wires": [
        [0, 1],
        [24, 4],
        [23, 3],
        [10, 2],
        [5, 13],
        [6, 14],
        [7, 15],
        [8, 16],
        [9, 17],
        [11, 18],
        [12, 19]
      ]
    },
    AllGates: {
      "v": 5,
      "in": [
        { "pos": [40, 320], "id": 0, "val": 0 },
        { "pos": [40, 490], "id": 1, "val": 0 }
      ],
      "out": [
        { "pos": [400, 30], "id": 48 },
        { "pos": [400, 80], "id": 49 },
        { "pos": [400, 140], "id": 50 },
        { "pos": [400, 260], "id": 51 },
        { "pos": [400, 380], "id": 52 },
        { "pos": [400, 200], "id": 53 },
        { "pos": [400, 320], "id": 54 },
        { "pos": [400, 440], "id": 55 },
        { "pos": [400, 560], "id": 56 },
        { "pos": [400, 680], "id": 57 },
        { "pos": [400, 500], "id": 58 },
        { "pos": [400, 620], "id": 59 },
        { "pos": [400, 740], "id": 60 },
        { "pos": [400, 860], "id": 61 },
        { "pos": [400, 800], "id": 62 },
        { "pos": [400, 920], "id": 63 }
      ],
      "gates": [
        { "type": "NOT", "pos": [290, 80], "in": 2, "out": 3 },
        { "type": "BUF", "pos": [290, 30], "in": 4, "out": 5 },
        { "type": "AND", "pos": [290, 140], "in": [6, 7], "out": 8 },
        { "type": "OR", "pos": [290, 260], "in": [9, 10], "out": 11 },
        { "type": "XOR", "pos": [290, 380], "in": [12, 13], "out": 14 },
        { "type": "NAND", "pos": [290, 200], "in": [15, 16], "out": 17 },
        { "type": "NOR", "pos": [290, 320], "in": [18, 19], "out": 20 },
        { "type": "XNOR", "pos": [290, 440], "in": [21, 22], "out": 23 },
        { "type": "IMPLY", "pos": [290, 560], "in": [24, 25], "out": 26 },
        { "type": "RIMPLY", "pos": [290, 680], "in": [27, 28], "out": 29 },
        { "type": "NIMPLY", "pos": [290, 500], "in": [30, 31], "out": 32 },
        { "type": "RNIMPLY", "pos": [290, 620], "in": [33, 34], "out": 35 },
        { "type": "TXA", "pos": [290, 740], "in": [36, 37], "out": 38 },
        { "type": "TXB", "pos": [290, 860], "in": [39, 40], "out": 41 },
        { "type": "TXNA", "pos": [290, 800], "in": [42, 43], "out": 44 },
        { "type": "TXNB", "pos": [290, 920], "in": [45, 46], "out": 47 }
      ],
      "wires": [
        [0, 4],
        [0, 2],
        [0, 6],
        [0, 9],
        [0, 12],
        [0, 15],
        [0, 18],
        [0, 21],
        [0, 24],
        [0, 27],
        [0, 30],
        [0, 33],
        [0, 36],
        [0, 39],
        [0, 42],
        [0, 45],
        [1, 7],
        [1, 10],
        [1, 13],
        [1, 16],
        [1, 19],
        [1, 22],
        [1, 25],
        [1, 28],
        [1, 31],
        [1, 34],
        [1, 37],
        [1, 40],
        [1, 43],
        [1, 46],
        [5, 48],
        [3, 49],
        [8, 50],
        [11, 51],
        [14, 52],
        [17, 53],
        [20, 54],
        [23, 55],
        [26, 56],
        [29, 57],
        [32, 58],
        [35, 59],
        [38, 60],
        [41, 61],
        [44, 62],
        [47, 63]
      ]
    },
    SevenSegmentDisplay: {
      "v": 5,
      "opts": {
        "propagationDelay": 20
      },
      "in": [
        { type: "clock", "pos": [90, 60], "orient": "s", "id": 21, "period": 16e3, "phase": 8e3 },
        { type: "clock", "pos": [130, 60], "orient": "s", "id": 22, "period": 8e3, "phase": 4e3 },
        { type: "clock", "pos": [170, 60], "orient": "s", "id": 23, "period": 4e3, "phase": 2e3 },
        { type: "clock", "pos": [210, 60], "orient": "s", "id": 24, "period": 2e3, "phase": 1e3 }
      ],
      "out": [
        { "type": "display", "bits": 4, "pos": [1320, 140], "id": [132, 133, 134, 135], "radix": 16 },
        { "type": "bar", "pos": [1330, 310], "id": 117, "display": "h" },
        { "type": "bar", "pos": [1270, 490], "id": 118, "display": "v" },
        { "type": "bar", "pos": [1390, 370], "id": 119, "display": "v" },
        { "type": "bar", "pos": [1270, 370], "id": 120, "display": "v" },
        { "type": "bar", "pos": [1330, 430], "id": 121, "display": "h" },
        { "type": "bar", "pos": [1390, 490], "id": 122, "display": "v" },
        { "type": "bar", "pos": [1330, 550], "id": 123, "display": "h" }
      ],
      "gates": [
        { "type": "NOT", "pos": [1170, 310], "in": 103, "out": 104 },
        { "type": "NOT", "pos": [1170, 350], "in": 105, "out": 106 },
        { "type": "NOT", "pos": [1170, 390], "in": 107, "out": 108 },
        { "type": "NOT", "pos": [1170, 430], "in": 109, "out": 110 },
        { "type": "NOT", "pos": [1170, 550], "in": 111, "out": 112 },
        { "type": "NOT", "pos": [1170, 510], "in": 113, "out": 114 },
        { "type": "NOT", "pos": [1170, 470], "in": 115, "out": 116 },
        { "type": "XOR", "pos": [210, 180], "in": [0, 1], "out": 2 },
        { "type": "AND", "pos": [220, 340], "in": [3, 4], "out": 5 },
        { "type": "XOR", "pos": [200, 420], "in": [6, 7], "out": 8 },
        { "type": "XOR", "pos": [330, 220], "in": [9, 10], "out": 11 },
        { "type": "XOR", "pos": [340, 280], "in": [12, 13], "out": 14 },
        { "type": "OR", "pos": [320, 480], "in": [15, 16], "out": 17 },
        { "type": "NOR", "pos": [440, 220], "in": [18, 19], "out": 20 },
        { "type": "XOR", "pos": [450, 290], "in": [25, 26], "out": 27 },
        { "type": "NOR", "pos": [430, 450], "in": [31, 32], "out": 33 },
        { "type": "NOR", "pos": [560, 410], "in": [34, 35], "out": 36 },
        { "type": "NOR", "pos": [600, 190], "in": [37, 38], "out": 39 },
        { "type": "NOR", "pos": [540, 360], "in": [40, 41], "out": 42 },
        { "type": "XOR", "pos": [650, 320], "in": [43, 44], "out": 45 },
        { "type": "OR", "pos": [670, 430], "in": [46, 47], "out": 48 },
        { "type": "XOR", "pos": [770, 490], "in": [49, 50], "out": 51 },
        { "type": "NOR", "pos": [770, 540], "in": [52, 53], "out": 54 },
        { "type": "NOR", "pos": [800, 390], "in": [55, 56], "out": 57 },
        { "type": "OR", "pos": [960, 250], "in": [58, 59], "out": 60 },
        { "type": "NOR", "pos": [940, 310], "in": [61, 62], "out": 63 },
        { "type": "AND", "pos": [1050, 270], "in": [64, 65], "out": 66 },
        { "type": "AND", "pos": [950, 380], "in": [67, 68], "out": 69 },
        { "type": "AND", "pos": [950, 440], "in": [70, 71], "out": 72 },
        { "type": "OR", "pos": [1030, 410], "in": [73, 74], "out": 75 },
        { "type": "XOR", "pos": [1030, 520], "in": [76, 77], "out": 78 }
      ],
      "wires": [
        [104, 117],
        [106, 119],
        [108, 122],
        [110, 123],
        [112, 121],
        [114, 120],
        [116, 118],
        [21, 135],
        [22, 134],
        [23, 133],
        [24, 132],
        [21, 0],
        [23, 1],
        [24, 3],
        [22, 4],
        [24, 6],
        [21, 7],
        [2, 9],
        [22, 10],
        [23, 12],
        [5, 13],
        [5, 15],
        [8, 16],
        [11, 18],
        [14, 19],
        [11, 25],
        [8, 26],
        [5, 32],
        [14, 31],
        [33, 34],
        [21, 35],
        [20, 37],
        [2, 38],
        [27, 40],
        [8, 41],
        [42, 43],
        [21, 44],
        [39, 46],
        [17, 47],
        [48, 49],
        [21, 50],
        [48, 52],
        [33, 53],
        [36, 56],
        [45, 55],
        [57, 103],
        [39, 58],
        [24, 59],
        [60, 64],
        [27, 65],
        [66, 109],
        [39, 61],
        [45, 62],
        [63, 113],
        [69, 73],
        [72, 74],
        [75, 105],
        [39, 67],
        [24, 68],
        [45, 70],
        [22, 71],
        [51, 115],
        [20, 111],
        [78, 107],
        [72, 76],
        [54, 77]
      ]
    },
    SevenSegmentBCDDisplay: {
      "v": 5,
      "in": [
        { "bits": 4, "pos": [50, 80], "id": [0, 1, 2, 3], "val": [0, 1, 0, 1] }
      ],
      "out": [
        { "type": "bar", "pos": [560, 100], "id": 4, "display": "h" },
        { "type": "bar", "pos": [620, 280], "id": 5, "display": "v" },
        { "type": "bar", "pos": [500, 160], "id": 6, "display": "v" },
        { "type": "bar", "pos": [560, 220], "id": 7, "display": "h" },
        { "type": "bar", "pos": [560, 340], "id": 8, "display": "h" },
        { "type": "bar", "pos": [500, 280], "id": 9, "display": "v" },
        { "type": "bar", "pos": [620, 160], "id": 10, "display": "v" },
        { "type": "bar", "pos": [420, 160], "id": 50, "display": "v" },
        { "type": "bar", "pos": [420, 280], "id": 51, "display": "v" },
        { "type": "display", "bits": 4, "pos": [170, 250], "id": [11, 23, 24, 25] }
      ],
      "ic": [
        { "type": "decoder-7seg", "pos": [280, 60], "in": [12, 13, 14, 15], "out": [16, 17, 18, 19, 20, 21, 22] },
        { "type": "decoder-bcd4", "pos": [180, 80], "in": [26, 27, 28, 29], "out": [30, 31, 32, 33, 34] }
      ],
      "wires": [
        [16, 4],
        [17, 10],
        [18, 5],
        [19, 8],
        [20, 9],
        [21, 6],
        [22, 7],
        [0, 11],
        [1, 23],
        [2, 24],
        [3, 25],
        [0, 26],
        [1, 27],
        [2, 28],
        [3, 29],
        [30, 12],
        [31, 13],
        [32, 14],
        [33, 15],
        [34, 50],
        [34, 51]
      ]
    },
    SixteenVsSevenSegmentDisplays: {
      "v": 5,
      "in": [
        { "bits": 4, "pos": [50, 90], "id": [74, 75, 76, 77], "val": [1, 0, 0, 1] },
        { "bits": 4, "pos": [50, 170], "id": [78, 79, 80, 81], "val": [1, 1, 0, 0] }
      ],
      "out": [
        { "type": "16seg", "pos": [440, 170], "id": [57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73] },
        { "type": "ascii", "pos": [230, 60], "id": [82, 83, 84, 85, 86, 87, 88], "additionalReprRadix": 10 },
        { "type": "7seg", "pos": [440, 330], "id": [93, 94, 95, 96, 97, 98, 99, 100] }
      ],
      "gates": [{ "type": "OR", "pos": [330, 250], "in": [90, 91], "out": 92 }],
      "ic": [
        { "type": "decoder-16seg", "pos": [230, 170], "in": [34, 35, 36, 37, 38, 39, 40], "out": [41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 89] },
        { "type": "decoder-7seg", "pos": [230, 320], "in": [101, 102, 103, 104], "out": [105, 106, 107, 108, 109, 110, 111] }
      ],
      "wires": [
        [74, 82],
        [75, 83],
        [76, 84],
        [77, 85],
        [78, 86],
        [79, 87],
        [80, 88],
        [41, 57],
        [42, 58],
        [43, 59],
        [44, 60],
        [45, 61],
        [46, 62],
        [47, 63],
        [48, 64],
        [49, 65],
        [50, 66],
        [51, 67],
        [52, 68],
        [53, 69],
        [54, 70],
        [55, 71],
        [56, 72],
        [74, 34],
        [75, 35],
        [76, 36],
        [77, 37],
        [78, 38],
        [79, 39],
        [80, 40],
        [89, 90],
        [92, 73],
        [81, 91],
        [105, 93],
        [106, 94],
        [107, 95],
        [108, 96],
        [109, 97],
        [110, 98],
        [111, 99],
        [74, 101],
        [75, 102],
        [76, 103],
        [77, 104],
        [81, 100, { "via": [[200, 370]] }]
      ]
    },
    NibbleAdder: {
      "v": 5,
      "in": [
        { "pos": [100, 40], "orient": "s", "id": 3, "name": "A3", "val": 0 },
        { "pos": [200, 40], "orient": "s", "id": 0, "name": "A2", "val": 0 },
        { "pos": [300, 40], "orient": "s", "id": 1, "name": "A1", "val": 0 },
        { "pos": [400, 40], "orient": "s", "id": 2, "name": "A0", "val": 0 },
        { "pos": [140, 180], "orient": "s", "id": 15, "name": "B3", "val": 0 },
        { "pos": [240, 180], "orient": "s", "id": 14, "name": "B2", "val": 0 },
        { "pos": [340, 180], "orient": "s", "id": 13, "name": "B1", "val": 0 },
        { "pos": [440, 180], "orient": "s", "id": 12, "name": "B0", "val": 0 }
      ],
      "out": [
        { "pos": [30, 450], "orient": "s", "id": 37, "name": "S4" },
        { "pos": [120, 450], "orient": "s", "id": 36, "name": "S3" },
        { "pos": [220, 450], "orient": "s", "id": 38, "name": "S2" },
        { "pos": [320, 450], "orient": "s", "id": 39, "name": "S1" },
        { "pos": [420, 450], "orient": "s", "id": 40, "name": "S0" },
        { "type": "display", "bits": 4, "pos": [530, 100], "id": [4, 5, 6, 7] },
        { "type": "display", "bits": 4, "pos": [530, 240], "id": [8, 9, 10, 11] },
        { "type": "display", "bits": 4, "pos": [530, 390], "id": [41, 42, 43, 44] }
      ],
      "ic": [
        { "type": "adder", "pos": [420, 320], "in": [16, 17, 18], "out": [19, 20] },
        { "type": "adder", "pos": [320, 320], "in": [21, 22, 23], "out": [24, 25] },
        { "type": "adder", "pos": [220, 320], "in": [26, 27, 28], "out": [29, 30] },
        { "type": "adder", "pos": [120, 320], "in": [31, 32, 33], "out": [34, 35] }
      ],
      "wires": [
        [12, 8],
        [13, 9],
        [14, 10],
        [15, 11],
        [2, 4],
        [1, 5],
        [0, 6],
        [3, 7],
        [20, 23],
        [25, 28],
        [30, 33],
        [2, 16],
        [12, 17],
        [1, 21],
        [13, 22],
        [0, 26],
        [14, 27],
        [3, 31],
        [15, 32],
        [19, 41],
        [24, 42],
        [29, 43],
        [34, 44],
        [35, 37],
        [34, 36],
        [29, 38],
        [24, 39],
        [19, 40]
      ]
    },
    ALU: {
      "v": 5,
      "in": [
        { "pos": [290, 60], "orient": "s", "id": 16, "name": "Op1", "val": 0 },
        { "pos": [330, 60], "orient": "s", "id": 17, "name": "Op0", "val": 0 },
        { "pos": [50, 140], "id": 18, "val": 0 },
        { "pos": [50, 160], "id": 19, "name": "A", "val": 0 },
        { "pos": [50, 180], "id": 20, "val": 0 },
        { "pos": [50, 200], "id": 21, "val": 0 },
        { "pos": [50, 240], "id": 26, "val": 0 },
        { "pos": [50, 260], "id": 27, "name": "B", "val": 0 },
        { "pos": [50, 280], "id": 28, "val": 0 },
        { "pos": [50, 300], "id": 29, "val": 0 }
      ],
      "out": [
        { "pos": [420, 320], "id": 38, "name": "Zero" },
        { "pos": [420, 350], "id": 39, "name": "oVerflow" },
        { "type": "display", "bits": 4, "pos": [110, 60], "orient": "n", "id": [22, 23, 24, 25], "name": "A (non sign\xE9)" },
        { "type": "display", "bits": 4, "pos": [110, 350], "orient": "s", "id": [30, 31, 32, 33], "name": "B (non sign\xE9)" },
        { "type": "display", "bits": 4, "pos": [420, 250], "id": [34, 35, 36, 37], "name": "Y (sign\xE9)", "radix": -10 },
        { "type": "display", "bits": 4, "pos": [420, 150], "id": [40, 41, 42, 43], "name": "Y (non sign\xE9)" },
        { "type": "display", "bits": 4, "pos": [210, 60], "orient": "n", "id": [44, 45, 46, 47], "name": "A (sign\xE9)", "radix": -10 },
        { "type": "display", "bits": 4, "pos": [210, 350], "orient": "s", "id": [48, 49, 50, 51], "name": "B (sign\xE9)", "radix": -10 }
      ],
      "ic": [
        { "type": "alu", "pos": [280, 220], "in": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "out": [10, 11, 12, 13, 14, 15] }
      ],
      "wires": [
        [16, 9],
        [17, 8],
        [21, 3],
        [20, 2],
        [19, 1],
        [18, 0],
        [18, 22],
        [19, 23],
        [20, 24],
        [21, 25],
        [26, 4],
        [27, 5],
        [28, 6],
        [29, 7],
        [26, 30],
        [27, 31],
        [28, 32],
        [29, 33],
        [10, 34],
        [11, 35],
        [12, 36],
        [13, 37],
        [15, 38],
        [14, 39],
        [10, 40],
        [11, 41],
        [12, 42],
        [13, 43],
        [18, 44],
        [19, 45],
        [20, 46],
        [21, 47],
        [26, 48],
        [27, 49],
        [28, 50],
        [29, 51]
      ]
    },
    MiniAlu: {
      "v": 5,
      "in": [
        { "pos": [340, 40], "orient": "s", "id": 10, "val": 1 },
        { "pos": [470, 40], "orient": "s", "id": 11, "val": 1 },
        { "pos": [370, 180], "orient": "s", "id": 12, "val": 0 },
        { "pos": [500, 180], "orient": "s", "id": 13, "val": 1 },
        { "pos": [80, 40], "orient": "s", "id": 26, "val": 0 },
        { "pos": [210, 40], "orient": "s", "id": 27, "val": 0 },
        { "pos": [110, 180], "orient": "s", "id": 28, "val": 0 },
        { "pos": [240, 180], "orient": "s", "id": 34, "val": 0 },
        { "pos": [600, 370], "orient": "w", "id": 98, "name": "Add/Sub", "val": 0 }
      ],
      "out": [
        { "pos": [600, 690], "id": 49, "name": "V" },
        { "type": "display", "bits": 4, "pos": [600, 120], "id": [18, 19, 20, 21], "name": "A" },
        { "type": "display", "bits": 4, "pos": [600, 260], "id": [22, 23, 24, 25], "name": "B" },
        { "type": "display", "bits": 4, "pos": [600, 620], "id": [45, 46, 47, 48], "name": "S" }
      ],
      "gates": [
        { "type": "XOR", "pos": [120, 450], "orient": "s", "in": [86, 87], "out": 88 },
        { "type": "XOR", "pos": [250, 450], "orient": "s", "in": [89, 90], "out": 91 },
        { "type": "XOR", "pos": [380, 450], "orient": "s", "in": [92, 93], "out": 94 },
        { "type": "XOR", "pos": [510, 450], "orient": "s", "in": [95, 96], "out": 97 }
      ],
      "ic": [
        { "type": "adder", "pos": [490, 530], "in": [0, 1, 2], "out": [3, 4] },
        { "type": "adder", "pos": [360, 530], "in": [5, 6, 7], "out": [8, 9] },
        { "type": "adder", "pos": [230, 530], "in": [35, 36, 37], "out": [38, 39] },
        { "type": "adder", "pos": [100, 530], "in": [40, 41, 42], "out": [43, 44] }
      ],
      "wires": [
        [4, 7],
        [11, 0],
        [10, 5],
        [11, 18],
        [10, 19],
        [13, 22],
        [12, 23],
        [9, 37],
        [39, 42],
        [3, 45],
        [8, 46],
        [38, 47],
        [43, 48],
        [44, 49, { "via": [[50, 690]] }],
        [27, 35],
        [26, 40],
        [28, 87],
        [34, 90],
        [34, 24],
        [28, 25],
        [27, 20],
        [26, 21],
        [12, 93],
        [13, 96],
        [97, 1],
        [94, 6],
        [91, 36],
        [88, 41],
        [98, 2],
        [98, 95],
        [98, 92],
        [98, 89],
        [98, 86]
      ]
    },
    LatchedAdder: {
      "v": 5,
      "in": [
        { "pos": [340, 570], "orient": "n", "id": 40, "name": "Reset", "val": 0, "isPushButton": true },
        { "pos": [40, 220], "id": 41, "val": 0 },
        { "pos": [40, 250], "id": 42, "val": 0 },
        { "pos": [40, 280], "id": 43, "val": 0 },
        { "pos": [40, 310], "id": 44, "val": 0 },
        { "pos": [280, 570], "orient": "n", "id": 45, "name": "Horloge", "val": 0, "isPushButton": true },
        { "pos": [190, 400], "orient": "n", "id": 60, "name": "Add./soustr.", "val": 0 }
      ],
      "out": [
        { "pos": [550, 380], "id": 61, "name": "V" },
        { "type": "display", "bits": 4, "pos": [100, 390], "orient": "s", "id": [50, 51, 52, 53], "name": "B" },
        { "type": "display", "bits": 4, "pos": [550, 230], "id": [46, 47, 48, 49], "name": "Acc." }
      ],
      "ic": [
        { "type": "alu", "pos": [180, 210], "in": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "out": [10, 11, 12, 13, 14, 15] },
        { "type": "flipflop-d", "pos": [390, 100], "in": [17, 18, 19, 16], "out": [20, 21], "state": 0 },
        { "type": "flipflop-d", "pos": [390, 200], "in": [23, 24, 25, 22], "out": [26, 27], "state": 0 },
        { "type": "flipflop-d", "pos": [390, 300], "in": [29, 30, 31, 28], "out": [32, 33], "state": 0 },
        { "type": "flipflop-d", "pos": [390, 400], "in": [35, 36, 37, 34], "out": [38, 39], "state": 0 },
        { "type": "flipflop-d", "pos": [390, 500], "in": [55, 56, 57, 54], "out": [58, 59], "state": 0 }
      ],
      "wires": [
        [10, 16, { "via": [[260, 80]] }],
        [11, 22, { "via": [[260, 180]] }],
        [12, 28, { "via": [[260, 280]] }],
        [13, 34, { "via": [[260, 380]] }],
        [40, 37, { "via": [[340, 440]] }],
        [40, 31, { "via": [[340, 340, "n"]] }],
        [40, 25, { "via": [[340, 240, "n"]] }],
        [40, 19, { "via": [[340, 140, "n"]] }],
        [20, 0, { "via": [[430, 80], [430, 50], [130, 50], [130, 130]] }],
        [26, 1, { "via": [[440, 180], [440, 40], [120, 40], [120, 150]] }],
        [32, 2, { "via": [[450, 280], [450, 30], [110, 30], [110, 170]] }],
        [38, 3, { "via": [[460, 380, "n"], [460, 20], [100, 20], [100, 190]] }],
        [41, 4],
        [42, 5],
        [43, 6],
        [44, 7],
        [45, 35, { "via": [[280, 420]] }],
        [45, 29, { "via": [[280, 320, "n"]] }],
        [45, 23, { "via": [[280, 220, "n"]] }],
        [45, 17, { "via": [[280, 120, "n"]] }],
        [41, 50],
        [42, 51],
        [43, 52],
        [44, 53],
        [20, 46, { "via": [[480, 80]] }],
        [26, 47, { "via": [[480, 180]] }],
        [32, 48, { "via": [[480, 280]] }],
        [38, 49, { "via": [[480, 380]] }],
        [60, 8, { "via": [[230, 320, "n"], [230, 110, "n"]] }],
        [40, 57],
        [45, 55, { "via": [[280, 520]] }],
        [14, 54, { "via": [[260, 420, "s"], [260, 480]] }],
        [58, 61]
      ]
    },
    LatchedCounter: {
      "v": 5,
      "ic": [
        { "type": "flipflop-d", "pos": [170, 160], "in": [7, 8, 9, 6], "out": [10, 11], "state": 0, "trigger": "falling", "showContent": true },
        { "type": "flipflop-d", "pos": [300, 160], "in": [15, 16, 17, 14], "out": [18, 19], "state": 0, "trigger": "falling", "showContent": true },
        { "type": "flipflop-d", "pos": [440, 160], "in": [21, 22, 23, 20], "out": [24, 25], "state": 0, "trigger": "falling", "showContent": true },
        { "type": "flipflop-d", "pos": [580, 160], "in": [35, 36, 37, 34], "out": [38, 39], "state": 0, "trigger": "falling", "showContent": true }
      ],
      "in": [
        { "pos": [100, 180], "id": 12, "name": "Horloge", "val": 0, "isPushButton": true },
        { "pos": [100, 240], "id": 41, "name": "Reset", "val": 0, "isPushButton": true }
      ],
      "out": [{ "type": "display", "bits": 4, "pos": [660, 60], "id": [26, 27, 28, 29] }],
      "wires": [
        [12, 7],
        [10, 15],
        [18, 21],
        [19, 14],
        [11, 6],
        [25, 20],
        [10, 26, { "via": [[400, 30]] }],
        [18, 27, { "via": [[520, 50]] }],
        [24, 28],
        [39, 34],
        [24, 35],
        [38, 29],
        [41, 9],
        [41, 17],
        [41, 23],
        [41, 37]
      ]
    },
    Decoder2To4: {
      "v": 5,
      "in": [
        { "pos": [60, 80], "id": 0, "name": "S0", "val": 0 },
        { "pos": [60, 220], "id": 1, "name": "S1", "val": 0 }
      ],
      "gates": [
        { "type": "NOT", "pos": [130, 50], "in": 2, "out": 3 },
        { "type": "NOT", "pos": [130, 190], "in": 4, "out": 5 },
        { "type": "AND", "pos": [280, 60], "in": [6, 7], "out": 8 },
        { "type": "AND", "pos": [280, 120], "in": [9, 10], "out": 11 },
        { "type": "AND", "pos": [280, 180], "in": [12, 13], "out": 14 },
        { "type": "AND", "pos": [280, 240], "in": [15, 16], "out": 17 },
        { "type": "BUF", "pos": [130, 110], "in": 22, "out": 23 },
        { "type": "BUF", "pos": [130, 250], "in": 24, "out": 25 }
      ],
      "out": [
        { "pos": [370, 60], "id": 18, "name": "0" },
        { "pos": [370, 120], "id": 19, "name": "1" },
        { "pos": [370, 180], "id": 20, "name": "2" },
        { "pos": [370, 240], "id": 21, "name": "3" }
      ],
      "wires": [
        [0, 2],
        [1, 4],
        [11, 19],
        [17, 21],
        [14, 20],
        [8, 18],
        [3, 6],
        [5, 7],
        [5, 10],
        [3, 12],
        [0, 22],
        [1, 24],
        [23, 9],
        [23, 15],
        [25, 13],
        [25, 16]
      ]
    },
    Decoder3To8: {
      "v": 5,
      "in": [
        { "pos": [60, 130], "id": 26, "name": "S0", "val": 1 },
        { "pos": [60, 290], "id": 27, "name": "S1", "val": 1 },
        { "pos": [60, 460], "id": 28, "name": "S2", "val": 0 }
      ],
      "gates": [
        { "type": "NOT", "pos": [130, 90], "in": 30, "out": 31 },
        { "type": "NOT", "pos": [130, 250], "in": 32, "out": 33 },
        { "type": "NOT", "pos": [130, 420], "in": 34, "out": 35 },
        { "type": "AND", "bits": 3, "pos": [340, 120], "in": [36, 37, 38], "out": 39 },
        { "type": "AND", "bits": 3, "pos": [340, 190], "in": [40, 41, 42], "out": 43 },
        { "type": "AND", "bits": 3, "pos": [340, 260], "in": [44, 45, 46], "out": 47 },
        { "type": "AND", "bits": 3, "pos": [340, 330], "in": [48, 49, 50], "out": 51 },
        { "type": "AND", "bits": 3, "pos": [340, 400], "in": [52, 53, 54], "out": 55 },
        { "type": "AND", "bits": 3, "pos": [340, 470], "in": [56, 57, 58], "out": 59 },
        { "type": "AND", "bits": 3, "pos": [340, 540], "in": [60, 61, 62], "out": 63 },
        { "type": "AND", "bits": 3, "pos": [340, 50], "in": [64, 65, 66], "out": 67 },
        { "type": "BUF", "pos": [130, 170], "in": 76, "out": 77 },
        { "type": "BUF", "pos": [130, 330], "in": 78, "out": 79 },
        { "type": "BUF", "pos": [130, 500], "in": 80, "out": 81 }
      ],
      "out": [
        { "pos": [420, 50], "id": 68, "name": "0" },
        { "pos": [420, 120], "id": 69, "name": "1" },
        { "pos": [420, 190], "id": 70, "name": "2" },
        { "pos": [420, 260], "id": 71, "name": "3" },
        { "pos": [420, 330], "id": 72, "name": "4" },
        { "pos": [420, 400], "id": 73, "name": "5" },
        { "pos": [420, 470], "id": 74, "name": "6" },
        { "pos": [420, 540], "id": 75, "name": "7" }
      ],
      "wires": [
        [26, 30],
        [27, 32],
        [28, 34],
        [67, 68],
        [39, 69],
        [43, 70],
        [47, 71],
        [51, 72],
        [55, 73],
        [59, 74],
        [63, 75],
        [31, 64],
        [33, 65],
        [35, 66],
        [26, 76],
        [27, 78],
        [28, 80],
        [77, 36],
        [33, 37],
        [35, 38],
        [31, 40],
        [79, 41],
        [35, 42],
        [35, 46],
        [79, 45],
        [77, 44],
        [31, 48],
        [77, 52],
        [31, 56],
        [77, 60],
        [33, 49],
        [33, 53],
        [79, 57],
        [79, 61],
        [81, 50],
        [81, 54],
        [81, 58],
        [81, 62]
      ]
    },
    ParityGenerator: {
      "v": 5,
      "in": [
        { "pos": [70, 180], "id": 0, "name": "D1", "val": 0 },
        { "pos": [70, 300], "id": 1, "name": "D2", "val": 0 },
        { "pos": [70, 360], "id": 2, "name": "D3", "val": 0 },
        { "pos": [70, 420], "id": 3, "name": "D4", "val": 0 }
      ],
      "out": [
        { "pos": [530, 60], "id": 4, "name": "P1" },
        { "pos": [530, 120], "id": 5, "name": "P2" },
        { "pos": [530, 180], "id": 6, "name": "D1" },
        { "pos": [530, 240], "id": 7, "name": "P3" },
        { "pos": [530, 300], "id": 8, "name": "D2" },
        { "pos": [530, 360], "id": 9, "name": "D3" },
        { "pos": [530, 420], "id": 10, "name": "D4" }
      ],
      "gates": [
        { "type": "XOR", "pos": [460, 240], "in": [11, 12], "out": 13 },
        { "type": "XOR", "pos": [380, 230], "in": [14, 15], "out": 16 },
        { "type": "XOR", "pos": [340, 120], "in": [17, 18], "out": 19 },
        { "type": "XOR", "pos": [260, 110], "in": [20, 21], "out": 22 },
        { "type": "XOR", "pos": [300, 60], "in": [23, 24], "out": 25 },
        { "type": "XOR", "pos": [220, 40], "in": [26, 27], "out": 28 }
      ],
      "wires": [
        [3, 10],
        [2, 9],
        [1, 8],
        [0, 6],
        [22, 17],
        [16, 11],
        [28, 23],
        [25, 4],
        [19, 5],
        [13, 7],
        [3, 18, { "via": [[280, 420], [280, 130]] }],
        [3, 12, { "via": [[420, 420]] }],
        [2, 15, { "via": [[340, 360]] }],
        [1, 14, { "via": [[310, 300], [310, 220]] }],
        [2, 21, { "via": [[220, 360]] }],
        [0, 20, { "via": [[190, 180], [190, 100]] }],
        [3, 24, { "via": [[150, 420], [150, 70]] }],
        [1, 27, { "via": [[120, 300], [120, 50]] }],
        [0, 26, { "via": [[100, 30]] }]
      ]
    },
    ShiftRegister: {
      "v": 5,
      "in": [
        { "pos": [110, 130], "id": 0, "name": "D", "val": 1 },
        { "pos": [100, 210], "id": 1, "name": "Horloge", "val": 0, "isPushButton": true },
        { "pos": [100, 260], "id": 38, "name": "Reset", "val": 0, "isPushButton": true }
      ],
      "out": [{ "type": "display", "bits": 4, "pos": [650, 60], "id": [39, 40, 41, 42] }],
      "ic": [
        { "type": "flipflop-d", "pos": [560, 150], "in": [21, 22, 23, 20], "out": [24, 25], "state": 1, "showContent": true },
        { "type": "flipflop-d", "pos": [450, 150], "in": [15, 16, 17, 14], "out": [18, 19], "state": 0, "showContent": true },
        { "type": "flipflop-d", "pos": [340, 150], "in": [9, 10, 11, 8], "out": [12, 13], "state": 1, "showContent": true },
        { "type": "flipflop-d", "pos": [230, 150], "in": [3, 4, 5, 2], "out": [6, 7], "state": 1, "showContent": true }
      ],
      "wires": [
        [6, 8],
        [12, 14],
        [18, 20],
        [38, 5, { "via": [[230, 260]] }],
        [38, 11, { "via": [[340, 260]] }],
        [38, 17, { "via": [[450, 260]] }],
        [38, 23, { "via": [[560, 260]] }],
        [1, 21, { "via": [[490, 210]] }],
        [1, 15, { "via": [[380, 210]] }],
        [1, 9, { "via": [[270, 210]] }],
        [1, 3, { "via": [[160, 210]] }],
        [0, 2],
        [24, 39],
        [18, 40, { "via": [[530, 50]] }],
        [12, 41, { "via": [[410, 70]] }],
        [6, 42, { "via": [[300, 90]] }]
      ]
    },
    Muxes: {
      "v": 5,
      "in": [
        { "pos": [160, 70], "orient": "s", "id": 59, "name": "S0", "val": 0 },
        { "pos": [160, 340], "orient": "s", "id": 64, "name": "S0", "val": 0 },
        { "pos": [450, 360], "orient": "s", "id": 69, "name": "S0", "val": 0 },
        { "bits": 4, "pos": [270, 60], "orient": "s", "id": [0, 1, 2, 3], "val": [1, 1, 0, 0] },
        { "bits": 4, "pos": [460, 70], "orient": "s", "id": [60, 61, 62, 63], "val": [0, 0, 0, 0] },
        { "bits": 4, "pos": [270, 300], "orient": "s", "id": [65, 66, 67, 68], "val": [0, 0, 0, 0] },
        { "bits": 4, "pos": [110, 180], "id": [86, 87, 88, 89], "val": [0, 0, 0, 0] },
        { "bits": 4, "pos": [230, 180], "id": [90, 91, 92, 93], "val": [0, 0, 0, 0] },
        { "bits": 4, "pos": [400, 170], "id": [94, 95, 96, 97], "val": [0, 0, 0, 0] },
        { "bits": 4, "pos": [400, 250], "id": [98, 99, 100, 101], "val": [0, 0, 0, 0] },
        { "bits": 4, "pos": [110, 420], "id": [102, 103, 104, 105], "val": [0, 0, 0, 0] },
        { "bits": 4, "pos": [110, 520], "id": [106, 107, 108, 109], "val": [0, 0, 0, 0] },
        { "bits": 4, "pos": [400, 540], "id": [110, 111, 112, 113], "val": [0, 0, 0, 0] },
        { "bits": 4, "pos": [400, 440], "id": [114, 115, 116, 117], "val": [0, 0, 0, 0] },
        { "bits": 4, "pos": [230, 400], "id": [118, 119, 120, 121], "val": [0, 0, 0, 0] },
        { "bits": 4, "pos": [230, 460], "id": [122, 123, 124, 125], "val": [0, 0, 0, 0] },
        { "bits": 4, "pos": [230, 520], "id": [126, 127, 128, 129], "val": [0, 0, 0, 0] },
        { "bits": 4, "pos": [230, 580], "id": [130, 131, 132, 133], "val": [0, 0, 0, 0] }
      ],
      "ic": [
        { "type": "mux", "from": 2, "to": 1, "pos": [160, 160], "in": [5, 6, 7], "out": 8 },
        { "type": "mux", "from": 4, "to": 1, "pos": [290, 180], "in": [4, 9, 10, 11, 12, 13], "out": 14 },
        { "type": "mux", "from": 8, "to": 1, "pos": [470, 210], "in": [15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25], "out": 26 },
        { "type": "mux", "from": 4, "to": 2, "pos": [160, 470], "in": [27, 28, 29, 30, 31], "out": [32, 33] },
        { "type": "mux", "from": 8, "to": 2, "pos": [290, 490], "in": [34, 35, 36, 37, 38, 39, 40, 41, 42, 43], "out": [44, 45] },
        { "type": "mux", "from": 8, "to": 4, "pos": [450, 490], "in": [46, 47, 48, 49, 50, 51, 52, 53, 54], "out": [55, 56, 57, 58] },
        { "type": "alu", "pos": [630, 450], "in": [70, 71, 72, 73, 74, 75, 76, 77, 78, 79], "out": [80, 81, 82, 83, 84, 85] }
      ],
      "wires": [
        [59, 7],
        [0, 12],
        [1, 13],
        [60, 23],
        [61, 24],
        [62, 25],
        [64, 31],
        [65, 42],
        [66, 43],
        [69, 54],
        [86, 5],
        [87, 6],
        [90, 4],
        [91, 9],
        [92, 10],
        [93, 11],
        [94, 15],
        [95, 16],
        [96, 17],
        [97, 18],
        [98, 19],
        [99, 20],
        [100, 21],
        [101, 22],
        [104, 27],
        [105, 28],
        [106, 29],
        [107, 30],
        [110, 50],
        [111, 51],
        [112, 52],
        [113, 53],
        [114, 46],
        [115, 47],
        [116, 48],
        [117, 49],
        [119, 34],
        [120, 35],
        [123, 36],
        [124, 37],
        [127, 38],
        [128, 39],
        [131, 40],
        [132, 41]
      ]
    }
  };

  // simulator/src/LogicEditor.ts
  var Mode2 = /* @__PURE__ */ ((Mode3) => {
    Mode3[Mode3["STATIC"] = 0] = "STATIC";
    Mode3[Mode3["TRYOUT"] = 1] = "TRYOUT";
    Mode3[Mode3["CONNECT"] = 2] = "CONNECT";
    Mode3[Mode3["DESIGN"] = 3] = "DESIGN";
    Mode3[Mode3["FULL"] = 4] = "FULL";
    return Mode3;
  })(Mode2 || {});
  var MIN_MODE_INDEX = 0 /* STATIC */;
  var MAX_MODE_INDEX = 4 /* FULL */;
  var MAX_MODE_WHEN_SINGLETON = 4 /* FULL */;
  var MAX_MODE_WHEN_EMBEDDED = 3 /* DESIGN */;
  var DEFAULT_MODE = 3 /* DESIGN */;
  var ATTRIBUTE_NAMES = {
    lang: "lang",
    singleton: "singleton",
    // whether this is the only editor in the page
    mode: "mode",
    hidereset: "hidereset",
    exportformat: "exportformat",
    // differences between MyST and pymarkdown
    // these are mirrored in the display options
    name: "name",
    showonly: "showonly",
    showgatetypes: "showgatetypes",
    showdisconnectedpins: "showdisconnectedpins",
    showtooltips: "tooltips",
    src: "src",
    data: "data",
    // set on the root div and not the custom element
    modes: "modes",
    // the space-separated list of cumulative modes whose UI elements should be shown
    nomodes: "nomodes"
  };
  var DEFAULT_EDITOR_OPTIONS = {
    name: void 0,
    showOnly: void 0,
    initParams: void 0,
    showGateTypes: false,
    showDisconnectedPins: false,
    wireStyle: WireStyles.auto,
    animateWires: false,
    hideWireColors: false,
    hideInputColors: false,
    hideOutputColors: false,
    hideMemoryContent: false,
    hideTooltips: false,
    groupParallelWires: false,
    showHiddenWires: false,
    showAnchors: false,
    showIDs: false,
    propagationDelay: 100,
    allowPausePropagation: false,
    zoom: 100
  };
  var MouseActions = {
    edit: {
      cursor: null,
      paramTypes: []
    },
    move: {
      cursor: "move",
      paramTypes: []
    },
    delete: {
      cursor: "not-allowed",
      paramTypes: []
    },
    setanchor: {
      cursor: "alias",
      paramTypes: Any
    }
  };
  var _LogicEditor = class extends HTMLElement {
    constructor() {
      super();
      /// Accessible service singletons, defined once per editor ///
      this.factory = new ComponentFactory(this);
      this.eventMgr = new UIEventManager(this);
      this.timeline = new Timeline(this);
      /** EditTools are singleton-meant elements that help the general edition process, independently of
       * whether the editor is showing the main circuit or a CustomComponent. They are thus instantiated
       * only once by the main LogicEditor and can be accessed statically with `editor.editTools.xyz`
       * when needed. If, however, certain actions are done inside a circuit currently not being edited
       * (e.g., a CustomComponent that is closed, or the main circuit when a CustomComponent is open),
       * then use the `ifEditing?.xyz` to avoid having unwanted effects. */
      this.editTools = {
        moveMgr: new MoveManager(this),
        undoMgr: new UndoManager(this),
        redrawMgr: new RedrawManager(),
        testsPalette: new TestsPalette(this),
        setDirty: this.setDirty.bind(this),
        setToolCursor: this.setToolCursor.bind(this)
      };
      this.components = new ComponentList();
      this.nodeMgr = new NodeManager();
      this.testSuites = new TestSuites(this);
      this.linkMgr = new LinkManager(this);
      this.recalcMgr = new RecalcManager();
      this._ifEditing = this.editTools;
      /// Other internal state ///
      this._isEmbedded = false;
      this._isSingleton = false;
      this._maxInstanceMode = MAX_MODE_WHEN_EMBEDDED;
      // can be set later
      this._isDirty = false;
      this._isRunningOrCreatingTests = false;
      // when inputs are being set programmatically over a longer period
      this._dontHogFocus = false;
      this._mode = DEFAULT_MODE;
      this._initialData = void 0;
      this._options = __spreadValues({}, DEFAULT_EDITOR_OPTIONS);
      this._hideResetButton = false;
      this._exportformat = void 0;
      this._menu = void 0;
      this._topBar = void 0;
      this._messageBar = void 0;
      this._toolCursor = null;
      this._highlightedItems = void 0;
      this._nextAnimationFrameHandle = null;
      this._propagationPromise = Promise.resolve();
      this._propagationResolve = void 0;
      this._editorRoot = this;
      this.optionsHtml = void 0;
      this.userdata = void 0;
      this._baseDrawingScale = 1;
      this._actualZoomFactor = 1;
      this.mouseX = -1e3;
      // offscreen at start
      this.mouseY = -1e3;
      this.root = this.attachShadow({ mode: "open" });
      this.root.appendChild(window.Logic.template.content.cloneNode(true));
      const html = {
        rootDiv: this.elemWithId("logicEditorRoot"),
        centerCol: this.elemWithId("centerCol"),
        canvasContainer: this.elemWithId("canvas-sim"),
        mainCanvas: this.elemWithId("mainCanvas"),
        leftToolbar: this.elemWithId("leftToolbar"),
        rightToolbarContainer: this.elemWithId("rightToolbarContainer"),
        rightResetButton: this.elemWithId("rightResetButton"),
        tooltipElem: this.elemWithId("tooltip"),
        tooltipContents: this.elemWithId("tooltipContents"),
        mainContextMenu: this.elemWithId("mainContextMenu"),
        settingsPalette: this.elemWithId("settingsPalette"),
        fileChooser: this.elemWithId("fileChooser"),
        embedDialog: this.elemWithId("embedDialog"),
        embedUrl: this.elemWithId("embedUrl"),
        // embedUrlQRCode: this.elemWithId("embedUrlQRCode"),
        embedIframe: this.elemWithId("embedIframe"),
        embedWebcomp: this.elemWithId("embedWebcomp"),
        embedMarkdown: this.elemWithId("embedMarkdown")
      };
      this.html = html;
      dialog_polyfill_esm_default.registerDialog(html.embedDialog);
    }
    static get allConnectedEditors() {
      return _LogicEditor._allConnectedEditors;
    }
    /// DrawableParent implementation ///
    isMainEditor() {
      return true;
    }
    get editor() {
      return this;
    }
    /** See #editTools */
    get ifEditing() {
      return this._ifEditing;
    }
    stopEditingThis() {
      this._ifEditing = void 0;
    }
    startEditingThis(tools) {
      this._ifEditing = tools;
    }
    /** Either the LogicEditor itself, or a CustomComponent, whichever is being edited right now. */
    get editorRoot() {
      return this._editorRoot;
    }
    elemWithId(id) {
      let elem = this.root.querySelector(`#${id}`);
      if (elem === null) {
        elem = document.querySelector(`#${id}`);
        if (elem !== null) {
          console.log(`WARNING found elem with id ${id} in document rather than in shadow root`);
        }
      }
      if (elem === null) {
        console.log("root", this.root);
        throw new Error(`Could not find element with id '${id}'`);
      }
      return elem;
    }
    static get observedAttributes() {
      return [];
    }
    get mode() {
      return this._mode;
    }
    get actualZoomFactor() {
      return this._actualZoomFactor;
    }
    get isSingleton() {
      return this._isSingleton;
    }
    get options() {
      return this._options;
    }
    get documentDisplayName() {
      var _a;
      return (_a = this._options.name) != null ? _a : S.Settings.DefaultFileName;
    }
    setPartialOptions(opts) {
      var _a, _b;
      const newOptions = __spreadValues(__spreadValues({}, DEFAULT_EDITOR_OPTIONS), opts);
      if (this._isSingleton) {
        newOptions.showOnly = this._options.showOnly;
      }
      this._options = newOptions;
      let optionsHtml;
      if ((optionsHtml = this.optionsHtml) !== void 0) {
        optionsHtml.animateWiresCheckbox.checked = newOptions.animateWires;
        optionsHtml.hideWireColorsCheckbox.checked = newOptions.hideWireColors;
        optionsHtml.hideInputColorsCheckbox.checked = newOptions.hideInputColors;
        optionsHtml.hideOutputColorsCheckbox.checked = newOptions.hideOutputColors;
        optionsHtml.hideMemoryContentCheckbox.checked = newOptions.hideMemoryContent;
        optionsHtml.showGateTypesCheckbox.checked = newOptions.showGateTypes;
        optionsHtml.wireStylePopup.value = newOptions.wireStyle;
        optionsHtml.showDisconnectedPinsCheckbox.checked = newOptions.showDisconnectedPins;
        optionsHtml.hideTooltipsCheckbox.checked = newOptions.hideTooltips;
        optionsHtml.groupParallelWiresCheckbox.checked = newOptions.groupParallelWires;
        optionsHtml.showHiddenWiresCheckbox.checked = newOptions.showHiddenWires;
        optionsHtml.showAnchorsCheckbox.checked = newOptions.showAnchors;
        optionsHtml.showIdsCheckbox.checked = newOptions.showIDs;
        optionsHtml.propagationDelayField.valueAsNumber = newOptions.propagationDelay;
        this.setWindowTitleFrom(newOptions.name);
        (_a = this._topBar) == null ? void 0 : _a.setCircuitName(this.editor.options.name);
        (_b = this._topBar) == null ? void 0 : _b.setZoomLevel(newOptions.zoom);
        optionsHtml.showUserDataLinkContainer.style.display = this.userdata !== void 0 ? "initial" : "none";
      }
      this._actualZoomFactor = clampZoom(newOptions.zoom);
      this.editTools.redrawMgr.requestRedraw({ why: "options changed", invalidateMask: true, invalidateTests: true });
    }
    setWindowTitleFrom(docName) {
      if (!this._isSingleton) {
        return;
      }
      const defaultTitle = "Logic";
      if (docName === void 0) {
        document.title = defaultTitle;
      } else {
        document.title = `${docName} \u2013 ${defaultTitle}`;
      }
    }
    nonDefaultOptions() {
      const nonDefaultOpts = {};
      let set = false;
      for (const [_k, v] of Object.entries(this._options)) {
        const k = _k;
        if (v !== DEFAULT_EDITOR_OPTIONS[k]) {
          nonDefaultOpts[k] = v;
          set = true;
        }
      }
      return set ? nonDefaultOpts : void 0;
    }
    runFileChooser(accept, callback) {
      const chooser = this.html.fileChooser;
      chooser.setAttribute("accept", accept);
      chooser.addEventListener("change", () => {
        const files = this.html.fileChooser.files;
        if (files !== null && files.length > 0) {
          callback(files[0]);
        }
      }, { once: true });
      chooser.click();
    }
    setToolCursor(cursor) {
      this._toolCursor = cursor;
    }
    setCanvasSize() {
      var _a;
      const { canvasContainer, mainCanvas } = this.html;
      mainCanvas.style.setProperty("width", "0");
      mainCanvas.style.setProperty("height", "0");
      const w = canvasContainer.clientWidth;
      const h = canvasContainer.clientHeight;
      const f = (_a = window.devicePixelRatio) != null ? _a : 1;
      mainCanvas.setAttribute("width", String(w * f));
      mainCanvas.setAttribute("height", String(h * f));
      mainCanvas.style.setProperty("width", w + "px");
      mainCanvas.style.setProperty("height", h + "px");
      this._baseDrawingScale = f;
    }
    connectedCallback() {
      if (_LogicEditor._allConnectedEditors.length === 0) {
        this.setupLang();
      }
      _LogicEditor._allConnectedEditors.push(this);
      this.setup();
    }
    disconnectedCallback() {
      const insts = _LogicEditor._allConnectedEditors;
      insts.splice(insts.indexOf(this), 1);
    }
    setupLang() {
      var _a, _b, _c, _d;
      const getNavigatorLanguage = /* @__PURE__ */ __name(() => {
        var _a2, _b2;
        const lang2 = (_b2 = (_a2 = navigator.languages) == null ? void 0 : _a2[0]) != null ? _b2 : navigator.language;
        if (lang2.length > 2) {
          return lang2.substring(0, 2);
        }
        if (lang2.length === 2) {
          return lang2;
        }
        return void 0;
      }, "getNavigatorLanguage");
      const getSavedLang = /* @__PURE__ */ __name(() => {
        return localStorage.getItem(ATTRIBUTE_NAMES.lang);
      }, "getSavedLang");
      const langStr = ((_d = (_c = (_b = (_a = getURLParameter(ATTRIBUTE_NAMES.lang)) != null ? _a : this.getAttribute(ATTRIBUTE_NAMES.lang)) != null ? _b : getSavedLang()) != null ? _c : getNavigatorLanguage()) != null ? _d : DefaultLang).toLowerCase();
      const lang = isLang(langStr) ? langStr : DefaultLang;
      setLang(lang);
    }
    setup() {
      var _a;
      const rootDiv = this.html.rootDiv;
      const parentStyles = this.getAttribute("style");
      if (parentStyles !== null) {
        rootDiv.setAttribute("style", rootDiv.getAttribute("style") + parentStyles);
      }
      this._isEmbedded = isEmbeddedInIframe();
      const singletonAttr = this.getAttribute(ATTRIBUTE_NAMES.singleton);
      this._isSingleton = !this._isEmbedded && singletonAttr !== null && !isFalsyString(singletonAttr);
      this._maxInstanceMode = this._isSingleton && !this._isEmbedded ? MAX_MODE_WHEN_SINGLETON : MAX_MODE_WHEN_EMBEDDED;
      this._exportformat = (_a = this.getAttribute(ATTRIBUTE_NAMES.exportformat)) != null ? _a : void 0;
      if (this._isSingleton || this._isEmbedded) {
        const transferUrlParamToAttribute = /* @__PURE__ */ __name((name2) => {
          const value = getURLParameter(name2);
          if (value !== void 0) {
            this.setAttribute(name2, value);
          }
        }, "transferUrlParamToAttribute");
        for (const attr2 of [
          ATTRIBUTE_NAMES.mode,
          ATTRIBUTE_NAMES.showonly,
          ATTRIBUTE_NAMES.showgatetypes,
          ATTRIBUTE_NAMES.showdisconnectedpins,
          ATTRIBUTE_NAMES.showtooltips,
          ATTRIBUTE_NAMES.data,
          ATTRIBUTE_NAMES.src,
          ATTRIBUTE_NAMES.hidereset
        ]) {
          transferUrlParamToAttribute(attr2);
        }
        const userParamPrefix = "user";
        const url = new URL(window.location.href);
        url.searchParams.forEach((value, key) => {
          if (key.startsWith(userParamPrefix)) {
            key = key.substring(userParamPrefix.length);
            if (key.startsWith(".")) {
              key = key.substring(1);
            }
            if (key.length === 0) {
              this.userdata = value;
            } else {
              key = key[0].toLowerCase() + key.substring(1);
              if (typeof this.userdata !== "object") {
                this.userdata = {};
              }
              if (key in this.userdata) {
                const oldValue = this.userdata[key];
                if (isArray(oldValue)) {
                  oldValue.push(value);
                } else {
                  this.userdata[key] = [oldValue, value];
                }
              } else {
                this.userdata[key] = value;
              }
            }
          }
        });
        if (this.userdata !== void 0) {
          console.log("Custom user data: ", this.userdata);
        }
      }
      if (this._isSingleton) {
        const darkModeQuery = window.matchMedia("(prefers-color-scheme: dark)");
        darkModeQuery.onchange = () => {
          setDarkMode(darkModeQuery.matches, false);
        };
        setDarkMode(darkModeQuery.matches, true);
        window.JSON5 = import_json57.default;
        window.Logic.singleton = this;
        window.load = this.loadCircuitOrLibrary.bind(this);
        window.save = this.save.bind(this);
        window.highlight = this.highlight.bind(this);
        window.logicalTime = () => {
          const time = this.timeline.logicalTime();
          return time;
        };
        const madeBy = div(
          cls("noselect"),
          style("position: absolute; bottom: 0; right: 0; padding: 5px 3px 2px 5px; color: rgba(128,128,128,0.2); border-radius: 10px 0 0 0; font-size: 69%; font-style: italic;"),
          S.Messages.DevelopedBy + " ",
          a(
            style("color: inherit"),
            href("https://github.com/jppellet/Logic-Circuit-Simulator"),
            target("_blank"),
            "Jean-Philippe Pellet"
          ),
          ", ",
          a(
            style("color: inherit"),
            href("https://www.hepl.ch/accueil/formation/unites-enseignement-et-recherche/medias-usages-numeriques-et-didactique-de-linformatique.html"),
            target("_blank"),
            "HEP Vaud"
          )
        ).render();
        this.html.canvasContainer.insertAdjacentElement("afterbegin", madeBy);
        window.onbeforeunload = (e) => {
          if (this._isSingleton && this._isDirty && this.mode >= 2 /* CONNECT */) {
            e.preventDefault();
            e.returnValue = S.Messages.ReallyCloseWindow;
          }
        };
        this.addEventListener("focusout", () => {
          if (!this._dontHogFocus) {
            this.focus();
          }
        });
        this.focus();
      }
      let modeAttr = this.getAttribute(ATTRIBUTE_NAMES.mode);
      if (modeAttr !== null && (modeAttr = modeAttr.toUpperCase()) in Mode2) {
        this._maxInstanceMode = Mode2[modeAttr];
      }
      const showonlyAttr = this.getAttribute(ATTRIBUTE_NAMES.showonly);
      if (showonlyAttr !== null) {
        this._options.showOnly = showonlyAttr.toLowerCase().split(/[, +]+/).filter((x) => x.trim());
      }
      const showgatetypesAttr = this.getAttribute(ATTRIBUTE_NAMES.showgatetypes);
      if (showgatetypesAttr !== null) {
        this._options.showGateTypes = isTruthyString(showgatetypesAttr);
      }
      const showdisconnectedpinsAttr = this.getAttribute(ATTRIBUTE_NAMES.showdisconnectedpins);
      if (showdisconnectedpinsAttr !== null) {
        this._options.showDisconnectedPins = isTruthyString(showdisconnectedpinsAttr);
      }
      const showtooltipsAttr = this.getAttribute(ATTRIBUTE_NAMES.showtooltips);
      if (showtooltipsAttr !== null) {
        this._options.hideTooltips = !isFalsyString(showtooltipsAttr);
      }
      this._hideResetButton = this.getAttribute(ATTRIBUTE_NAMES.hidereset) !== null && !isFalsyString(this.getAttribute(ATTRIBUTE_NAMES.hidereset));
      let dataOrSrcRef;
      if ((dataOrSrcRef = this.getAttribute(ATTRIBUTE_NAMES.data)) !== null) {
        this._initialData = { _type: "compressed", str: dataOrSrcRef };
      } else if ((dataOrSrcRef = this.getAttribute(ATTRIBUTE_NAMES.src)) !== null) {
        this._initialData = { _type: "url", url: dataOrSrcRef };
      } else {
        const tryLoadFromLightDOM = /* @__PURE__ */ __name(() => {
          const innerScriptElem = this.findLightDOMChild("script");
          if (innerScriptElem !== null) {
            this._initialData = { _type: "json", json: innerScriptElem.innerHTML };
            innerScriptElem.remove();
            this.tryLoadCircuitFromData();
            this.doRedraw(true);
            return true;
          } else {
            return false;
          }
        }, "tryLoadFromLightDOM");
        setTimeout(() => {
          const loaded = tryLoadFromLightDOM();
          if (!loaded) {
            setTimeout(() => {
              tryLoadFromLightDOM();
            }, 100);
          }
        });
      }
      const setCaption = /* @__PURE__ */ __name((buttonId, strings) => {
        const elem = this.elemWithId(buttonId);
        const [name2, tooltip] = isString(strings) ? [strings, void 0] : strings;
        elem.insertAdjacentText("beforeend", name2);
        if (tooltip !== void 0) {
          elem.setAttribute("title", tooltip);
        }
      }, "setCaption");
      const s = S.Dialogs.Share;
      setCaption("shareDialogTitle", s.title);
      setCaption("shareDialogUrl", s.URL);
      setCaption("shareDialogIframe", s.EmbedInIframe);
      setCaption("shareDialogWebComp", s.EmbedWithWebComp);
      setCaption("shareDialogMarkdown", s.EmbedInMarkdown);
      setCaption("shareDialogClose", S.Dialogs.Generic.Close);
      this._topBar = new TopBar(this);
      this._menu = new ComponentMenu(this, this.html.leftToolbar);
      this._messageBar = new MessageBar(this);
      const testResultsPalette = this.elemWithId("testResultsPalette");
      testResultsPalette.parentElement.replaceChild(this.editTools.testsPalette.rootElem, testResultsPalette);
      const groupButton = this.html.leftToolbar.querySelector("button.sim-component-button[data-type=rect]");
      if (groupButton === null) {
        if (this._options.showOnly === void 0) {
          console.log("ERROR: Could not find group button");
        }
      } else {
        groupButton.addEventListener("mousedown", this.wrapHandler((e) => {
          const success2 = this.makeGroupWithSelection();
          if (success2) {
            e.preventDefault();
            e.stopImmediatePropagation();
          }
        }));
      }
      this.eventMgr.registerCanvasListenersOn(this.html.mainCanvas);
      this.eventMgr.registerButtonListenersOn(this._menu.allFixedButtons(), false);
      this.html.rightResetButton.addEventListener("click", this.wrapHandler(this.resetCircuit.bind(this)));
      const showModeChange = this._maxInstanceMode >= 4 /* FULL */;
      if (showModeChange) {
        const modeChangeMenu = this.elemWithId("modeChangeMenu");
        const titleElem = div(
          cls("toolbar-title"),
          "Mode"
        ).render();
        this.eventMgr.registerTitleDragListenersOn(titleElem);
        mods(
          titleElem,
          div(
            cls("btn-group-vertical"),
            ...[4 /* FULL */, 3 /* DESIGN */, 2 /* CONNECT */, 1 /* TRYOUT */, 0 /* STATIC */].map((buttonMode) => {
              const [[modeTitle, expl], addElem] = (() => {
                switch (buttonMode) {
                  case 4 /* FULL */: {
                    const optionsDiv = div(
                      cls("sim-mode-link"),
                      title(S.Settings.Settings),
                      makeIcon("settings")
                    ).render();
                    optionsDiv.addEventListener("click", () => {
                      toggleVisible(this.html.settingsPalette);
                    });
                    return [S.Modes.FULL, optionsDiv];
                  }
                  case 3 /* DESIGN */:
                    return [S.Modes.DESIGN, emptyMod];
                  case 2 /* CONNECT */:
                    return [S.Modes.CONNECT, emptyMod];
                  case 1 /* TRYOUT */:
                    return [S.Modes.TRYOUT, emptyMod];
                  case 0 /* STATIC */:
                    return [S.Modes.STATIC, emptyMod];
                }
              })();
              const copyLinkDiv = div(
                cls("sim-mode-link"),
                title("Copie un lien vers ce contenu dans ce mode"),
                makeIcon("link")
              ).render();
              copyLinkDiv.addEventListener("click", (__) => {
                this.shareSheetForMode(buttonMode);
              });
              const switchToModeDiv = div(
                cls("btn btn-sm btn-outline-light sim-toolbar-button-right sim-mode-tool"),
                style("display: flex; justify-content: space-between; align-items: center"),
                attrBuilder("mode")(Mode2[buttonMode].toLowerCase()),
                title(expl),
                modeTitle,
                addElem,
                copyLinkDiv
              ).render();
              switchToModeDiv.addEventListener("click", () => this.setMode(buttonMode, true));
              return switchToModeDiv;
            })
          )
        ).applyTo(modeChangeMenu);
        setVisible(modeChangeMenu, true);
      }
      const selectAllListener = /* @__PURE__ */ __name((e) => {
        const textArea = e.target;
        textArea.focus();
        textArea.select();
        e.preventDefault();
      }, "selectAllListener");
      for (const textArea of [this.html.embedUrl, this.html.embedIframe, this.html.embedWebcomp, this.html.embedMarkdown]) {
        textArea.addEventListener("pointerdown", selectAllListener);
        textArea.addEventListener("focus", selectAllListener);
      }
      this.setCurrentMouseAction("edit", true);
      this.timeline.reset();
      const settingsPalette = this.html.settingsPalette;
      const settingsTitleElem = div(cls("toolbar-title with-border"), S.Settings.Settings).render();
      this.eventMgr.registerTitleDragListenersOn(settingsTitleElem, () => {
        setVisible(settingsPalette, false);
      });
      settingsPalette.insertAdjacentElement("afterbegin", settingsTitleElem);
      const makeCheckbox = /* @__PURE__ */ __name((optionName, [title2, mouseover], hide2 = false) => {
        const checkbox = input(type("checkbox")).render();
        if (this.options[optionName] === true) {
          checkbox.checked = true;
        }
        checkbox.addEventListener("change", this.wrapHandler(() => {
          this._options[optionName] = checkbox.checked;
          this.editTools.redrawMgr.requestRedraw({ why: "option changed: " + optionName, invalidateMask: true, invalidateTests: true });
          this.focus();
        }));
        const section = div(
          style("height: 20px"),
          label(checkbox, span(style("margin-left: 4px"), attr("title", mouseover), title2))
        ).render();
        settingsPalette.appendChild(section);
        if (hide2) {
          setVisible(section, false);
        }
        return checkbox;
      }, "makeCheckbox");
      const animateWiresCheckbox = makeCheckbox("animateWires", S.Settings.animateWires);
      const hideWireColorsCheckbox = makeCheckbox("hideWireColors", S.Settings.hideWireColors);
      const hideInputColorsCheckbox = makeCheckbox("hideInputColors", S.Settings.hideInputColors);
      const hideOutputColorsCheckbox = makeCheckbox("hideOutputColors", S.Settings.hideOutputColors);
      const hideMemoryContentCheckbox = makeCheckbox("hideMemoryContent", S.Settings.hideMemoryContent);
      const showGateTypesCheckbox = makeCheckbox("showGateTypes", S.Settings.showGateTypes);
      const showDisconnectedPinsCheckbox = makeCheckbox("showDisconnectedPins", S.Settings.showDisconnectedPins);
      const hideTooltipsCheckbox = makeCheckbox("hideTooltips", S.Settings.hideTooltips);
      const groupParallelWiresCheckbox = makeCheckbox("groupParallelWires", S.Settings.groupParallelWires, true);
      const showHiddenWiresCheckbox = makeCheckbox("showHiddenWires", S.Settings.showHiddenWires);
      const showAnchorsCheckbox = makeCheckbox("showAnchors", S.Settings.showAnchors);
      const showIdsCheckbox = makeCheckbox("showIDs", S.Settings.showIds);
      const sw = S.Components.Wire.contextMenu;
      const wireStylePopup = select(
        option(attr("value", WireStyles.auto), sw.WireStyleAuto),
        option(attr("value", WireStyles.straight), sw.WireStyleStraight),
        option(attr("value", WireStyles.hv), sw.WireStyleSquareHV),
        option(attr("value", WireStyles.vh), sw.WireStyleSquareVH),
        option(attr("value", WireStyles.bezier), sw.WireStyleCurved)
      ).render();
      wireStylePopup.addEventListener("change", this.wrapHandler(() => {
        this._options.wireStyle = wireStylePopup.value;
        this.linkMgr.invalidateAllWirePaths();
        this.editTools.redrawMgr.requestRedraw({ why: "wire style changed", invalidateMask: true });
      }));
      settingsPalette.appendChild(
        div(
          style("height: 20px"),
          S.Settings.wireStyle + " ",
          wireStylePopup
        ).render()
      );
      const propagationDelayField = input(
        type("number"),
        style("margin: 0 4px; width: 4em"),
        attr("min", "0"),
        attr("step", "50"),
        attr("value", String(this.options.propagationDelay)),
        attr("title", S.Settings.propagationDelay)
      ).render();
      propagationDelayField.addEventListener("change", () => {
        this._options.propagationDelay = propagationDelayField.valueAsNumber;
      });
      settingsPalette.appendChild(
        div(
          style("height: 20px"),
          S.Settings.propagationDelayField[0],
          propagationDelayField,
          S.Settings.propagationDelayField[1]
        ).render()
      );
      const showUserdataLink = a(S.Settings.showUserDataLink[1], style("text-decoration: underline; cursor: pointer")).render();
      showUserdataLink.addEventListener("click", () => {
        alert(S.Settings.userDataHeader + "\n\n" + import_json57.default.stringify(this.userdata, void 0, 4));
      });
      const showUserDataLinkContainer = div(
        style("margin-top: 5px; display: none"),
        S.Settings.showUserDataLink[0],
        showUserdataLink
      ).render();
      settingsPalette.appendChild(showUserDataLinkContainer);
      this.optionsHtml = {
        animateWiresCheckbox,
        hideWireColorsCheckbox,
        hideInputColorsCheckbox,
        hideOutputColorsCheckbox,
        hideMemoryContentCheckbox,
        wireStylePopup,
        showGateTypesCheckbox,
        showDisconnectedPinsCheckbox,
        hideTooltipsCheckbox,
        groupParallelWiresCheckbox,
        showHiddenWiresCheckbox,
        showAnchorsCheckbox,
        showIdsCheckbox,
        propagationDelayField,
        showUserDataLinkContainer
      };
      this.setCanvasSize();
      onVisible(this.html.canvasContainer, () => {
        this.redraw();
      });
      this.tryLoadCircuitFromData();
      this.setModeFromString(this.getAttribute(ATTRIBUTE_NAMES.mode));
      this.setCanvasSize();
      _LogicEditor.installGlobalListeners();
      this.doRedraw(true);
    }
    findLightDOMChild(tagName) {
      const TAGNAME = tagName.toUpperCase();
      for (const child of this.children) {
        if (child.tagName === TAGNAME) {
          return child;
        }
      }
      return null;
    }
    static installGlobalListeners() {
      if (_LogicEditor._globalListenersInstalled) {
        return;
      }
      window.decompress = LZString.decompressFromEncodedURIComponent;
      window.decodeOld = _LogicEditor.decodeFromURLOld;
      window.formatString = formatString;
      window.gallery = gallery;
      window.addEventListener("mousemove", (e) => {
        for (const editor of _LogicEditor._allConnectedEditors) {
          const canvasContainer = editor.html.canvasContainer;
          if (canvasContainer !== void 0) {
            const canvasPos = canvasContainer.getBoundingClientRect();
            editor.mouseX = e.clientX - canvasPos.left;
            editor.mouseY = e.clientY - canvasPos.top;
          }
        }
      }, true);
      window.addEventListener("resize", () => {
        for (const editor of _LogicEditor._allConnectedEditors) {
          const canvasContainer = editor.html.canvasContainer;
          if (canvasContainer !== void 0) {
            editor.wrapHandler(() => {
              editor.setCanvasSize();
              editor.editTools.redrawMgr.requestRedraw({ why: "window resized", invalidateMask: true });
            })();
          }
        }
        registerPixelRatioListener();
      });
      let pixelRatioMediaQuery;
      const registerPixelRatioListener = /* @__PURE__ */ __name(() => {
        if (pixelRatioMediaQuery !== void 0) {
          pixelRatioMediaQuery.onchange = null;
        }
        const queryString = `(resolution: ${window.devicePixelRatio}dppx)`;
        pixelRatioMediaQuery = window.matchMedia(queryString);
        pixelRatioMediaQuery.onchange = () => {
          for (const editor of _LogicEditor._allConnectedEditors) {
            editor.wrapHandler(() => {
              editor.setCanvasSize();
              editor.editTools.redrawMgr.requestRedraw({ why: "devicePixelRatio changed", invalidateMask: true });
            })();
          }
          registerPixelRatioListener();
        };
      }, "registerPixelRatioListener");
      registerPixelRatioListener();
      document.body.addEventListener("themechanged", (e) => {
        var _a;
        const isDark = Boolean((_a = e.detail) == null ? void 0 : _a.is_dark_theme);
        setDarkMode(isDark, false);
      });
      const mkdocsThemeObserver = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
          if (mutation.type === "attributes" && mutation.attributeName === "data-md-color-switching" && document.body.getAttribute("data-md-color-switching") === null) {
            const newBackgroundColor = getComputedStyle(document.body).backgroundColor;
            console.log("Logic: looks like new background color is " + newBackgroundColor);
            window.Logic.setDarkMode(newBackgroundColor);
          }
        });
      });
      mkdocsThemeObserver.observe(document.body, { attributes: true });
      _LogicEditor._globalListenersInstalled = true;
    }
    setMode(mode, doSetFocus) {
      this.wrapHandler(() => {
        var _a;
        let modeStr = Mode2[mode].toLowerCase();
        if (mode > this._maxInstanceMode) {
          mode = this._maxInstanceMode;
          console.log(`Cannot switch to mode ${modeStr} because we are capped by ${Mode2[this._maxInstanceMode]}`);
          modeStr = Mode2[mode].toLowerCase();
        }
        this._mode = mode;
        const modes = [];
        for (let i2 = MIN_MODE_INDEX; i2 <= mode; i2++) {
          modes.push(Mode2[i2].toLowerCase());
        }
        this.html.rootDiv.setAttribute(ATTRIBUTE_NAMES.modes, modes.join(" "));
        const nomodes = [];
        for (let i2 = mode + 1; i2 <= MAX_MODE_INDEX; i2++) {
          nomodes.push(Mode2[i2].toLowerCase());
        }
        this.html.rootDiv.setAttribute(ATTRIBUTE_NAMES.nomodes, nomodes.join(" "));
        this.editTools.redrawMgr.requestRedraw({ why: "mode changed", invalidateMask: true });
        this.root.querySelectorAll(".sim-mode-tool").forEach((elem) => {
          if (elem.getAttribute("mode") === modeStr) {
            elem.classList.add("active");
          } else {
            elem.classList.remove("active");
          }
        });
        if (mode < 2 /* CONNECT */) {
          this.setCurrentMouseAction("edit");
        }
        const showComponentsAndEditControls = mode >= 3 /* DESIGN */ ? "show" : this._maxInstanceMode >= 3 /* DESIGN */ ? "inactive" : "hide";
        const showEditControls = showComponentsAndEditControls === "show";
        const showReset = mode >= 1 /* TRYOUT */ && !this._hideResetButton;
        const showOnlyReset = showReset && !showEditControls;
        const hideSettings = mode < 4 /* FULL */;
        (_a = this._topBar) == null ? void 0 : _a.setButtonStateFromMode({ showComponentsAndEditControls, showReset }, mode);
        setVisible(this.html.rightToolbarContainer, showOnlyReset);
        if (hideSettings) {
          setVisible(this.html.settingsPalette, false);
        }
        setDisplay(this.html.leftToolbar, showComponentsAndEditControls);
        if (mode < 2 /* CONNECT */) {
          this.setTestsPaletteVisible(false);
        } else {
          this.didLoadTests(this.testSuites);
        }
        if (doSetFocus) {
          this.focus();
        }
      })();
    }
    setModeFromString(modeStr) {
      let mode = this._maxInstanceMode;
      if (modeStr !== null && (modeStr = modeStr.toUpperCase()) in Mode2) {
        mode = Mode2[modeStr];
      }
      this.setMode(mode, false);
    }
    setCircuitName(name2) {
      var _a;
      this._options.name = name2 === void 0 || name2.length === 0 ? void 0 : name2;
      (_a = this._topBar) == null ? void 0 : _a.setCircuitName(name2);
      this.setWindowTitleFrom(this._options.name);
    }
    setZoomLevel(zoom) {
      this._options.zoom = zoom;
      this._actualZoomFactor = clampZoom(zoom);
      this.editTools.redrawMgr.requestRedraw({ why: "zoom level changed", invalidateMask: true });
    }
    updateCustomComponentButtons() {
      var _a;
      if (this._menu !== void 0) {
        this._menu.updateCustomComponentButtons(this.factory.customDefs());
        this.eventMgr.registerButtonListenersOn(this._menu.allCustomButtons(), true);
      }
      (_a = this._topBar) == null ? void 0 : _a.updateCustomComponentCaption();
    }
    allowGateType(type7) {
      var _a, _b;
      return (_b = (_a = this._menu) == null ? void 0 : _a.allowGateType(type7)) != null ? _b : true;
    }
    focus() {
      this.html.mainCanvas.focus();
    }
    tryLoadFrom(file) {
      if (file.type === "application/json" || file.type === "application/json5" || file.type === "text/plain") {
        const reader = new FileReader();
        reader.onload = () => {
          var _a;
          const content = (_a = reader.result) == null ? void 0 : _a.toString();
          if (content !== void 0) {
            this.loadCircuitOrLibrary(content);
          }
        };
        reader.readAsText(file, "utf-8");
      } else if (file.type === "image/png") {
        const reader = new FileReader();
        reader.onload = () => {
          var _a;
          const content = reader.result;
          if (content instanceof ArrayBuffer) {
            const uintArray2 = new Uint8Array(content);
            const pngMetadata = pngMeta.readMetadata(uintArray2);
            const compressedJSON = (_a = pngMetadata.tEXt) == null ? void 0 : _a.Description;
            if (isString(compressedJSON)) {
              this._initialData = { _type: "compressed", str: compressedJSON };
              this.wrapHandler(() => {
                this.tryLoadCircuitFromData();
              })();
            }
          }
        };
        reader.readAsArrayBuffer(file);
      } else if (file.type === "image/svg+xml") {
        const reader = new FileReader();
        reader.onload = (e) => {
          var _a, _b;
          const content = (_b = (_a = e.target) == null ? void 0 : _a.result) == null ? void 0 : _b.toString();
          if (content !== void 0) {
            const temp = document.createElement("div");
            temp.innerHTML = content;
            const metadata = temp.querySelector("svg metadata");
            const json = metadata == null ? void 0 : metadata.textContent;
            temp.remove();
            if (json !== void 0 && json !== null) {
              this.loadCircuitOrLibrary(json);
            }
          }
        };
        reader.readAsText(file, "utf-8");
      } else {
        this.showMessage(S.Messages.UnsupportedFileType.expand({ type: file.type }));
      }
    }
    tryLoadCircuitFromData() {
      var _a;
      if (this._initialData === void 0) {
        return;
      }
      if (this._initialData._type === "url") {
        const url = this._initialData.url;
        fetch(url, { mode: "cors" }).then((response) => response.text()).then((json) => {
          console.log(`Loaded initial data from URL '${url}'`);
          this._initialData = { _type: "json", json };
          this.tryLoadCircuitFromData();
        });
        return;
      }
      let error = void 0;
      if (this._initialData._type === "json") {
        try {
          error = Serialization.loadCircuitOrLibrary(this, this._initialData.json);
        } catch (e) {
          error = String(e) + " (JSON)";
        }
      } else {
        let decodedData;
        try {
          decodedData = LZString.decompressFromEncodedURIComponent(this._initialData.str);
          if (this._initialData.str.length !== 0 && ((_a = decodedData == null ? void 0 : decodedData.length) != null ? _a : 0) === 0) {
            throw new Error("zero decoded length");
          }
        } catch (err) {
          error = String(err) + " (LZString)";
          try {
            decodedData = _LogicEditor.decodeFromURLOld(this._initialData.str);
            error = void 0;
          } catch (e) {
          }
        }
        if (error === void 0 && isString(decodedData)) {
          error = Serialization.loadCircuitOrLibrary(this, decodedData);
          if (error === void 0) {
            this._initialData = { _type: "json", json: decodedData };
          }
        }
      }
      if (error !== void 0) {
        console.log("ERROR could not not load initial data: " + error);
      } else {
        this.clearDirty();
      }
    }
    resetCircuit() {
      this.editor.tryLoadCircuitFromData();
    }
    tryCloseCustomComponentEditor() {
      const editorRoot = this.editor.editorRoot;
      if (!(editorRoot instanceof CustomComponent)) {
        return false;
      }
      const def = editorRoot.customDef;
      const error = this.editor.factory.tryModifyCustomComponent(def, editorRoot);
      if (error !== void 0) {
        if (error.length !== 0) {
          window.alert(error);
        }
        return true;
      }
      for (const type7 of this.factory.getCustomComponentTypesWhichUse(def.type)) {
        this.components.updateCustomComponents(type7);
      }
      this.setEditorRoot(this.editor);
      this.editTools.undoMgr.takeSnapshot();
      return true;
    }
    loadCircuitOrLibrary(jsonStringOrObject) {
      this.wrapHandler(
        (jsonStringOrObject2) => Serialization.loadCircuitOrLibrary(this, jsonStringOrObject2)
      )(jsonStringOrObject);
    }
    makeGroupWithSelection() {
      var _a;
      const selectedComps = ((_a = this.eventMgr.currentSelection) == null ? void 0 : _a.previouslySelectedElements) || /* @__PURE__ */ new Set();
      if (selectedComps.size === 0) {
        return false;
      }
      const newGroup = RectangleDef.make(this);
      newGroup.setSpawned();
      if (newGroup instanceof Rectangle) {
        newGroup.wrapContents(selectedComps);
        for (const comp of selectedComps) {
          if (comp instanceof DrawableWithDraggablePosition && comp.anchor === void 0) {
            comp.anchor = newGroup;
          }
        }
      } else {
        console.log("ERROR: created component is not a Rectangle");
      }
      return true;
    }
    setDirty(__reason) {
      var _a;
      if (this.mode >= 2 /* CONNECT */) {
        this._isDirty = true;
        (_a = this._topBar) == null ? void 0 : _a.setDirty(true);
      }
    }
    clearDirty() {
      var _a;
      this._isDirty = false;
      (_a = this._topBar) == null ? void 0 : _a.setDirty(false);
    }
    setDark(dark) {
      this.html.rootDiv.classList.toggle("dark", dark);
    }
    setEditorRoot(newRoot) {
      var _a, _b;
      if (newRoot === this._editorRoot) {
        return;
      }
      if (this._editorRoot !== void 0) {
        this._editorRoot.stopEditingThis();
      }
      this._editorRoot = newRoot;
      newRoot.startEditingThis(this.editTools);
      const [customComp, typesToHide] = !(newRoot instanceof CustomComponent) ? [void 0, []] : [newRoot, this.factory.getCustomComponentTypesWhichUse(newRoot.customDef.type)];
      (_a = this._menu) == null ? void 0 : _a.setCustomComponentsHidden(typesToHide);
      (_b = this._topBar) == null ? void 0 : _b.setEditingCustomComponent(customComp == null ? void 0 : customComp.customDef);
      this._highlightedItems = void 0;
      this.eventMgr.currentSelection = void 0;
      this.eventMgr.clearPopperIfNecessary();
      this.eventMgr.updateMouseOver([this.mouseX, this.mouseY], false, false);
      this.editTools.testsPalette.update();
      this.editTools.moveMgr.clear();
      this.editTools.redrawMgr.requestRedraw({ why: "editor root changed", invalidateMask: true, invalidateTests: true });
      this.focus();
    }
    setCurrentMouseAction(action, forceUpdate = false, ...params) {
      var _a;
      const changed = this.eventMgr.setHandlersFor(action, ...params);
      if (forceUpdate || changed) {
        this.setToolCursor(MouseActions[action].cursor);
        (_a = this._topBar) == null ? void 0 : _a.updateActiveTool(action);
        this.editTools.redrawMgr.requestRedraw({ why: "mouse action changed" });
        this.editor.focus();
      }
      return changed;
    }
    updateCursor(e) {
      var _a, _b, _c;
      const cursor = this.editTools.moveMgr.areDrawablesMoving() ? "grabbing" : (_c = (_b = this._toolCursor) != null ? _b : (_a = this.eventMgr.currentMouseOverComp) == null ? void 0 : _a.cursorWhenMouseover(e)) != null ? _c : "default";
      this.html.canvasContainer.style.cursor = cursor;
    }
    showMessage(msg, duration = 2e3) {
      var _a, _b;
      return (_b = (_a = this._messageBar) == null ? void 0 : _a.showMessage(msg, duration)) != null ? _b : () => void 0;
    }
    offsetXYForContextMenu(e, snapToGrid = false) {
      const mainCanvas = this.html.mainCanvas;
      let x, y;
      if ("offsetX" in e && e.offsetX === 0 && e.offsetY === 0 && e.target === mainCanvas) {
        const canvasRect = mainCanvas.getBoundingClientRect();
        x = e.clientX - canvasRect.x;
        y = e.clientY - canvasRect.y;
      } else if ("dragStartX" in e) {
        return [e.dragStartX, e.dragStartY];
      } else {
        [x, y] = this.offsetXY(e);
      }
      if (snapToGrid) {
        x = Math.round(x / GRID_STEP) * GRID_STEP;
        y = Math.round(y / GRID_STEP) * GRID_STEP;
      }
      return [x, y];
    }
    offsetXY(e, skipScaling = false) {
      const [unscaledX, unscaledY] = (() => {
        const mainCanvas = this.html.mainCanvas;
        let target2 = e.target;
        if ("offsetX" in e) {
          const canvasRect = mainCanvas.getBoundingClientRect();
          let offsetX = e.offsetX;
          let offsetY = e.offsetY;
          if (offsetX === 0 && offsetY === 0) {
            const _e = e;
            if ("_savedOffsetX" in _e) {
              offsetX = _e._savedOffsetX;
              offsetY = _e._savedOffsetY;
              target2 = _e._savedTarget;
            } else if ("layerX" in e) {
              offsetX = _e.layerX + canvasRect.x;
              offsetY = _e.layerY + canvasRect.y;
            }
          }
          if (target2 === mainCanvas) {
            return [offsetX, offsetY];
          } else {
            const elemRect = target2.getBoundingClientRect();
            return [
              Math.max(GRID_STEP * 2, offsetX + elemRect.x - canvasRect.x),
              Math.max(GRID_STEP * 2, offsetY + elemRect.y - canvasRect.y)
            ];
          }
        } else {
          const elemRect = target2.getBoundingClientRect();
          const bodyRect = document.body.getBoundingClientRect();
          const touch = e.changedTouches[0];
          const offsetX = touch.pageX - (elemRect.left - bodyRect.left);
          const offsetY = touch.pageY - (elemRect.top - bodyRect.top);
          if (target2 === mainCanvas) {
            return [offsetX, offsetY];
          } else {
            const canvasRect = mainCanvas.getBoundingClientRect();
            return [
              Math.max(GRID_STEP * 2, offsetX + elemRect.x - canvasRect.x),
              Math.max(GRID_STEP * 2, offsetY + elemRect.y - canvasRect.y)
            ];
          }
        }
      })();
      const currentScale = skipScaling ? 1 : this._actualZoomFactor;
      return [unscaledX / currentScale, unscaledY / currentScale];
    }
    offsetXYForComponent(e, comp) {
      const offset2 = this.offsetXY(e);
      if (comp.orient === Orientation.default) {
        return offset2;
      }
      const [x, y] = offset2;
      const dx = x - comp.posX;
      const dy = y - comp.posY;
      switch (comp.orient) {
        case "e":
          return offset2;
        case "w":
          return [comp.posX - dx, comp.posY - dy];
        case "s":
          return [comp.posX - dy, comp.posY - dx];
        case "n":
          return [comp.posX + dy, comp.posY + dx];
      }
    }
    guessAdequateCanvasSize(applyZoom) {
      let rightmostX = Number.NEGATIVE_INFINITY, leftmostX = Number.POSITIVE_INFINITY;
      let lowestY = Number.NEGATIVE_INFINITY, highestY = Number.POSITIVE_INFINITY;
      const drawables = [...this.editorRoot.components.all()];
      for (const wire of this.linkMgr.wires) {
        drawables.push(...wire.waypoints);
      }
      for (const comp of drawables) {
        const cx = comp.posX;
        const width = comp.width;
        const left2 = cx - width / 2;
        const right2 = left2 + width;
        if (right2 > rightmostX) {
          rightmostX = right2;
        }
        if (left2 < leftmostX) {
          leftmostX = left2;
        }
        const cy = comp.posY;
        const height = comp.height;
        const top2 = cy - height / 2;
        const bottom2 = top2 + height;
        if (bottom2 > lowestY) {
          lowestY = bottom2;
        }
        if (top2 < highestY) {
          highestY = top2;
        }
      }
      leftmostX = Math.max(0, leftmostX);
      let w = rightmostX + leftmostX;
      if (isNaN(w)) {
        w = 300;
      }
      highestY = Math.max(0, highestY);
      let h = highestY + lowestY;
      if (isNaN(h)) {
        h = 150;
      }
      const f = applyZoom ? this._actualZoomFactor : 1;
      return [f * w, f * h];
    }
    shareSheetForMode(mode) {
      return __async(this, null, function* () {
        if (this._mode > MAX_MODE_WHEN_EMBEDDED) {
          this._mode = MAX_MODE_WHEN_EMBEDDED;
        }
        const modeStr = Mode2[mode].toLowerCase();
        const { fullJson, compressedJsonForUri, showOnlyArr } = this.fullJsonStateAndCompressedForUri(true);
        console.log("JSON:\n" + fullJson);
        const fullUrl = this.fullUrlForMode(mode, compressedJsonForUri, showOnlyArr);
        this.html.embedUrl.value = fullUrl;
        const modeParam = mode === MAX_MODE_WHEN_EMBEDDED ? "" : `:mode: ${modeStr}`;
        const embedHeight = this.guessAdequateCanvasSize(true)[1];
        const showOnlySpaceDelim = showOnlyArr === void 0 ? void 0 : showOnlyArr.join(" ");
        const markdownBlock = this._exportformat === "superfence" ? `\`\`\`{.logic height=${embedHeight} mode=${modeStr}${showOnlySpaceDelim === void 0 ? "" : `showonly=${showOnlySpaceDelim}`}}
${fullJson}
\`\`\`` : `\`\`\`{logic}
:height: ${embedHeight}
${modeParam}
${showOnlySpaceDelim === void 0 ? "" : `:showonly: ${showOnlySpaceDelim}
`}
${fullJson}
\`\`\``;
        this.html.embedMarkdown.value = markdownBlock;
        const showOnlyHtmlAttr = showOnlySpaceDelim === void 0 ? "" : ` showonly="${showOnlySpaceDelim}"`;
        const iframeEmbed = `<iframe style="width: 100%; height: ${embedHeight}px; border: 0"${showOnlyHtmlAttr} src="${fullUrl}"></iframe>`;
        this.html.embedIframe.value = iframeEmbed;
        const webcompEmbed = `<div style="width: 100%; height: ${embedHeight}px">
  <logic-editor mode="${Mode2[mode].toLowerCase()}"${showOnlyHtmlAttr}>
    <script type="application/json5">
      ${fullJson.replace(/\n/g, "\n      ")}
    <\/script>
  </logic-editor>
</div>`;
        this.html.embedWebcomp.value = webcompEmbed;
        this.saveToUrl(compressedJsonForUri, showOnlyArr);
        if (!showModal(this.html.embedDialog)) {
          if (copyToClipboard(fullUrl)) {
            console.log("  -> Copied!");
          } else {
            console.log("  -> Could not copy!");
          }
        }
      });
    }
    saveCurrentStateToUrl() {
      const { fullJson, compressedJsonForUri, showOnlyArr } = this.fullJsonStateAndCompressedForUri(true);
      console.log("Saved to URL compressed version of:\n" + fullJson);
      this.saveToUrl(compressedJsonForUri, showOnlyArr);
    }
    save() {
      return Serialization.buildCircuitObject(this);
    }
    saveToUrl(compressedUriSafeJson, showOnly) {
      if (this._isSingleton) {
        history.pushState(null, "", this.fullUrlForMode(MAX_MODE_WHEN_SINGLETON, compressedUriSafeJson, showOnly));
        this.clearDirty();
        this.showMessage(S.Messages.SavedToUrl);
      }
    }
    /**
     * @param removeShowOnly if showOnly should be removed from the JSON (first returned value.). It is always removed from the compressed version for the URL, since it is an explicit URL parameter.
     */
    fullJsonStateAndCompressedForUri(removeShowOnly) {
      let showOnlyArr = void 0;
      const jsonObj = Serialization.buildCircuitObject(this);
      if (removeShowOnly) {
        showOnlyArr = Serialization.removeShowOnlyFrom(jsonObj);
      }
      const fullJson = Serialization.stringifyObject(jsonObj, false);
      if (!removeShowOnly) {
        showOnlyArr = Serialization.removeShowOnlyFrom(jsonObj);
      }
      const jsonForUri = Serialization.stringifyObject(jsonObj, true);
      const compressedJsonForUri = LZString.compressToEncodedURIComponent(jsonForUri);
      return { fullJson, compressedJsonForUri, showOnlyArr };
    }
    fullUrlForMode(mode, compressedUriSafeJson, showOnlyArr) {
      const loc = window.location;
      const showOnlyParam = showOnlyArr === void 0 ? "" : `&${ATTRIBUTE_NAMES.showonly}=${showOnlyArr.join(",")}`;
      const currentLang = getLang();
      const hasCorrectLangParam = new URL(loc.href).searchParams.get(ATTRIBUTE_NAMES.lang) === currentLang;
      const langParam = !hasCorrectLangParam ? "" : `&${ATTRIBUTE_NAMES.lang}=${currentLang}`;
      return `${loc.protocol}//${loc.host}${loc.pathname}?${ATTRIBUTE_NAMES.mode}=${Mode2[mode].toLowerCase()}${langParam}${showOnlyParam}&${ATTRIBUTE_NAMES.data}=${compressedUriSafeJson}`;
    }
    toBase64(blob) {
      return new Promise((resolve, __) => {
        if (blob === null || blob === void 0) {
          resolve(void 0);
          return;
        }
        const reader = new FileReader();
        reader.onloadend = () => {
          const dataURL = reader.result;
          const asBase64 = dataURL.substring(dataURL.indexOf(",") + 1);
          resolve(asBase64);
        };
        reader.readAsDataURL(blob);
      });
    }
    toPNG(withMetadata, heightHint) {
      return __async(this, null, function* () {
        const pngBareBlob = yield new Promise((resolve) => {
          const drawingScale = 3;
          let [width, height] = this.guessAdequateCanvasSize(false);
          if (heightHint !== void 0) {
            height = heightHint;
          }
          width *= drawingScale;
          height *= drawingScale;
          const transform = new DOMMatrix(`scale(${drawingScale})`);
          const tmpCanvas = document.createElement("canvas");
          tmpCanvas.width = width;
          tmpCanvas.height = height;
          const g = _LogicEditor.getGraphics(tmpCanvas);
          const wasDark = isDarkMode();
          if (wasDark) {
            setDarkMode(false, false);
          }
          this.doDrawWithContext(g, width, height, transform, transform, true, true, false);
          if (wasDark) {
            setDarkMode(true, false);
          }
          tmpCanvas.toBlob(resolve, "image/png");
          tmpCanvas.remove();
        });
        if (pngBareBlob === null) {
          return void 0;
        }
        if (!withMetadata) {
          return pngBareBlob;
        }
        const { compressedJsonForUri } = this.fullJsonStateAndCompressedForUri(false);
        const pngBareData = new Uint8Array(yield pngBareBlob.arrayBuffer());
        const pngChunks = pngMeta.extractChunks(pngBareData);
        pngMeta.insertMetadata(pngChunks, { "tEXt": { "Description": compressedJsonForUri } });
        return new Blob([pngMeta.encodeChunks(pngChunks)], { type: "image/png" });
      });
    }
    toSVG(withMetadata) {
      return __async(this, null, function* () {
        const metadata = !withMetadata ? void 0 : Serialization.stringifyObject(Serialization.buildCircuitObject(this), false);
        const [width, height] = this.guessAdequateCanvasSize(false);
        const id = new DOMMatrix();
        const svgCtx = new SVGRenderingContext({ width, height, metadata });
        this.doDrawWithContext(svgCtx, width, height, id, id, true, true, false);
        const serializedSVG = svgCtx.getSerializedSvg();
        return Promise.resolve(new Blob([serializedSVG], { type: "image/svg+xml" }));
      });
    }
    download(data2, extension) {
      return __async(this, null, function* () {
        const blob = yield data2;
        if (blob === void 0) {
          return;
        }
        const filename = this.documentDisplayName + extension;
        (0, import_file_saver3.saveAs)(blob, filename);
      });
    }
    setTestsPaletteVisible(visible) {
      var _a;
      this.editTools.testsPalette.setVisible(visible);
      (_a = this._topBar) == null ? void 0 : _a.updateTestPaletteVisible(visible);
    }
    didLoadTests(testSuites) {
      var _a;
      const numTests = testSuites.totalCases();
      (_a = this._topBar) == null ? void 0 : _a.setTestPaletteButtonVisible(numTests);
      this.setTestsPaletteVisible(numTests > 0);
    }
    addTestCases(result) {
      var _a, _b, _c;
      let testSuite;
      if (this.testSuites.suites.length > 0) {
        testSuite = this.testSuites.suites[0];
      } else {
        testSuite = new TestSuite();
        this.testSuites.push(testSuite);
      }
      if (!Array.isArray(result)) {
        testSuite.testCases.push(result);
      } else {
        testSuite.testCases.push(...result);
      }
      (_a = this.ifEditing) == null ? void 0 : _a.setDirty("added test case");
      (_b = this.ifEditing) == null ? void 0 : _b.undoMgr.takeSnapshot();
      (_c = this.ifEditing) == null ? void 0 : _c.testsPalette.update();
    }
    removeTestCase(testCase) {
      var _a, _b, _c;
      for (const testSuite of this.testSuites.suites) {
        const idx = testSuite.testCases.indexOf(testCase);
        if (idx >= 0) {
          testSuite.testCases.splice(idx, 1);
          (_a = this.ifEditing) == null ? void 0 : _a.setDirty("removed test case");
          (_b = this.ifEditing) == null ? void 0 : _b.undoMgr.takeSnapshot();
          (_c = this.ifEditing) == null ? void 0 : _c.testsPalette.update();
          return;
        }
      }
    }
    disableUIWhile(message, action) {
      return __async(this, null, function* () {
        if (this._isRunningOrCreatingTests) {
          return void 0;
        }
        this._isRunningOrCreatingTests = true;
        const oldMode = this.mode;
        const restoreAfter = /* @__PURE__ */ new Map();
        const hideMsg = this.showMessage(message, 0);
        try {
          this.setMode(0 /* STATIC */, false);
          const result = yield action(restoreAfter);
          return result;
        } finally {
          hideMsg();
          this.setMode(oldMode, true);
          for (const [input2, value] of restoreAfter) {
            input2.setValue(value);
          }
          this.recalcPropagateAndDrawIfNeeded();
          yield this.waitForPropagation();
          this._isRunningOrCreatingTests = false;
        }
      });
    }
    runTestSuite(testSuite, options) {
      return __async(this, null, function* () {
        var _a, _b;
        const palette = this.editTools.testsPalette;
        if (palette === void 0) {
          return void 0;
        }
        const fast = (_a = options == null ? void 0 : options.fast) != null ? _a : false;
        const doLog = (_b = options == null ? void 0 : options.doLog) != null ? _b : false;
        return this.disableUIWhile(S.Messages.RunningTests, (restoreAfter) => __async(this, null, function* () {
          this.setTestsPaletteVisible(true);
          const results = new TestSuiteResults(testSuite);
          const ui = palette.getOrMakeUIFor(testSuite);
          let isFirst = true;
          let skip = false;
          for (let i2 = 0; i2 < testSuite.testCases.length; i2++) {
            const testCase = testSuite.testCases[i2];
            ui.setRunning(i2);
            if (isFirst) {
              isFirst = false;
            } else if (!skip && !fast) {
              yield new Promise((resolve) => setTimeout(resolve, 2e3));
            }
            let testCaseResult;
            if (skip) {
              testCaseResult = TestCaseResult.Skip;
            } else {
              const [oldInValues, result] = yield this.runTestCase(testCase, testSuite, doLog);
              testCaseResult = result;
              for (const [input2, value] of oldInValues) {
                if (!restoreAfter.has(input2)) {
                  restoreAfter.set(input2, value);
                }
              }
            }
            results.addTestCaseResult(testCase, testCaseResult);
            ui.setResult(i2, testCaseResult);
            if (testCase.stopOnFail && testCaseResult._tag === "fail") {
              skip = true;
            }
          }
          return results;
        }));
      });
    }
    trySetInputsAndRecalc(inputs) {
      for (const [input2, valueRepr] of inputs) {
        if (!isString(input2)) {
          input2.setValue(valuesFromReprForInput(valueRepr, input2.numBits));
        } else {
          console.error(`Input component ${input2} not found`);
        }
      }
      this.recalcPropagateAndDrawIfNeeded(false);
    }
    runTestCase(testCase, sourceSuite, doLog) {
      return __async(this, null, function* () {
        if (doLog) {
          const fullTestNameParts = [sourceSuite.name, testCase.name].filter(Boolean);
          const fullTestName = fullTestNameParts.length === 0 ? S.Tests.DefaultTestCaseName : fullTestNameParts.join("/");
          console.group("Running test case " + fullTestName);
        }
        testCase.tryFixReferences(this.editorRoot.components);
        const oldInValues = /* @__PURE__ */ new Map();
        try {
          for (const [input2, valueRepr] of testCase.in) {
            if (isString(input2)) {
              return [oldInValues, TestCaseResult.Error(`Input component ${input2} not found`)];
            }
            oldInValues.set(input2, input2.value);
            input2.setValue(valuesFromReprForInput(valueRepr, input2.numBits));
          }
          this.recalcPropagateAndDrawIfNeeded(true);
          yield this.waitForPropagation();
          const mismatches = [];
          for (const [output, expectedRepr] of testCase.out) {
            if (isString(output)) {
              return [oldInValues, TestCaseResult.Error(`Output component ${output} not found`)];
            }
            const actual = output.value;
            const expected = valuesFromReprForInput(expectedRepr, output.numBits);
            if (!deepArrayEquals(actual, expected)) {
              mismatches.push({ output, expected, actual });
              if (doLog) {
                const failMsg = `${output.ref} is ${actual} instead of ${expected}`;
                console.log(`%cFAIL:%c ${failMsg}`, "color: red; font-weight: bold;", "");
              }
            } else {
              if (doLog) {
                const passMsg = `${output.ref} is ${expected}`;
                console.log(`%cPASS:%c ${passMsg}`, "color: green; font-weight: bold;", "");
              }
            }
          }
          return [oldInValues, mismatches.length === 0 ? TestCaseResult.Pass : TestCaseResult.Fail(mismatches)];
        } finally {
          if (doLog) {
            console.groupEnd();
          }
        }
      });
    }
    /**
     * Make sure that `recalcPropagateAndDrawIfNeeded` has been called after the change
     * with an argument of `true` to force the redraw and reset the promise if needed.
     */
    waitForPropagation() {
      return this._propagationPromise;
    }
    /**
     * @param forceNow This must be `true` only if we have just changed values manually
     * and we need to bypass and cancel the possible next animation frame to make sure we
     * renew the propagation promise right now. Otherwise, the next animation frame
     * will take care of the redraw.
     */
    recalcPropagateAndDrawIfNeeded(forceNow = false) {
      var _a, _b;
      if (this._nextAnimationFrameHandle !== null) {
        if (!forceNow) {
          return;
        } else {
          cancelAnimationFrame(this._nextAnimationFrameHandle);
          this._nextAnimationFrameHandle = null;
        }
      }
      const __recalculated = this.recalcMgr.recalcAndPropagateIfNeeded();
      const redrawMgr = this.editTools.redrawMgr;
      const linkMgr = this._editorRoot.linkMgr;
      if (linkMgr.isAddingWire || linkMgr.isSettingAnchor) {
        redrawMgr.requestRedraw({ why: "adding a wire/setting anchor" });
      }
      const animateWires = this._options.animateWires;
      const redrawInfo = redrawMgr.getReasonsAndClear();
      if (redrawInfo === void 0 && !animateWires) {
        return;
      }
      if (redrawInfo !== void 0 && this._propagationResolve === void 0) {
        this._propagationPromise = new Promise((resolve) => {
          this._propagationResolve = resolve;
        });
      }
      const redrawMask = (_a = redrawInfo == null ? void 0 : redrawInfo.redrawMask) != null ? _a : false;
      this.doRedraw(redrawMask);
      const invalidateTests = (_b = redrawInfo == null ? void 0 : redrawInfo.invalidateTests) != null ? _b : false;
      if (invalidateTests && !this._isRunningOrCreatingTests) {
        this.editTools.testsPalette.clearDisplayedResults();
      }
      if (!redrawMgr.isAnyValuePropagating()) {
        if (this._propagationResolve !== void 0) {
          if (!this.timeline.hasPendingCallbacksNow()) {
            this._propagationResolve();
            this._propagationResolve = void 0;
          } else {
          }
        }
      }
      if (animateWires || redrawMgr.hasReasons()) {
        this._nextAnimationFrameHandle = requestAnimationFrame(() => {
          this._nextAnimationFrameHandle = null;
          this.recalcPropagateAndDrawIfNeeded();
        });
      }
    }
    highlight(refs) {
      if (refs === void 0) {
        this._highlightedItems = void 0;
        return;
      }
      if (isString(refs)) {
        refs = [refs];
      }
      const highlightComps = [];
      const highlightWires = [];
      if (!isArray(refs)) {
        highlightComps.push(refs);
      } else {
        for (const comp of this.components.all()) {
          if (comp.ref !== void 0 && refs.includes(comp.ref)) {
            highlightComps.push(comp);
          }
        }
        for (const wire of this.linkMgr.wires) {
          if (wire.ref !== void 0 && refs.includes(wire.ref)) {
            highlightWires.push(wire);
          }
        }
        if (highlightComps.length === 0 && highlightWires.length === 0) {
          console.log(`Nothing to highlight for ref '${refs}'`);
          this._highlightedItems = void 0;
          return;
        }
      }
      const start2 = this.timeline.unadjustedTime();
      this._highlightedItems = { comps: highlightComps, wires: highlightWires, start: start2 };
      this.editTools.redrawMgr.requestRedraw({ why: "highlighting component" });
      this.recalcPropagateAndDrawIfNeeded();
    }
    redraw() {
      this.setCanvasSize();
      this.editTools.redrawMgr.requestRedraw({ why: "explicit redraw call", invalidateMask: true });
      this.recalcPropagateAndDrawIfNeeded();
    }
    doRedraw(redrawMask) {
      var _a;
      (_a = this._topBar) == null ? void 0 : _a.updateTimeLabelIfNeeded();
      const g = _LogicEditor.getGraphics(this.html.mainCanvas);
      const mainCanvas = this.html.mainCanvas;
      const baseDrawingScale = this._baseDrawingScale;
      const width = mainCanvas.width / baseDrawingScale;
      const height = mainCanvas.height / baseDrawingScale;
      const baseTransform = new DOMMatrix(`scale(${this._baseDrawingScale})`);
      const contentTransform = baseTransform.scale(this._actualZoomFactor);
      this.doDrawWithContext(g, width, height, baseTransform, contentTransform, false, false, redrawMask);
    }
    doDrawWithContext(g, width, height, baseTransform, contentTransform, skipBorder, transparentBackground, __redrawMask) {
      var _a, _b;
      g.setTransform(baseTransform);
      g.lineCap = "square";
      g.textBaseline = "alphabetic";
      g.fillStyle = COLOR_BACKGROUND;
      if (transparentBackground) {
        g.clearRect(0, 0, width, height);
      } else {
        g.fillRect(0, 0, width, height);
      }
      g.setTransform(contentTransform);
      const highlightRectFor = /* @__PURE__ */ __name((comp) => {
        const margin = 15;
        let w = comp.unrotatedWidth + margin + margin;
        let h = comp.unrotatedHeight + margin + margin;
        if (Orientation.isVertical(comp.orient)) {
          const t38 = w;
          w = h;
          h = t38;
        }
        return new DOMRect(comp.posX - w / 2, comp.posY - h / 2, w, h);
      }, "highlightRectFor");
      const highlightedItems = this._highlightedItems;
      let highlightColor = void 0;
      if (highlightedItems !== void 0) {
        const HOLD_TIME = 2e3;
        const FADE_OUT_TIME = 200;
        const START_ALPHA = 0.4;
        const elapsed = this.timeline.unadjustedTime() - highlightedItems.start;
        const highlightAlpha = elapsed < HOLD_TIME ? START_ALPHA : START_ALPHA * (1 - (elapsed - HOLD_TIME) / FADE_OUT_TIME);
        if (highlightAlpha <= 0) {
          this._highlightedItems = void 0;
        } else {
          g.beginPath();
          for (const comp of highlightedItems.comps) {
            const highlightRect = highlightRectFor(comp);
            g.moveTo(highlightRect.x, highlightRect.y);
            g.lineTo(highlightRect.right, highlightRect.y);
            g.lineTo(highlightRect.right, highlightRect.bottom);
            g.lineTo(highlightRect.x, highlightRect.bottom);
            g.closePath();
          }
          highlightColor = `rgba(238,241,0,${highlightAlpha})`;
          g.shadowColor = highlightColor;
          g.shadowBlur = 20;
          g.shadowOffsetX = 0;
          g.shadowOffsetY = 0;
          g.fillStyle = highlightColor;
          g.fill();
          g.shadowBlur = 0;
          this.editTools.redrawMgr.requestRedraw({ why: "highlight animation" });
        }
      }
      const moveMgr = this.editTools.moveMgr;
      const isMovingComponent = moveMgr.areDrawablesMoving();
      if (isMovingComponent) {
        g.beginGroup("grid");
        const widthAdjusted = width / this._actualZoomFactor;
        const heightAdjusted = height / this._actualZoomFactor;
        const step = GRID_STEP;
        g.strokeStyle = COLOR_GRID_LINES;
        g.lineWidth = 1;
        g.beginPath();
        for (let x = step; x < widthAdjusted; x += step) {
          g.moveTo(x, 0);
          g.lineTo(x, height);
        }
        for (let y = step; y < heightAdjusted; y += step) {
          g.moveTo(0, y);
          g.lineTo(width, y);
        }
        g.stroke();
        g.endGroup();
      }
      const singleMovingWayoint = moveMgr.getSingleMovingWaypoint();
      if (singleMovingWayoint !== void 0) {
        g.beginGroup("guides");
        const guides = singleMovingWayoint.getPrevAndNextAnchors();
        g.strokeStyle = COLOR_GRID_LINES_GUIDES;
        g.lineWidth = 1.5;
        g.beginPath();
        for (const guide of guides) {
          g.moveTo(guide.posX, 0);
          g.lineTo(guide.posX, height);
          g.moveTo(0, guide.posY);
          g.lineTo(width, guide.posY);
        }
        g.stroke();
        g.endGroup();
      }
      if (!skipBorder && (this._mode >= 2 /* CONNECT */ || this._maxInstanceMode === MAX_MODE_WHEN_SINGLETON)) {
        g.beginGroup("border");
        g.setTransform(baseTransform);
        g.strokeStyle = COLOR_BORDER;
        g.lineWidth = 2;
        if (this._maxInstanceMode === MAX_MODE_WHEN_SINGLETON && this._mode < this._maxInstanceMode) {
          g.strokeRect(0, 0, width, height);
          const h = this.guessAdequateCanvasSize(true)[1];
          strokeSingleLine(g, 0, h, width, h);
          g.fillStyle = COLOR_BACKGROUND_UNUSED_REGION;
          g.fillRect(0, h, width, height - h);
        } else {
          const myX = this.html.mainCanvas.getBoundingClientRect().x;
          const [x1, x2] = (_b = (_a = this._topBar) == null ? void 0 : _a.getActiveTabCoords()) != null ? _b : [0, 0];
          g.beginPath();
          g.moveTo(x1 - myX, 0);
          g.lineTo(0, 0);
          g.lineTo(0, height);
          g.lineTo(width, height);
          g.lineTo(width, 0);
          g.lineTo(x2 - myX, 0);
          g.stroke();
        }
        g.setTransform(contentTransform);
        g.endGroup();
      }
      const drawTime = this.timeline.logicalTime();
      const drawTimeAnimationFraction = !this._options.animateWires ? void 0 : drawTime / 1e3 % 1;
      g.strokeStyle = COLOR_COMPONENT_BORDER;
      const currentMouseOverComp = this.eventMgr.currentMouseOverComp;
      const drawParams = {
        drawTime,
        drawTimeAnimationFraction,
        currentMouseOverComp,
        highlightedItems,
        highlightColor,
        currentSelection: void 0,
        anythingMoving: moveMgr.areDrawablesMoving()
      };
      const currentSelection = this.eventMgr.currentSelection;
      drawParams.currentSelection = currentSelection;
      const drawComp = /* @__PURE__ */ __name((comp) => {
        g.beginGroup(comp.constructor.name);
        try {
          comp.draw(g, drawParams);
          for (const node of comp.allNodes()) {
            node.draw(g, drawParams);
          }
        } finally {
          g.endGroup();
        }
      }, "drawComp");
      const root = this._editorRoot;
      g.beginGroup("background");
      for (const comp of root.components.withZIndex(DrawZIndex.Background)) {
        drawComp(comp);
      }
      g.endGroup();
      g.beginGroup("wires");
      root.linkMgr.draw(g, drawParams);
      g.endGroup();
      g.beginGroup("components");
      for (const comp of root.components.withZIndex(DrawZIndex.Normal)) {
        drawComp(comp);
      }
      g.endGroup();
      const movingCompWithAnchor = moveMgr.getSingleMovingComponentWithAnchors();
      if (movingCompWithAnchor !== void 0) {
        g.beginGroup("anchors");
        drawAnchorsAroundComponent(g, movingCompWithAnchor, true);
        g.endGroup();
      } else if (this._options.showAnchors) {
        g.beginGroup("anchors");
        for (const comp of root.components.all()) {
          drawAnchorsAroundComponent(g, comp, false);
        }
        g.endGroup();
      }
      g.beginGroup("overlays");
      for (const comp of root.components.withZIndex(DrawZIndex.Overlay)) {
        drawComp(comp);
      }
      g.endGroup();
      if (this._options.showIDs) {
        g.beginGroup("refs");
        g.font = "bold 14px sans-serif";
        g.strokeStyle = "white";
        g.lineWidth = 3;
        g.fillStyle = COLOR_COMPONENT_ID;
        g.textAlign = "center";
        for (const comp of root.components.all()) {
          if (comp.ref !== void 0) {
            strokeTextVAlign(g, TextVAlign.middle, comp.ref, comp.posX, comp.posY);
            fillTextVAlign(g, TextVAlign.middle, comp.ref, comp.posX, comp.posY);
          }
        }
        g.endGroup();
      }
      let selRect;
      if (currentSelection !== void 0 && (selRect = currentSelection.currentlyDrawnRect) !== void 0) {
        g.beginGroup("selection");
        g.lineWidth = 1.5;
        g.strokeStyle = "rgb(100,100,255)";
        g.fillStyle = "rgba(100,100,255,0.2)";
        g.beginPath();
        g.rect(selRect.x, selRect.y, selRect.width, selRect.height);
        g.stroke();
        g.fill();
        g.endGroup();
      }
    }
    cut() {
      console.log("cut");
    }
    copy() {
      var _a, _b;
      if (this.eventMgr.currentSelectionEmpty()) {
        return false;
      }
      const componentsToInclude = [];
      for (const elem of (_b = (_a = this.eventMgr.currentSelection) == null ? void 0 : _a.previouslySelectedElements) != null ? _b : []) {
        if (elem instanceof ComponentBase) {
          componentsToInclude.push(elem);
        }
      }
      const reprs = Serialization.buildComponentsAndWireObject(componentsToInclude, [], [this.mouseX, this.mouseY]);
      if (reprs.components === void 0 && reprs.wires === void 0) {
        return false;
      }
      const jsonStr = Serialization.stringifyObject(reprs, false);
      console.log("Copied:\n" + jsonStr);
      copyToClipboard(jsonStr);
      this.focus();
      return true;
    }
    paste() {
      const oldDontHogFocus = this._dontHogFocus;
      this._dontHogFocus = true;
      let jsonStr = void 0;
      try {
        jsonStr = pasteFromClipboard();
      } finally {
        this._dontHogFocus = oldDontHogFocus;
      }
      if (jsonStr === void 0 || jsonStr === "") {
        return;
      }
      const errorOrComps = Serialization.pasteComponents(this, jsonStr);
      if (isString(errorOrComps)) {
        console.log(errorOrComps);
      } else {
        const selection = new EditorSelection(void 0);
        for (const comp of errorOrComps) {
          selection.toggle(comp);
        }
        this.eventMgr.currentSelection = selection;
      }
      this.focus();
    }
    wrapHandler(f) {
      return (...params) => {
        const result = f(...params);
        this.recalcPropagateAndDrawIfNeeded();
        return result;
      };
    }
    static decodeFromURLOld(str) {
      return decodeURIComponent(atob(str.replace(/-/g, "+").replace(/_/g, "/").replace(/%3D/g, "=")));
    }
    static getGraphics(canvas2) {
      const g = canvas2.getContext("2d");
      g.createPath = (path) => new Path2D(path);
      g.beginGroup = () => void 0;
      g.endGroup = () => void 0;
      return g;
    }
  };
  var LogicEditor = _LogicEditor;
  __name(LogicEditor, "LogicEditor");
  LogicEditor._globalListenersInstalled = false;
  LogicEditor._allConnectedEditors = [];
  var LogicStatic = class {
    constructor(template2) {
      this.template = template2;
      this.tests = new Tests();
      this.Serialization = Serialization;
    }
    highlight(diagramRefs, componentRefs) {
      if (isString(diagramRefs)) {
        diagramRefs = [diagramRefs];
      }
      for (const diagramRef of diagramRefs) {
        const diagram = document.getElementById("logic_" + diagramRef);
        if (diagram === null) {
          console.log(`Cannot find logic diagram with reference '${diagramRef}'`);
          return;
        }
        if (!(diagram instanceof LogicEditor)) {
          console.log(`Element with id '${diagramRef}' is not a logic editor`);
          return;
        }
        diagram.highlight(componentRefs);
      }
    }
    runSampleTestSuite(options) {
      const f = /* @__PURE__ */ __name(() => __async(this, null, function* () {
        if (this.singleton) {
          const testSuite = new TestSuite([{
            name: "Simple XOR gate test suite",
            cases: [{
              name: "false false -> false",
              in: { in0: 0, in1: 0 },
              out: { out0: 0 },
              stopOnFail: true
            }, {
              name: "false true -> true",
              in: { in0: 1, in1: 0 },
              out: { out0: 1 }
            }, {
              name: "true false -> true",
              in: { in0: 0, in1: 1 },
              out: { out0: 1 }
            }, {
              name: "true true -> false",
              in: { in0: 1, in1: 1 },
              out: { out0: 0 }
            }]
          }, this.singleton.editorRoot.components]);
          const _opts = isRecord(options) ? options : {};
          const results = yield this.singleton.runTestSuite(testSuite, _opts);
          if (results === void 0) {
            console.error("Could not run test suite");
          } else {
            results.dump();
          }
        }
      }), "f");
      setTimeout(f, 0);
    }
    printUndoStack() {
      var _a;
      (_a = this.singleton) == null ? void 0 : _a.editTools.undoMgr.dump();
    }
    setDarkMode(mode) {
      if (mode === "auto") {
        mode = window.matchMedia("(prefers-color-scheme: dark)").matches;
      } else if (mode === "false") {
        mode = false;
      } else if (isString(mode)) {
        const col = parseColorToRGBA(mode);
        if (col !== void 0) {
          const rgbaString = col[3] === 255 ? `rgb(${col[0]}, ${col[1]}, ${col[2]})` : `rgba(${col[0]}, ${col[1]}, ${col[2]}, ${col[3] / 255})`;
          USER_COLORS.COLOR_BACKGROUND = rgbaString;
          const looksDark = col[0] + col[1] + col[2] < 3 * 128;
          console.log(`Will use '${rgbaString}' as background color, interpreted as a ${looksDark ? "dark" : "light"} theme`);
          mode = looksDark;
        }
      }
      setDarkMode(Boolean(mode), true);
    }
  };
  __name(LogicStatic, "LogicStatic");
  if (InBrowser) {
    const template2 = (() => {
      const template3 = document.createElement("template");
      template3.innerHTML = LogicEditorTemplate_default;
      const styles = [LogicEditor_default, dialog_polyfill_default];
      template3.content.querySelector("#inlineStyle").innerHTML = styles.join("\n\n\n");
      template3.content.querySelectorAll("i.svgicon").forEach(setupSvgIcon);
      return template3;
    })();
    window.Logic = new LogicStatic(template2);
    window.customElements.define("logic-editor", LogicEditor);
    document.addEventListener("toggle", (e) => {
      if (!(e.target instanceof HTMLDetailsElement)) {
        return;
      }
      if (e.target.open) {
        e.target.querySelectorAll("logic-editor").forEach((el) => {
          if (el instanceof LogicEditor) {
            el.redraw();
          }
        });
      }
    }, true);
  } else {
    console.log("cli");
  }
})();
//# sourceMappingURL=bundle-dev.js.map
